<table>    <tr>
      <td>Opcode</td>
      <td>Description</td>
      <td>Flags</td>
    </tr>
<tr><td><strong>AAA</strong><br />ASCII Adjust After Addition<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>37</code></td>
<td class="grid"><code>AAA</code></td>
<td class="grid">ASCII adjust AL after addition</td>
</tr>
</table></td><td>
<p>Adjusts the sum of two unpacked BCD values to create an unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAA instruction is only useful when it follows an ADD instruction that adds (binary addition) two unpacked BCD values and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.</p>
<p>If the addition produces a decimal carry, the AH register increments by 1, and the CF and AF flags are set. If there was no decimal carry, the CF and AF flags are cleared and the AH register is unchanged. In either case, bits 4 through 7 of the AL register are set to 0.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>AL <span class="operator">&amp;</span> <span class="number">0xF</span><span class="operator">)</span> <span class="operator">&gt;</span> <span class="number">9</span> <span class="operator">||</span> AF <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> {
	AL <span class="operator">=</span> AL <span class="operator">+</span> <span class="number">6</span><span class="operator">;</span>
	AH <span class="operator">=</span> AH <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
	AF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
	CF <span class="operator">=</span> <span class="number">1</span>
}
<span class="keyword">else</span> {
	AF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
}
AL <span class="operator">=</span> AL <span class="operator">&amp;</span> <span class="number">0xF</span><span class="operator">;</span>
</pre>
</td><td>
<p>The AF and CF flags are set to 1 if the adjustment results in a decimal carry; otherwise they are set to 0. The OF, SF, ZF, and PF flags are undefined.
</p>
</td></tr><tr><td><strong>AAD</strong><br />ASCII Adjust AX Before Division<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D5 0A</code></td>
<td class="grid"><code>AAD</code></td>
<td class="grid">ASCII adjust AX before division</td>
</tr>
<tr>
<td class="grid"><code>D5 ib</code></td>
<td class="grid"><code>(No mnemonic)</code></td>
<td class="grid">Adjust AX before division to number base imm8</td>
</tr>
</table></td><td>
<p>Adjusts two unpacked BCD digits (the least-significant digit in the AL register and the mostsignificant digit in the AH register) so that a division operation performed on the result will yield a correct unpacked BCD value. The AAD instruction is only useful when it precedes a DIV instruction that divides (binary division) the adjusted value in the AX register by an unpacked BCD value.</p>
<p>The AAD instruction sets the value in the AL register to (AL + (10 * AH)), and then clears the AH register to 00H. The value in the AX register is then equal to the binary equivalent of the original unpacked two-digit (base 10) number in registers AH and AL.</p>
<p>The generalized version of this instruction allows adjustment of two unpacked digits of any number base (see the &quot;{operation}&quot; section below), by setting the imm8 byte to the selected number base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAD mnemonic is interpreted by all assemblers to mean adjust ASCII (base 10) values. To adjust values in another number base, the instruction must be hand coded in machine code (D5 imm8).</p>
<br />
<pre><span class="comment">//imm8 is set to 0AH for the AAD mnemonic</span>
TemporaryAL <span class="operator">=</span> AL<span class="operator">;</span>
TemporaryAH <span class="operator">=</span> AH<span class="operator">;</span>
AL <span class="operator">=</span> TemporaryAL <span class="operator">+</span> <span class="operator">(</span>TemporaryAH <span class="operator">*</span> imm8<span class="operator">)</span> <span class="operator">&amp;</span> <span class="number">0xFF</span><span class="operator">;</span>
AH <span class="operator">=</span> <span class="number">0</span>
</pre>
</td><td>
<p>The SF, ZF, and PF flags are set according to the resulting binary value in the AL register; the OF, AF, and CF flags are undefined.
</p>
</td></tr><tr><td><strong>AAS</strong><br />ASCII Adjust AL After Subtraction<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>3F</code></td>
<td class="grid"><code>AAS</code></td>
<td class="grid">ASCII adjust AL after subtraction</td>
</tr>
</table></td><td>
<p>Adjusts the result of the subtraction of two unpacked BCD values to create a unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtraction) one unpacked BCD value from another and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.</p>
<p>If the subtraction produced a decimal carry, the AH register decrements by 1, and the CF and AF flags are set. If no decimal carry occurred, the CF and AF flags are cleared, and the AH register is unchanged. In either case, the AL register is left with its top nibble set to 0.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>AL <span class="operator">&amp;</span> <span class="number">0xF</span><span class="operator">)</span> <span class="operator">&gt;</span> <span class="number">9</span> <span class="operator">||</span> AF <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> {
	AL <span class="operator">=</span> AL <span class="operator">-</span> <span class="number">6</span><span class="operator">;</span>
	AH <span class="operator">=</span> AH <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
	AF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
	CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	AF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
}
AL <span class="operator">=</span> AL <span class="operator">&amp;</span> <span class="number">0xF</span><span class="operator">;</span>
</pre>
</td><td>
<p>The AF and CF flags are set to 1 if there is a decimal borrow; otherwise, they are set to 0. The OF, SF, ZF, and PF flags are undefined.
</p>
</td></tr><tr><td><strong>ADC</strong><br />Add with Carry<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>14 ib</code></td>
<td class="grid"><code>ADC AL, imm8</code></td>
<td class="grid">Add with carry imm8 to AL</td>
</tr>
<tr>
<td class="grid"><code>15 iw</code></td>
<td class="grid"><code>ADC AX, imm16</code></td>
<td class="grid">Add with carry imm16 to AX</td>
</tr>
<tr>
<td class="grid"><code>15 id</code></td>
<td class="grid"><code>ADC EAX, imm32</code></td>
<td class="grid">Add with carry imm32 to EAX</td>
</tr>
<tr>
<td class="grid"><code>80 /2 ib</code></td>
<td class="grid"><code>ADC r/m8, imm8</code></td>
<td class="grid">Add with carry imm8 to r/m8</td>
</tr>
<tr>
<td class="grid"><code>81 /2 iw</code></td>
<td class="grid"><code>ADC r/m16, imm16</code></td>
<td class="grid">Add with carry imm16 to r/m16</td>
</tr>
<tr>
<td class="grid"><code>81 /2 id</code></td>
<td class="grid"><code>ADC r/m32, imm32</code></td>
<td class="grid">Add with CF imm32 to r/m32</td>
</tr>
<tr>
<td class="grid"><code>83 /2 ib</code></td>
<td class="grid"><code>ADC r/m16, imm8</code></td>
<td class="grid">Add with CF sign-extended imm8 to r/m16</td>
</tr>
<tr>
<td class="grid"><code>83 /2 ib</code></td>
<td class="grid"><code>ADC r/m32, imm8</code></td>
<td class="grid">Add with CF sign-extended imm8 into r/m32</td>
</tr>
<tr>
<td class="grid"><code>10 /r</code></td>
<td class="grid"><code>ADC r/m8, r8</code></td>
<td class="grid">Add with carry byte register to r/m8</td>
</tr>
<tr>
<td class="grid"><code>11 /r</code></td>
<td class="grid"><code>ADC r/m16, r16</code></td>
<td class="grid">Add with carry r16 to r/m16</td>
</tr>
<tr>
<td class="grid"><code>11 /r</code></td>
<td class="grid"><code>ADC r/m32, r32</code></td>
<td class="grid">Add with CF r32 to r/m32</td>
</tr>
<tr>
<td class="grid"><code>12 /r</code></td>
<td class="grid"><code>ADC r8, r/m8</code></td>
<td class="grid">Add with carry r/m8 to byte register</td>
</tr>
<tr>
<td class="grid"><code>13 /r</code></td>
<td class="grid"><code>ADC r16, r/m16</code></td>
<td class="grid">Add with carry r/m16 to r16</td>
</tr>
<tr>
<td class="grid"><code>13 /r</code></td>
<td class="grid"><code>ADC r32, r/m32</code></td>
<td class="grid">Add with CF r/m32 to r32</td>
</tr>
</table></td><td>
<p>Adds the destination operand (first operand), the source operand (second operand), and the carry (CF) flag and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a carry from a previous addition. When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</p>
<p>The ADC instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a carry in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.</p>
<p>The ADC instruction is usually executed as part of a multibyte or multiword addition in which an ADD instruction is followed by an ADC instruction.</p>
<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<br />
<pre>Destination <span class="operator">=</span> Destination <span class="operator">+</span> Source <span class="operator">+</span> CF<span class="operator">;</span>
</pre>
</td><td>
<p>The OF, SF, ZF, AF, CF, and PF flags are set according to the result.
</p>
</td></tr><tr><td><strong>ADD</strong><br />Add<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>04 ib</code></td>
<td class="grid"><code>ADD AL, imm8</code></td>
<td class="grid">Add imm8 to AL</td>
</tr>
<tr>
<td class="grid"><code>05 iw</code></td>
<td class="grid"><code>ADD AX, imm16</code></td>
<td class="grid">Add imm16 to AX</td>
</tr>
<tr>
<td class="grid"><code>05 id</code></td>
<td class="grid"><code>ADD EAX, imm32</code></td>
<td class="grid">Add imm32 to EAX</td>
</tr>
<tr>
<td class="grid"><code>80 /0 ib</code></td>
<td class="grid"><code>ADD r/m8, imm8</code></td>
<td class="grid">Add imm8 to r/m8</td>
</tr>
<tr>
<td class="grid"><code>81 /0 iw</code></td>
<td class="grid"><code>ADD r/m16, imm16</code></td>
<td class="grid">Add imm16 to r/m16</td>
</tr>
<tr>
<td class="grid"><code>81 /0 id</code></td>
<td class="grid"><code>ADD r/m32, imm32</code></td>
<td class="grid">Add imm32 to r/m32</td>
</tr>
<tr>
<td class="grid"><code>83 /0 ib</code></td>
<td class="grid"><code>ADD r/m16, imm8</code></td>
<td class="grid">Add sign-extended imm8 to r/m16</td>
</tr>
<tr>
<td class="grid"><code>83 /0 ib</code></td>
<td class="grid"><code>ADD r/m32, imm8</code></td>
<td class="grid">Add sign-extended imm8 to r/m32</td>
</tr>
<tr>
<td class="grid"><code>00 /r</code></td>
<td class="grid"><code>ADD r/m8, r8</code></td>
<td class="grid">Add r8 to r/m8</td>
</tr>
<tr>
<td class="grid"><code>01 /r</code></td>
<td class="grid"><code>ADD r/m16, r16</code></td>
<td class="grid">Add r16 to r/m16</td>
</tr>
<tr>
<td class="grid"><code>01 /r</code></td>
<td class="grid"><code>ADD r/m32, r32</code></td>
<td class="grid">Add r32 to r/m32</td>
</tr>
<tr>
<td class="grid"><code>02 /r</code></td>
<td class="grid"><code>ADD r8, r/m8</code></td>
<td class="grid">Add r/m8 to r8</td>
</tr>
<tr>
<td class="grid"><code>03 /r</code></td>
<td class="grid"><code>ADD r16, r/m16</code></td>
<td class="grid">Add r/m16 to r16</td>
</tr>
<tr>
<td class="grid"><code>03 /r</code></td>
<td class="grid"><code>ADD r32, r/m32</code></td>
<td class="grid">Add r/m32 to r32</td>
</tr>
</table></td><td>
<p>Adds the first operand (destination operand) and the second operand (source operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</p>
<p>The ADD instruction performs integer addition. It evaluates the result for both signed and unsigned integer operands and sets the OF and CF flags to indicate a carry (overflow) in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.</p>
<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<br />
<pre>Destination <span class="operator">=</span> Destination <span class="operator">+</span> Source<span class="operator">;</span>
</pre>
</td><td>
<p>The OF, SF, ZF, AF, CF, and PF flags are set according to the result.
</p>
</td></tr><tr><td><strong>ADDPD</strong><br />Add Packed Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 58 /r</code></td>
<td class="grid"><code>ADDPD xmm1, xmm2/m128</code></td>
<td class="grid">Add packed double-precision floating-point values from xmm2/m128 to xmm1.</td>
</tr>
</table></td><td>
<p>Performs an SIMD add of the two packed double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the packed double-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
Overflow, Underflow, Invalid, Precision, Denormal.
</td></tr><tr><td><strong>ADDPS</strong><br />Add Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 58 /r</code></td>
<td class="grid"><code>ADDPS xmm1, xmm2/m128</code></td>
<td class="grid">Add packed single-precision floating-point values from xmm2/m128 to xmm1.</td>
</tr>
</table></td><td>
<p>Performs an SIMD add of the four packed single-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">127</span><span class="operator">-</span><span class="number">96</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
Overflow, Underflow, Invalid, Precision, Denormal.
</td></tr><tr><td><strong>ADDSD</strong><br />Add Scalar Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 58 /r</code></td>
<td class="grid"><code>ADDSD xmm1, xmm2/m64</code></td>
<td class="grid">Add the low double-precision floating-point value from xmm2/m64 to xmm1.</td>
</tr>
</table></td><td>
<p>Adds the low double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the double-precision floating-point result in the destination operand. The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. The high quadword of the destination operand remains unchanged.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[64..127] remains unchanged</span>
</pre>
</td><td>
Overflow, Underflow, Invalid, Precision, Denormal.
</td></tr><tr><td><strong>ADDSS</strong><br />Add Scalar Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 58 /r</code></td>
<td class="grid"><code>ADDSS xmm1, xmm2/m32</code></td>
<td class="grid">Add the low single-precision floating-point value from xmm2/m32 to xmm1.</td>
</tr>
</table></td><td>
<p>Adds the low single-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[32..127] remain unchanged</span>
</pre>
</td><td>
Overflow, Underflow, Invalid, Precision, Denormal.
</td></tr><tr><td><strong>ADDSUBPD</strong><br />Packed Double-FP Add/Subtract<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F D0 /r</code></td>
<td class="grid"><code>ADDSUBPD xmm1, xmm2/m128</code></td>
<td class="grid">Add/Subtract packed DP FP numbers from xmm2/m128 to xmm1.</td>
</tr>
</table></td><td>
<p>Adds the double-precision floating-point values in the high quadword of the source and destination operands and stores the result in the high quadword of the destination operand.</p>
<p>Subtracts the double-precision floating-point value in the low quadword of the source operand from the low quadword of the destination operand and stores the result in the low quadword of the destination operand.</p>
<br />
<pre>xmm1<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> xmm1<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">-</span> xmm2/m128<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
xmm1<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> xmm1<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">+</span> xmm2/m128<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
When the source operand is a memory operand, it must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.
</td></tr><tr><td><strong>ADDSUBPS</strong><br />Packed Single-FP Add/Subtract<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F D0 /r</code></td>
<td class="grid"><code>ADDSUBPS xmm1, xmm2/m128</code></td>
<td class="grid">Add/Subtract packed SP FP numbers from xmm2/m128 to xmm1.</td>
</tr>
</table></td><td>
<p>Adds odd-numbered single-precision floating-point values of the source operand (second operand) with the corresponding single-precision floating-point values from the destination operand (first operand); stores the result in the odd-numbered values of the destination operand.</p>
<p>Subtracts the even-numbered single-precision floating-point values in the source operand from the corresponding single-precision floating values in the destination operand; stores the result into the even-numbered values of the destination operand.</p>
<br />
<pre>xmm1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> xmm1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">-</span> xmm2/m128<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
xmm1<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> xmm1<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">+</span> xmm2/m128<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
xmm1<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> xmm1<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">-</span> xmm2/m128<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
xmm1<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> xmm1<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">+</span> xmm2/m128<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
When the source operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.
</td></tr><tr><td><strong>AND</strong><br />Logical AND<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>24 ib</code></td>
<td class="grid"><code>AND AL, imm8</code></td>
<td class="grid">AL AND imm8</td>
</tr>
<tr>
<td class="grid"><code>25 iw</code></td>
<td class="grid"><code>AND AX, imm16</code></td>
<td class="grid">AX AND imm16</td>
</tr>
<tr>
<td class="grid"><code>25 id</code></td>
<td class="grid"><code>AND EAX, imm32</code></td>
<td class="grid">EAX AND imm32</td>
</tr>
<tr>
<td class="grid"><code>80 /4 ib</code></td>
<td class="grid"><code>AND r/m8, imm8</code></td>
<td class="grid">r/m8 AND imm8</td>
</tr>
<tr>
<td class="grid"><code>81 /4 iw</code></td>
<td class="grid"><code>AND r/m16, imm16</code></td>
<td class="grid">r/m16 AND imm16</td>
</tr>
<tr>
<td class="grid"><code>81 /4 id</code></td>
<td class="grid"><code>AND r/m32, imm32</code></td>
<td class="grid">r/m32 AND imm32</td>
</tr>
<tr>
<td class="grid"><code>83 /4 ib</code></td>
<td class="grid"><code>AND r/m16, imm8</code></td>
<td class="grid">r/m16 AND imm8 (sign-extended)</td>
</tr>
<tr>
<td class="grid"><code>83 /4 ib</code></td>
<td class="grid"><code>AND r/m32, imm8</code></td>
<td class="grid">r/m32 AND imm8 (sign-extended)</td>
</tr>
<tr>
<td class="grid"><code>20 /r</code></td>
<td class="grid"><code>AND r/m8, r8</code></td>
<td class="grid">r/m8 AND r8</td>
</tr>
<tr>
<td class="grid"><code>21 /r</code></td>
<td class="grid"><code>AND r/m16, r16</code></td>
<td class="grid">r/m16 AND r16</td>
</tr>
<tr>
<td class="grid"><code>21 /r</code></td>
<td class="grid"><code>AND r/m32, r32</code></td>
<td class="grid">r/m32 AND r32</td>
</tr>
<tr>
<td class="grid"><code>22 /r</code></td>
<td class="grid"><code>AND r8, r/m8</code></td>
<td class="grid">r8 AND r/m8</td>
</tr>
<tr>
<td class="grid"><code>23 /r</code></td>
<td class="grid"><code>AND r16, r/m16</code></td>
<td class="grid">r16 AND r/m16</td>
</tr>
<tr>
<td class="grid"><code>23 /r</code></td>
<td class="grid"><code>AND r32, r/m32</code></td>
<td class="grid">r32 AND r/m32</td>
</tr>
</table></td><td>
<p>Performs a bitwise AND operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location.</p>
<p>(However, two memory operands cannot be used in one instruction.) Each bit of the result is set to 1 if both corresponding bits of the first and second operands are 1; otherwise, it is set to 0.</p>
<p>This instruction can be used with a LOCK prefix to allow the it to be executed atomically.</p>
<br />
<pre>Destination <span class="operator">=</span> Destination <span class="operator">&amp;</span> Source<span class="operator">;</span>
</pre>
</td><td>
<p>The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined.
</p>
</td></tr><tr><td><strong>ANDPD</strong><br />Bitwise Logical AND of Packed Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 54 /r</code></td>
<td class="grid"><code>ANDPD xmm1, xmm2/m128</code></td>
<td class="grid">Bitwise logical AND of xmm2/m128 and xmm1. If any part of the operand lies outside the effective address space from 0 to FFFFH.</td>
</tr>
</table></td><td>
<p>Performs a bitwise logical AND of the two packed double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the result in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">&amp;</span> Source<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>ANDPS</strong><br />Bitwise Logical AND of Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 54 /r</code></td>
<td class="grid"><code>ANDPS xmm1, xmm2/m128</code></td>
<td class="grid">Bitwise logical AND of xmm2/m128 and xmm1.</td>
</tr>
</table></td><td>
<p>Performs a bitwise logical AND of the four packed single-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the result in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">&amp;</span> Source<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>ANDNPD</strong><br />Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 55 /r</code></td>
<td class="grid"><code>ANDNPD xmm1, xmm2/m128</code></td>
<td class="grid">Bitwise logical AND NOT of xmm2/m128 and xmm1.</td>
</tr>
</table></td><td>
<p>Inverts the bits of the two packed double-precision floating-point values in the destination operand (first operand), performs a bitwise logical AND of the two packed double-precision floating-point values in the source operand (second operand) and the temporary inverted result, and stores the result in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">~</span>Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">&amp;</span> Source<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>ANDNPS</strong><br />Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 55 /r</code></td>
<td class="grid"><code>ANDNPS xmm1, xmm2/m128</code></td>
<td class="grid">Bitwise logical AND NOT of xmm2/m128 and xmm1.</td>
</tr>
</table></td><td>
<p>Inverts the bits of the four packed single-precision floating-point values in the destination operand (first operand), performs a bitwise logical AND of the four packed single-precision floating-point values in the source operand (second operand) and the temporary inverted result, and stores the result in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">~</span>Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">&amp;</span> Source<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>ARPL</strong><br />Adjust RPL Field of Segment Selector<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>63 /r</code></td>
<td class="grid"><code>ARPL r/m16, r16</code></td>
<td class="grid">Adjust RPL of r/m16 to not less than RPL of r16</td>
</tr>
</table></td><td>
<p>Compares the RPL fields of two segment selectors. The first operand (the destination operand) contains one segment selector and the second operand (source operand) contains the other. (The RPL field is located in bits 0 and 1 of each operand.) If the RPL field of the destination operand is less than the RPL field of the source operand, the ZF flag is set and the RPL field of the destination operand is increased to match that of the source operand. Otherwise, the ZF flag is cleared and no change is made to the destination operand. (The destination operand can be a word register or a memory location; the source operand must be a word register.) The ARPL instruction is provided for use by operating-system procedures (however, it can also be used by applications). It is generally used to adjust the RPL of a segment selector that has been passed to the operating system by an application program to match the privilege level of the application program. Here the segment selector passed to the operating system is placed in the destination operand and segment selector for the application program's code segment is placed in the source operand. (The RPL field in the source operand represents the privilege level of the application program.) Execution of the ARPL instruction then insures that the RPL of the segment selector received by the operating system is no lower (does not have a higher privilege) than the privilege level of the application program (the segment selector for the application program's code segment can be read from the stack following a procedure call).</p>
<p>See &quot;Checking Caller Access Privileges&quot; in Chapter 4 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3, for more information about the use of this instruction.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">.</span>RPL <span class="operator">&lt;</span> Source<span class="operator">.</span>RPL<span class="operator">)</span> {
	ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
	Destination<span class="operator">.</span>RPL <span class="operator">=</span> Source<span class="operator">.</span>RPL<span class="operator">;</span>
}
<span class="keyword">else</span> ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
<p>The ZF flag is set to 1 if the RPL field of the destination operand is less than that of the source operand; otherwise, it is set to 0.
</p>
</td></tr><tr><td><strong>BOUND</strong><br />Check Array Index Against Bounds<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>62 /r</code></td>
<td class="grid"><code>BOUND r16, m16&amp;16</code></td>
<td class="grid">Check if r16 (array index) is within bounds specified by m16&amp;16</td>
</tr>
<tr>
<td class="grid"><code>62 /r</code></td>
<td class="grid"><code>BOUND r32, m32&amp;32</code></td>
<td class="grid">Check if r32 (array index) is within bounds specified by m32&amp;32</td>
</tr>
</table></td><td>
<p>Determines if the first operand (array index) is within the bounds of an array specified the second operand (bounds operand). The array index is a signed integer located in a register. The bounds operand is a memory location that contains a pair of signed doubleword-integers (when the operand-size attribute is 32) or a pair of signed word-integers (when the operand-size attribute is 16). The first doubleword (or word) is the lower bound of the array and the second doubleword (or word) is the upper bound of the array. The array index must be greater than or equal to the lower bound and less than or equal to the upper bound plus the operand size in bytes.</p>
<p>If the index is not within bounds, a BOUND range exceeded exception (#BR) is signaled. When this exception is generated, the saved return instruction pointer points to the BOUND instruction.</p>
<p>The bounds limit data structure (two words or doublewords containing the lower and upper limits of the array) is usually placed just before the array itself, making the limits addressable via a constant offset from the beginning of the array. Because the address of the array already will be present in a register, this practice avoids extra bus cycles to obtain the effective address of the array bounds.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>ArrayIndex <span class="operator">&lt;</span> LowerBound <span class="operator">||</span> ArrayIndex <span class="operator">&gt;</span> UpperBound<span class="operator">)</span> Exception<span class="operator">(</span>BR<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>BSF</strong><br />Bit Scan Forward<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F BC</code></td>
<td class="grid"><code>BSF r16, r/m16</code></td>
<td class="grid">Bit scan forward on r/m16</td>
</tr>
<tr>
<td class="grid"><code>0F BC</code></td>
<td class="grid"><code>BSF r32, r/m32</code></td>
<td class="grid">Bit scan forward on r/m32</td>
</tr>
</table></td><td>
<p>Searches the source operand (second operand) for the least significant set bit (1 bit). If a least significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content of the source operand is 0, the content of the destination operand is undefined.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Source <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
	ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	Destination <span class="operator">=</span> Undefined<span class="operator">;</span>
}
<span class="keyword">else</span> {
	ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	Temporary <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	<span class="keyword">while</span><span class="operator">(</span>Bit<span class="operator">(</span>Source<span class="operator">,</span> Temporary<span class="operator">)</span> <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		Temporary <span class="operator">=</span> Temporary <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
		Destination <span class="operator">=</span> Temporary<span class="operator">;</span>
	}
}
</pre>
</td><td>
<p>The ZF flag is set to 1 if all the source operand is 0; otherwise, the ZF flag is cleared. The CF, OF, SF, AF, and PF, flags are undefined.
</p>
</td></tr><tr><td><strong>BSR</strong><br />Bit Scan Reverse<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F BD</code></td>
<td class="grid"><code>BSR r16, r/m16</code></td>
<td class="grid">Bit scan reverse on r/m16</td>
</tr>
<tr>
<td class="grid"><code>0F BD</code></td>
<td class="grid"><code>BSR r32, r/m32</code></td>
<td class="grid">Bit scan reverse on r/m32</td>
</tr>
</table></td><td>
<p>Searches the source operand (second operand) for the most significant set bit (1 bit). If a most significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content source operand is 0, the content of the destination operand is undefined.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Source <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
	ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
	Destination <span class="operator">=</span> Undefined<span class="operator">;</span>
}
<span class="keyword">else</span> {
	ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	Temporary <span class="operator">=</span> OperandSize <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
	<span class="keyword">while</span><span class="operator">(</span>Bit<span class="operator">(</span>Source<span class="operator">,</span> Temporary<span class="operator">)</span> <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		Temporary <span class="operator">=</span> Temporary <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
		Destination <span class="operator">=</span> Temporary<span class="operator">;</span>
	}
}
</pre>
</td><td>
<p>The ZF flag is set to 1 if all the source operand is 0; otherwise, the ZF flag is cleared. The CF, OF, SF, AF, and PF, flags are undefined.
</p>
</td></tr><tr><td><strong>BSWAP</strong><br />Byte Swap<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F C8+rd</code></td>
<td class="grid"><code>BSWAP r32</code></td>
<td class="grid">Reverses the byte order of a 32-bit register.</td>
</tr>
</table></td><td>
<p>Reverses the byte order of a 32-bit (destination) register: bits 0 through 7 are swapped with bits 24 through 31, and bits 8 through 15 are swapped with bits 16 through 23. This instruction is provided for converting little-endian values to big-endian format and vice versa.</p>
<p>To swap bytes in a word value (16-bit register), use the XCHG instruction. When the BSWAP instruction references a 16-bit register, the result is undefined.</p>
<p>The BSWAP instruction is not supported on IA-32 processors earlier than the Intel486 processor family. For compatibility with this instruction, include functionally equivalent code for execution on Intel processors earlier than the Intel486 processor family.</p>
<br />
<pre>Temporary <span class="operator">=</span> Destination<span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> Temporary<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> Temporary<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> Temporary<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> Temporary<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>BT</strong><br />Bit Test<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F A3</code></td>
<td class="grid"><code>BT r/m16, r16</code></td>
<td class="grid">Store selected bit in CF flag</td>
</tr>
<tr>
<td class="grid"><code>0F A3</code></td>
<td class="grid"><code>BT r/m32, r32</code></td>
<td class="grid">Store selected bit in CF flag</td>
</tr>
<tr>
<td class="grid"><code>0F BA /4 ib</code></td>
<td class="grid"><code>BT r/m16, imm8</code></td>
<td class="grid">Store selected bit in CF flag</td>
</tr>
<tr>
<td class="grid"><code>0F BA /4 ib</code></td>
<td class="grid"><code>BT r/m32, imm8</code></td>
<td class="grid">Store selected bit in CF flag</td>
</tr>
</table></td><td>
<p>Selects the bit in a bit string (specified with the first operand, called the bit base) at the bitposition designated by the bit offset operand (second operand) and stores the value of the bit in the CF flag. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value. If the bit base operand specifies a register, the instruction takes the modulo 16 or 32 (depending on the register size) of the bit offset operand, allowing any bit position to be selected in a 16- or 32-bit register, respectively. If the bit base operand specifies a memory location, it represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string. The offset operand then selects a bit position within the range -2^31 to 2^31 - 1 for a register offset and 0 to 31 for an immediate offset.</p>
<p>Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combination with the displacement field of the memory operand. In this case, the loworder 3 or 5 bits (3 for 16-bit operands, 5 for 32-bit operands) of the immediate bit offset are stored in the immediate bit offset field, and the high-order bits are shifted and combined with the byte displacement in the addressing mode by the assembler. The processor will ignore the high order bits if they are not zero. </p>
<p>When accessing a bit in memory, the processor may access 4 bytes starting from the memory address for a 32-bit operand size, using by the following relationship:</p>
<p>Effective Address + (4 * (BitOffset / 32))</p>
<p>Or, it may access 2 bytes starting from the memory address for a 16-bit operand, using this relationship:</p>
<p>Effective Address + (2 * (BitOffset / 16))</p>
<p>It may do so even when only a single byte needs to be accessed to reach the given bit. When using this bit addressing mechanism, software should avoid referencing areas of memory close to address space holes. In particular, it should avoid references to memory-mapped I/O registers.</p>
<p>Instead, software should use the MOV instructions to load from or store to these addresses, and use the register form of these instructions to manipulate the data.</p>
<br />
<pre>CF <span class="operator">=</span> Bit<span class="operator">(</span>BitBase<span class="operator">,</span> BitOffset<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>The CF flag contains the value of the selected bit. The OF, SF, ZF, AF, and PF flags are undefined.
</p>
</td></tr><tr><td><strong>BTC</strong><br />Bit Test and Complement<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F BB</code></td>
<td class="grid"><code>BTC r/m16, r16</code></td>
<td class="grid">Store selected bit in CF flag and complement</td>
</tr>
<tr>
<td class="grid"><code>0F BB</code></td>
<td class="grid"><code>BTC r/m32, r32</code></td>
<td class="grid">Store selected bit in CF flag and complement</td>
</tr>
<tr>
<td class="grid"><code>0F BA /7 ib</code></td>
<td class="grid"><code>BTC r/m16, imm8</code></td>
<td class="grid">Store selected bit in CF flag and complement</td>
</tr>
<tr>
<td class="grid"><code>0F BA /7 ib</code></td>
<td class="grid"><code>BTC r/m32, imm8</code></td>
<td class="grid">Store selected bit in CF flag and complement</td>
</tr>
</table></td><td>
<p>Selects the bit in a bit string (specified with the first operand, called the bit base) at the bitposition designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and complements the selected bit in the bit string. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value. If the bit base operand specifies a register, the instruction takes the modulo 16 or 32 (depending on the register size) of the bit offset operand, allowing any bit position to be selected in a 16- or 32-bit register, respectively. If the bit base operand specifies a memory location, it represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string. The offset operand then selects a bit position within the range -2^31 to 2^31 - 1 for a register offset and 0 to 31 for an immediate offset.</p>
<p>Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combination with the displacement field of the memory operand. See &quot;BT-Bit Test&quot; in this chapter for more information on this addressing mechanism.</p>
<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<br />
<pre>CF <span class="operator">=</span> Bit<span class="operator">(</span>BitBase<span class="operator">,</span> BitOffset<span class="operator">)</span><span class="operator">;</span>
Bit<span class="operator">(</span>BitBase<span class="operator">,</span> BitOffset<span class="operator">)</span> <span class="operator">=</span> <span class="operator">~</span>Bit<span class="operator">(</span>BitBase<span class="operator">,</span> BitOffset<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>The CF flag contains the value of the selected bit before it is complemented. The OF, SF, ZF, AF, and PF flags are undefined.
</p>
</td></tr><tr><td><strong>BTR</strong><br />Bit Test and Reset<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F B3</code></td>
<td class="grid"><code>BTR r/m16, r16</code></td>
<td class="grid">Store selected bit in CF flag and clear</td>
</tr>
<tr>
<td class="grid"><code>0F B3</code></td>
<td class="grid"><code>BTR r/m32, r32</code></td>
<td class="grid">Store selected bit in CF flag and clear</td>
</tr>
<tr>
<td class="grid"><code>0F BA /6 ib</code></td>
<td class="grid"><code>BTR r/m16, imm8</code></td>
<td class="grid">Store selected bit in CF flag and clear</td>
</tr>
<tr>
<td class="grid"><code>0F BA /6 ib</code></td>
<td class="grid"><code>BTR r/m32, imm8</code></td>
<td class="grid">Store selected bit in CF flag and clear</td>
</tr>
</table></td><td>
<p>Selects the bit in a bit string (specified with the first operand, called the bit base) at the bitposition designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and clears the selected bit in the bit string to 0. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value. If the bit base operand specifies a register, the instruction takes the modulo 16 or 32 (depending on the register size) of the bit offset operand, allowing any bit position to be selected in a 16- or 32-bit register, respectively. If the bit base operand specifies a memory location, it represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string. The offset operand then selects a bit position within the range -2^31 to 2^31 - 1 for a register offset and 0 to 31 for an immediate offset.</p>
<p>Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combination with the displacement field of the memory operand. See &quot;BT-Bit Test&quot; in this chapter for more information on this addressing mechanism.</p>
<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<br />
<pre>CF <span class="operator">=</span> Bit<span class="operator">(</span>BitBase<span class="operator">,</span> BitOffset<span class="operator">)</span><span class="operator">;</span>
Bit<span class="operator">(</span>BitBase<span class="operator">,</span> BitOffset<span class="operator">)</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
<p>The CF flag contains the value of the selected bit before it is cleared. The OF, SF, ZF, AF, and PF flags are undefined.
</p>
</td></tr><tr><td><strong>BTS</strong><br />Bit Test and Set<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F AB</code></td>
<td class="grid"><code>BTS r/m16, r16</code></td>
<td class="grid">Store selected bit in CF flag and set</td>
</tr>
<tr>
<td class="grid"><code>0F AB</code></td>
<td class="grid"><code>BTS r/m32, r32</code></td>
<td class="grid">Store selected bit in CF flag and set</td>
</tr>
<tr>
<td class="grid"><code>0F BA /5 ib</code></td>
<td class="grid"><code>BTS r/m16, imm8</code></td>
<td class="grid">Store selected bit in CF flag and set</td>
</tr>
<tr>
<td class="grid"><code>0F BA /5 ib</code></td>
<td class="grid"><code>BTS r/m32, imm8</code></td>
<td class="grid">Store selected bit in CF flag and set</td>
</tr>
</table></td><td>
<p>Selects the bit in a bit string (specified with the first operand, called the bit base) at the bitposition designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and sets the selected bit in the bit string to 1. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value. If the bit base operand specifies a register, the instruction takes the modulo 16 or 32 (depending on the register size) of the bit offset operand, allowing any bit position to be selected in a 16- or 32-bit register, respectively. If the bit base operand specifies a memory location, it represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string. The offset operand then selects a bit position within the range -2^31 to 2^31 - 1 for a register offset and 0 to 31 for an immediate offset.</p>
<p>Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combination with the displacement field of the memory operand. See &quot;BT-Bit Test&quot; in this chapter for more information on this addressing mechanism.</p>
<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<br />
<pre>CF <span class="operator">=</span> Bit<span class="operator">(</span>BitBase<span class="operator">,</span> BitOffset<span class="operator">)</span><span class="operator">;</span>
Bit<span class="operator">(</span>BitBase<span class="operator">,</span> BitOffset<span class="operator">)</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</pre>
</td><td>
<p>The CF flag contains the value of the selected bit before it is set. The OF, SF, ZF, AF, and PF flags are undefined.
</p>
</td></tr><tr><td><strong>CALL</strong><br />Call Procedure<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>E8 cw</code></td>
<td class="grid"><code>CALL rel16</code></td>
<td class="grid">Call near, relative, displacement relative to next instruction</td>
</tr>
<tr>
<td class="grid"><code>E8 cd</code></td>
<td class="grid"><code>CALL rel32</code></td>
<td class="grid">Call near, relative, displacement relative to next instruction</td>
</tr>
<tr>
<td class="grid"><code>FF /2</code></td>
<td class="grid"><code>CALL r/m16</code></td>
<td class="grid">Call near, absolute indirect, address given in r/m16</td>
</tr>
<tr>
<td class="grid"><code>FF /2</code></td>
<td class="grid"><code>CALL r/m32</code></td>
<td class="grid">Call near, absolute indirect, address given in r/m32</td>
</tr>
<tr>
<td class="grid"><code>9A cd</code></td>
<td class="grid"><code>CALL ptr16:16</code></td>
<td class="grid">Call far, absolute, address given in operand</td>
</tr>
<tr>
<td class="grid"><code>9A cp</code></td>
<td class="grid"><code>CALL ptr16:32</code></td>
<td class="grid">Call far, absolute, address given in operand</td>
</tr>
<tr>
<td class="grid"><code>FF /3</code></td>
<td class="grid"><code>CALL m16:16</code></td>
<td class="grid">Call far, absolute indirect, address given in m16:16</td>
</tr>
<tr>
<td class="grid"><code>FF /3</code></td>
<td class="grid"><code>CALL m16:32</code></td>
<td class="grid">Call far, absolute indirect, address given in m16:32</td>
</tr>
</table></td><td>
<p>Saves procedure linking information on the stack and branches to the procedure (called procedure) specified with the destination (target) operand. The target operand specifies the address of the first instruction in the called procedure. This operand can be an immediate value, a generalpurpose register, or a memory location.</p>
<p>This instruction can be used to execute four different types of calls:</p>
<dl>
<dt>Near call</dt>
<dd>A call to a procedure within the current code segment (the segment currently pointed to by the CS register), sometimes referred to as an intrasegment call.</dd>
<dt>Far call</dt>
<dd>A call to a procedure located in a different segment than the current code segment, sometimes referred to as an intersegment call.</dd>
<dt>Inter-privilege-level far call</dt>
<dd>A far call to a procedure in a segment at a different privilege level than that of the currently executing program or procedure.</dd>
<dt>Task switch</dt>
<dd>A call to a procedure located in a different task.</dd>
</dl>
<p>The latter two call types (inter-privilege-level call and task switch) can only be executed in protected mode. See the section titled &quot;Calling Procedures Using Call and RET&quot; in Chapter 6 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for additional information on near, far, and inter-privilege-level calls. See Chapter 6, Task Management, in the IA-32 Intel Architecture Software Developer's Manual, Volume 3, for information on performing task switches with the CALL instruction.</p>
<h3>Near Call</h3><p>When executing a near call, the processor pushes the value of the EIP register (which contains the offset of the instruction following the CALL instruction) onto the stack (for use later as a return-instruction pointer). The processor then branches to the address in the current code segment specified with the target operand. The target operand specifies either an absolute offset in the code segment (that is an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current value of the instruction pointer in the EIP register, which points to the instruction following the CALL instruction). The CS register is not changed on near calls.</p>
<p>For a near call, an absolute offset is specified indirectly in a general-purpose register or a memory location (r/m16 or r/m32). The operand-size attribute determines the size of the target operand (16 or 32 bits). Absolute offsets are loaded directly into the EIP register. If the operandsize attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits. (When accessing an absolute offset indirectly using the stack pointer [ESP] as a base register, the base value used is the value of the ESP before the instruction executes.) A relative offset (rel16 or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 16- or 32-bit immediate value. This value is added to the value in the EIP register. As with absolute offsets, the operand-size attribute determines the size of the target operand (16 or 32 bits).</p>
<h3>Far Calls in Real-Address or Virtual-8086 Mode</h3><p>When executing a far call in realaddress or virtual-8086 mode, the processor pushes the current value of both the CS and EIP registers onto the stack for use as a return-instruction pointer. The processor then performs a &quot;far branch&quot; to the code segment and offset specified with the target operand for the called procedure.</p>
<p>Here the target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). With the pointer method, the segment and offset of the called procedure is encoded in the instruction, using a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address immediate. With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address. The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The far address is loaded directly into the CS and EIP registers. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared.</p>
<h3>Far Calls in Protected Mode</h3><p>When the processor is operating in protected mode, the CALL instruction can be used to perform the following three types of far calls: o Far call to the same privilege level o Far call to a different privilege level (inter-privilege level call) o Task switch (far call to another task) In protected mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate, task gate, or TSS) and access rights determine the type of call operation to be performed.</p>
<p>If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in protected mode is very similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The operandsize attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into CS register, and the offset from the instruction is loaded into the EIP register.</p>
<p>Note that a call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making calls between 16-bit and 32-bit code segments.</p>
<p>When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a call gate. The segment selector specified by the target operand identifies the call gate. Here again, the target operand can specify the call gate segment selector either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the call gate descriptor. (The offset from the target operand is ignored when a call gate is used.) On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is specified in the TSS for the currently running task. The branch to the new code segment occurs after the stack switch. (Note that when using a call gate to perform a far call to a segment at the same privilege level, no stack switch occurs.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure's stack, an (optional) set of parameters from the calling procedures stack, and the segment selector and instruction pointer for the calling procedure's code segment. (A value in the call gate descriptor determines how many parameters to copy to the new stack.) Finally, the processor branches to the address of the procedure being called within the new code segment.</p>
<p>Executing a task switch with the CALL instruction, is somewhat similar to executing a call through a call gate. Here the target operand specifies the segment selector of the task gate for the task being switched to (and the offset in the target operand is ignored.) The task gate in turn points to the TSS for the task, which contains the segment selectors for the task's code and stack segments. The TSS also contains the EIP value for the next instruction that was to be executed before the task was suspended. This instruction pointer value is loaded into the EIP register so that the task begins executing again at this next instruction.</p>
<p>The CALL instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of the task gate. See Chapter 6, Task Management, in the IA-32 Intel Architecture Software Developer's Manual, Volume 3, for detailed information on the mechanics of a task switch.</p>
<p>Note that when you execute at task switch with a CALL instruction, the nested task flag (NT) is set in the EFLAGS register and the new TSS's previous task link field is loaded with the old tasks TSS selector. Code is expected to suspend this nested task by executing an IRET instruction, which, because the NT flag is set, will automatically use the previous task link to return to the calling task. (See &quot;Task Linking&quot; in Chapter 6 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3, for more information on nested tasks.) Switching tasks with the CALL instruction differs in this regard from the JMP instruction which does not set the NT flag and therefore does not expect an IRET instruction to suspend the task.</p>
<h3>Mixing 16-Bit and 32-Bit Calls</h3><p>When making far calls between 16-bit and 32-bit code segments, the calls should be made through a call gate. If the far call is from a 32-bit code segment to a 16-bit code segment, the call should be made from the first 64 KBytes of the 32- bit code segment. This is because the operand-size attribute of the instruction is set to 16, so only a 16-bit return address offset is saved. Also, the call should be made using a 16-bit call gate so that 16-bit values will be pushed on the stack. See Chapter 17, Mixing 17-Bit and 32-Bit Code, in IA-32 Intel Architecture Software Developer's Manual, Volume 3 for more information.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>IsNearCall<span class="operator">(</span>Call<span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>IsRelativeCall<span class="operator">(</span>Call<span class="operator">)</span><span class="operator">)</span> {
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>InCodeSegmentLimits<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
			If<span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">4</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			Push<span class="operator">(</span>IP<span class="operator">)</span><span class="operator">;</span>
			EIP <span class="operator">=</span> EIP <span class="operator">+</span> Destination<span class="operator">;</span> <span class="comment">//Destination is rel32</span>
		}
		<span class="keyword">else</span> { <span class="comment">//OperandSize == 16</span>
			<span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">2</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			Push<span class="operator">(</span>IP<span class="operator">)</span><span class="operator">;</span>
			EIP <span class="operator">=</span> <span class="operator">(</span>EIP <span class="operator">+</span> Destination<span class="operator">)</span> <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span> <span class="comment">//Destination is rel16</span>
		}
	}
	<span class="keyword">else</span> { <span class="comment">//near absolute call</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>InCodeSegmentLimits<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
			If<span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">4</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			Push<span class="operator">(</span>EIP<span class="operator">)</span><span class="operator">;</span>
			EIP <span class="operator">=</span> Destination<span class="operator">;</span> <span class="comment">//Destination is r/m32</span>
		}
		<span class="keyword">else</span> { <span class="comment">//OperandSize == 16</span>
			<span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">2</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			Push<span class="operator">(</span>IP<span class="operator">)</span><span class="operator">;</span>
			EIP <span class="operator">=</span> Destination <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span> <span class="comment">//Destination is r/m16</span>
		}
	}
}

<span class="keyword">if</span><span class="operator">(</span>IsFarCall<span class="operator">(</span>Call<span class="operator">)</span> <span class="operator">&amp;&amp;</span> <span class="operator">(</span>PE <span class="operator">==</span> <span class="number">0</span> <span class="operator">||</span> <span class="operator">(</span>PE <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> VM <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span><span class="operator">)</span><span class="operator">)</span> { <span class="comment">//real-address or virtual-8086 mode</span>
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
		<span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">6</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>InCodeSegmentLimits<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		Push<span class="operator">(</span>CS<span class="operator">)</span><span class="operator">;</span> <span class="comment">//padded with 16 high-order bits</span>
		Push<span class="operator">(</span>EIP<span class="operator">)</span><span class="operator">;</span>
		<span class="comment">//Destination is ptr16:32 or [m16:32]</span>
		CS <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
		EIP <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {	<span class="comment">//OperandSize == 16</span>
		<span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">4</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>InCodeSegmentLimits<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		Push<span class="operator">(</span>CS<span class="operator">)</span><span class="operator">;</span>
		Push<span class="operator">(</span>IP<span class="operator">)</span><span class="operator">;</span>
		<span class="comment">//Destination is ptr16:16 or [m16:16]</span>
		CS <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">31..16</span><span class="operator">]</span><span class="operator">;</span>
		EIP <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">15..0</span><span class="operator">]</span><span class="operator">;</span>
		EIP <span class="operator">=</span> EIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span> <span class="comment">//clear upper 16 bits</span>
	}
}

<span class="keyword">if</span><span class="operator">(</span>IsFarCall<span class="operator">(</span>Call<span class="operator">)</span> <span class="operator">&amp;&amp;</span> <span class="operator">(</span>PE <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> VM <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span><span class="operator">)</span> { <span class="comment">//Protected mode, not virtual-8086 mode</span>
	<span class="keyword">if</span><span class="operator">(</span>TargetOperand<span class="operator">.</span>SegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>InDescriptorTableLimits<span class="operator">(</span>TargetOperand<span class="operator">.</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>NewCodeSegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	SegmentDescriptorType <span class="operator">=</span> ReadSegmentDescriptorType<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	SegmentDescriptorAccessRights <span class="operator">=</span> ReadSegmentDescriptorAccessRights<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	
	<span class="keyword">switch</span><span class="operator">(</span>SegmentDescriptorType<span class="operator">)</span> {
		<span class="keyword">case</span> ConformingCodeSegment<span class="operator">:</span>
			<span class="keyword">if</span><span class="operator">(</span>DPL <span class="operator">&gt;</span> CPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>NewCodeSegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>SegementIsPresent<span class="operator">(</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>NewCodeSegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
				<span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">6</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>InCodeSegmentLimits<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				Push<span class="operator">(</span>CS<span class="operator">)</span><span class="operator">;</span> <span class="comment">//padded with 16 high-order bits</span>
				Push<span class="operator">(</span>EIP<span class="operator">)</span><span class="operator">;</span>
				CS <span class="operator">=</span> Destination<span class="operator">[</span>NewCodeSegmentSelector<span class="operator">]</span><span class="operator">;</span>
				<span class="comment">//segment descriptor information also loaded</span>
				CS<span class="operator">.</span>RPL <span class="operator">=</span> CPL<span class="operator">;</span>
				EIP <span class="operator">=</span> Destination<span class="operator">.</span>Offset<span class="operator">;</span>
			}
			<span class="keyword">else</span> { <span class="comment">//OperandSize == 16</span>
				<span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">4</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>InCodeSegmentLimits<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				Push<span class="operator">(</span>CS<span class="operator">)</span><span class="operator">;</span>
				Push<span class="operator">(</span>IP<span class="operator">)</span><span class="operator">;</span>
				CS <span class="operator">=</span> Destination<span class="operator">[</span>NewCodeSegmentSelector<span class="operator">]</span><span class="operator">;</span>
				<span class="comment">//segment descriptor information also loaded</span>
				CS<span class="operator">.</span>RPL <span class="operator">=</span> CPL<span class="operator">;</span>
				EIP <span class="operator">=</span> Destination<span class="operator">.</span>Offset <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span> <span class="comment">//clear upper 16 bits</span>
			}
			<span class="keyword">break</span><span class="operator">;</span>
			
		<span class="keyword">case</span> NonConformingCodeSegment<span class="operator">:</span>
			<span class="keyword">if</span><span class="operator">(</span>RPL <span class="operator">&gt;</span> CPL <span class="operator">||</span> DPL <span class="operator">!=</span> CPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>NewCodeSegmentSelector<span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>SegementIsPresent<span class="operator">(</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>NewCodeSegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> ReturnAddress<span class="operator">.</span>Size<span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			TemporaryEIP <span class="operator">=</span> Destination<span class="operator">.</span>Offset<span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> TemporaryEIP <span class="operator">=</span> TemporaryEIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span> <span class="comment">//clear upper 16 bits</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>InCodeSegmentLimits<span class="operator">(</span>TemporaryEIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
				Push<span class="operator">(</span>CS<span class="operator">)</span><span class="operator">;</span> <span class="comment">//padded with 16 high-order bits</span>
				Push<span class="operator">(</span>EIP<span class="operator">)</span><span class="operator">;</span>
				CS <span class="operator">=</span> Destination<span class="operator">.</span>NewCodeSegmentSelector<span class="operator">;</span>
				<span class="comment">//segment descriptor information also loaded</span>
				CS<span class="operator">.</span>RPL <span class="operator">=</span> CPL<span class="operator">;</span>
				EIP <span class="operator">=</span> TemporaryEIP<span class="operator">;</span>
			}
			<span class="keyword">else</span> { <span class="comment">//OperandSize == 16</span>
				Push<span class="operator">(</span>CS<span class="operator">)</span><span class="operator">;</span>
				Push<span class="operator">(</span>IP<span class="operator">)</span><span class="operator">;</span>
				CS <span class="operator">=</span> Destination<span class="operator">.</span>NewCodeSegmentSelector<span class="operator">;</span>
				<span class="comment">//segment descriptor information also loaded.</span>
				CS<span class="operator">.</span>RPL <span class="operator">=</span> CPL<span class="operator">;</span>
				EIP <span class="operator">=</span> TemporaryEIP<span class="operator">;</span>
			}
			<span class="keyword">break</span><span class="operator">;</span>
			
		<span class="keyword">case</span> CallGate<span class="operator">:</span>
			<span class="keyword">if</span><span class="operator">(</span>CallGate<span class="operator">.</span>DPL <span class="operator">&lt;</span> CPL <span class="operator">||</span> CallGate<span class="operator">.</span>DPL <span class="operator">&lt;</span> RPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>CallGateSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>CallGate<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>CallGateSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>CallGateCodeSegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>InDescriptorTableLimits<span class="operator">(</span>CallGateCodeSegmentSelector<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>CodeSegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			CodeSegmentDescriptor <span class="operator">=</span> ReadCodeSegmentDescriptor<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IndicatesCodeSegment<span class="operator">(</span>CodeSegmentDescriptor<span class="operator">)</span> <span class="operator">||</span> CodeSegmentDescriptor<span class="operator">.</span>DPL <span class="operator">&gt;</span> CPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>CodeSegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>CodeSegment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>NewCodeSegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>IsNonConformingCodeSegment<span class="operator">(</span>CodeSegment<span class="operator">)</span> <span class="operator">&amp;&amp;</span> DPL <span class="operator">&lt;</span> CPL<span class="operator">)</span> {
				<span class="comment">//More privilege</span>
				<span class="keyword">if</span><span class="operator">(</span>Is32BitTSS<span class="operator">(</span>CurrenTSS<span class="operator">)</span><span class="operator">)</span> {
					TSSStackAddress <span class="operator">=</span> NewCodeSegment<span class="operator">(</span>DPL <span class="operator">*</span> <span class="number">8</span><span class="operator">)</span> <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span>TSSStackAddress <span class="operator">+</span> <span class="number">7</span> <span class="operator">&gt;</span> TSSLimit<span class="operator">)</span> Exception<span class="operator">(</span>TS<span class="operator">(</span>CurrenTSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					NewSS <span class="operator">=</span> TSSStackAddress <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
					NewESP <span class="operator">=</span> StackAddress<span class="operator">;</span>
				}
				<span class="keyword">else</span> { <span class="comment">//TSS is 16-bit</span>
					<span class="keyword">if</span><span class="operator">(</span>TSSStackAddress <span class="operator">+</span> <span class="number">4</span> <span class="operator">&gt;</span> TSSLimit<span class="operator">)</span> Exception<span class="operator">(</span>TS<span class="operator">(</span>CurrenTSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					NewESP <span class="operator">=</span> TSSStackAddress<span class="operator">;</span>
					NewSS <span class="operator">=</span> TSSStackAddress <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
				}
				<span class="keyword">if</span><span class="operator">(</span>StackSegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>TS<span class="operator">(</span>StackSegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>StackSegmentSelector<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>TS<span class="operator">(</span>SSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				CodeSegmentDescriptor <span class="operator">=</span> ReadCodeSegmentDescriptor<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span>StackSegmentSelectorData<span class="operator">.</span>RPL <span class="operator">!=</span> CodeSegmentDescriptor<span class="operator">.</span>DPL <span class="operator">||</span> StackSegment<span class="operator">.</span>DPL <span class="operator">!=</span> CodeSegment<span class="operator">.</span>DPL <span class="operator">||</span> <span class="operator">!</span>IsWritableDataSegment<span class="operator">(</span>StackSegment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>TS<span class="operator">(</span>SSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>StackSegment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span>SSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span>CallGate<span class="operator">.</span>Size <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
					<span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> Parameters<span class="operator">.</span>Size <span class="operator">+</span> <span class="number">16</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span>SSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimit<span class="operator">(</span>CallGate<span class="operator">.</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					SS <span class="operator">=</span> NewSS<span class="operator">;</span>
					<span class="comment">//segment descriptor information also loaded;</span>
					ESP <span class="operator">=</span> NewESP<span class="operator">;</span>
					CS<span class="operator">:</span>EIP <span class="operator">=</span> CallGate<span class="operator">(</span>CS<span class="operator">:</span>InstructionPointer<span class="operator">)</span><span class="operator">;</span>
					<span class="comment">//segment descriptor information also loaded</span>
					Push<span class="operator">(</span>oldSS<span class="operator">:</span>oldESP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//from calling procedure</span>
					Temporary <span class="operator">=</span> MaskTo5Bits<span class="operator">(</span>Parameters<span class="operator">.</span>Count<span class="operator">)</span><span class="operator">;</span>
					Push<span class="operator">(</span>Parameters<span class="operator">,</span> Temporary<span class="operator">)</span><span class="operator">;</span>
					Push<span class="operator">(</span>oldCS<span class="operator">:</span>oldEIP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//return address to calling procedure</span>
				}
				<span class="keyword">else</span> { <span class="comment">//CallGate.Size == 16</span>
					<span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> Parameters<span class="operator">.</span>Size <span class="operator">+</span> <span class="number">8</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span>SSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimit<span class="operator">(</span>CallGate<span class="operator">.</span>InstructionPointer <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					SS <span class="operator">=</span> NewSS<span class="operator">;</span>
					<span class="comment">//segment descriptor information also loaded;</span>
					ESP <span class="operator">=</span> NewESP<span class="operator">;</span>
					CS<span class="operator">:</span>IP <span class="operator">=</span> CallGate<span class="operator">(</span>CS<span class="operator">:</span>InstructionPointer<span class="operator">)</span><span class="operator">;</span>
					<span class="comment">//segment descriptor information also loaded</span>
					Push<span class="operator">(</span>oldSS<span class="operator">:</span>oldESP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//from calling procedure</span>
					Temporary <span class="operator">=</span> MaskTo5Bits<span class="operator">(</span>Parameters<span class="operator">.</span>Count<span class="operator">)</span><span class="operator">;</span>
					Push<span class="operator">(</span>Parameters<span class="operator">,</span> Temporary<span class="operator">)</span><span class="operator">;</span>
					Push<span class="operator">(</span>oldCS<span class="operator">:</span>oldEIP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//return address to calling procedure</span>
					<span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> Parameters<span class="operator">.</span>Size <span class="operator">+</span> <span class="number">16</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span>SSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimit<span class="operator">(</span>CallGate<span class="operator">.</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					SS <span class="operator">=</span> NewSS<span class="operator">;</span>
					<span class="comment">//segment descriptor information also loaded;</span>
					ESP <span class="operator">=</span> NewESP<span class="operator">;</span>
					CS<span class="operator">:</span>EIP <span class="operator">=</span> CallGate<span class="operator">(</span>CS<span class="operator">:</span>InstructionPointer<span class="operator">)</span><span class="operator">;</span>
					<span class="comment">//segment descriptor information also loaded</span>
					Push<span class="operator">(</span>oldSS<span class="operator">:</span>oldESP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//from calling procedure</span>
					Temporary <span class="operator">=</span> MaskTo5Bits<span class="operator">(</span>Parameters<span class="operator">.</span>Count<span class="operator">)</span><span class="operator">;</span>
					Push<span class="operator">(</span>Parameters<span class="operator">,</span> Temporary<span class="operator">)</span><span class="operator">;</span>
					Push<span class="operator">(</span>oldCS<span class="operator">:</span>oldEIP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//return address to calling procedure</span>
				}
				CPL <span class="operator">=</span> CodeSegment<span class="operator">.</span>DPL
				CS<span class="operator">.</span>RPL <span class="operator">=</span> CPL<span class="operator">;</span>
			}
			<span class="comment">//Same privilege</span>
			<span class="keyword">else</span> {
				<span class="keyword">if</span><span class="operator">(</span>CallGate<span class="operator">.</span>Size <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
					<span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">8</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimit<span class="operator">(</span>EIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					CS<span class="operator">:</span>EIP <span class="operator">=</span> CallGate<span class="operator">(</span>CS<span class="operator">:</span>EIP<span class="operator">)</span> <span class="comment">//segment descriptor information also loaded</span>
					Push<span class="operator">(</span>oldCS<span class="operator">:</span>oldEIP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//return address to calling procedure</span>
				}
				<span class="keyword">else</span> { <span class="comment">//CallGate.Size == 16</span>
					<span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">4</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimit<span class="operator">(</span>IP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					CS<span class="operator">:</span>IP <span class="operator">=</span> CallGate<span class="operator">(</span>CS<span class="operator">:</span>IP<span class="operator">)</span> <span class="comment">//segment descriptor information also loaded</span>
					Push<span class="operator">(</span>oldCS<span class="operator">:</span>oldIP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//return address to calling procedure</span>
				}
				CS<span class="operator">.</span>RPL <span class="operator">=</span> CPL<span class="operator">;</span>
			}
			<span class="keyword">break</span><span class="operator">;</span>
			
		<span class="keyword">case</span> TaskGate<span class="operator">:</span>
			<span class="keyword">if</span><span class="operator">(</span>TaskGate<span class="operator">.</span>DPL <span class="operator">&lt;</span> CPL <span class="operator">||</span> TaskGate<span class="operator">.</span>DPL <span class="operator">&lt;</span> RPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>TaskGateSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>TaskGate<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>TaskGateSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			TaskGateDescriptor <span class="operator">=</span> ReadTSSegmentSelector<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>IsLocal<span class="operator">(</span>TSSegmentSelector<span class="operator">)</span> <span class="operator">||</span> <span class="operator">!</span>IsWithinGDTLimits<span class="operator">(</span>Index<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>TSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			Access<span class="operator">(</span>GDT<span class="operator">.</span>TSSDescriptor<span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>TSSDescriptor <span class="operator">&amp;</span> <span class="number">0x1F</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>TSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//TSS is busy</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>TSS<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>TSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			SwitchTasks<span class="operator">(</span>TSS<span class="operator">)</span><span class="operator">;</span> <span class="comment">//switch tasks to TSS (with nesting)</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>EIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">break</span><span class="operator">;</span>
			
		<span class="keyword">case</span> TaskStateSegment<span class="operator">:</span>
			<span class="keyword">if</span><span class="operator">(</span>TSS<span class="operator">.</span>DPL <span class="operator">&lt;</span> CPL <span class="operator">||</span> TSS<span class="operator">.</span>DPL <span class="operator">&lt;</span> RPL <span class="operator">||</span> <span class="operator">!</span>IsTSSAvailable<span class="operator">(</span>TSSDescriptor<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>TSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>TSS<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>TSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			SwitchTasks<span class="operator">(</span>TSS<span class="operator">)</span><span class="operator">;</span> <span class="comment">//switch tasks to TSS (with nesting)</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>EIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">break</span><span class="operator">;</span>
			
		<span class="keyword">default</span><span class="operator">:</span>
			Exception<span class="operator">(</span>GP<span class="operator">(</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	}
}
</pre>
</td><td>
<p>All flags are affected if a task switch occurs; no flags are affected if a task switch does not occur.
</p>
</td></tr><tr><td><strong>CBW/CWDE</strong><br />Convert Byte to Word/Convert Word to Doubleword<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>98</code></td>
<td class="grid"><code>CBW</code></td>
<td class="grid">AX = sign-extend of AL</td>
</tr>
<tr>
<td class="grid"><code>98</code></td>
<td class="grid"><code>CWDE</code></td>
<td class="grid">EAX = sign-extend of AX</td>
</tr>
</table></td><td>
<p>Double the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to doubleword) instruction copies the sign (bit 15) of the word in the AX register into the higher 16 bits of the EAX register.</p>
<p>The CBW and CWDE mnemonics reference the same opcode. The CBW instruction is intended for use when the operand-size attribute is 16 and the CWDE instruction for when the operandsize attribute is 32. Some assemblers may force the operand size to 16 when CBW is used and to 32 when CWDE is used. Others may treat these mnemonics as synonyms (CBW/CWDE) and use the current setting of the operand-size attribute to determine the size of values to be converted, regardless of the mnemonic used.</p>
<p>The CWDE instruction is different from the CWD (convert word to double) instruction. The CWD instruction uses the DX:AX register pair as a destination operand; whereas, the CWDE instruction uses the EAX register as a destination.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> AX <span class="operator">=</span> SignExtend<span class="operator">(</span>AL<span class="operator">)</span><span class="operator">;</span> <span class="comment">//instruction == CBW</span>
<span class="keyword">else</span> EAX <span class="operator">=</span> SignExtend<span class="operator">(</span>AX<span class="operator">)</span><span class="operator">;</span> <span class="comment">//OperandSize == 32, instruction == CWDE</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>CLC</strong><br />Clear Carry Flag<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F8</code></td>
<td class="grid"><code>CLC</code></td>
<td class="grid">Clear CF flag.</td>
</tr>
</table></td><td>
<p>Clears the CF flag in the EFLAGS register.</p>
<br />
<pre>CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
<p>The CF flag is set to 0. The OF, ZF, SF, AF, and PF flags are unaffected.
</p>
</td></tr><tr><td><strong>CLD</strong><br />Clear Direction Flag<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>FC</code></td>
<td class="grid"><code>CLD</code></td>
<td class="grid">Clear DF flag.</td>
</tr>
</table></td><td>
<p>Clears the DF flag in the EFLAGS register. When the DF flag is set to 0, string operations increment the index registers (ESI and/or EDI).</p>
<br />
<pre>DF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
<p>The DF flag is set to 0. The CF, OF, ZF, SF, AF, and PF flags are unaffected.
</p>
</td></tr><tr><td><strong>CLFLUSH</strong><br />Flush Cache Line<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F AE /7</code></td>
<td class="grid"><code>CLFLUSH m8</code></td>
<td class="grid">Flushes cache line containing m8.</td>
</tr>
</table></td><td>
<p>Invalidates the cache line that contains the linear address specified with the source operand from all levels of the processor cache hierarchy (data and instruction). The invalidation is broadcast throughout the cache coherence domain. If, at any level of the cache hierarchy, the line is inconsistent with memory (dirty) it is written to memory before invalidation. The source operand is a byte memory location.</p>
<p>The availability of CLFLUSH is indicated by the presence of the CPUID feature flag CLFSH (bit 19 of the EDX register, see Section , CPUID-CPU Identification). The aligned cache line size affected is also indicated with the CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).</p>
<p>The memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It should be noted that processors are free to speculatively fetch and cache data from system memory regions assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types). PREFETCHh instructions can be used to provide the processor with hints for this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, the CLFLUSH instruction is not ordered with respect to PREFETCHh instructions or any of the speculative fetching mechanisms (that is, data can be speculatively loaded into a cache line just before, during, or after the execution of a CLFLUSH instruction that references the cache line).</p>
<p>CLFLUSH is only ordered by the MFENCE instruction. It is not guaranteed to be ordered by any other fencing or serializing instructions or by another CLFLUSH instruction. For example, software can use an MFENCE instruction to insure that previous stores are included in the writeback.</p>
<p>The CLFLUSH instruction can be used at all privilege levels and is subject to all permission checking and faults associated with a byte load (and in addition, a CLFLUSH instruction is allowed to flush a linear address in an execute-only segment). Like a load, the CLFLUSH instruction sets the A bit but not the D bit in the page tables.</p>
<p>The CLFLUSH instruction was introduced with the SSE2 extensions; however, because it has its own CPUID feature flag, it can be implemented in IA-32 processors that do not include the SSE2 extensions. Also, detecting the presence of the SSE2 extensions with the CPUID instruction does not guarantee that the CLFLUSH instruction is implemented in the processor.</p>
<br />
<pre>FlushCacheLine<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>#GP(0)</code></td><td>For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.</td></tr>
<tr><td><code>#GP(0)</code></td><td>For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.</td></tr>
<tr><td><code>#SS(0)</code></td><td>For an illegal address in the SS segment.</td></tr>
<tr><td><code>#PF(fault-code)</code></td><td>For a page fault.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>CLI </strong><br /> Clear Interrupt Flag<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>FA</code></td>
<td class="grid"><code>CLI</code></td>
<td class="grid">Clear interrupt flag; interrupts disabled when interrupt flag cleared.</td>
</tr>
</table></td><td>
<p>If protected-mode virtual interrupts are not enabled, CLI clears the IF flag in the EFLAGS register. No other flags are affected. Clearing the IF flag causes the processor to ignore maskable external interrupts. The IF flag and the CLI and STI instruction have no affect on the generation of exceptions and NMI interrupts.</p>
<p>When protected-mode virtual interrupts are enabled, CPL is 3, and IOPL is less than 3; CLI clears the VIF flag in the EFLAGS register, leaving IF unaffected.</p>
<p>The following table indicates the action of the CLI instruction depending on the processor operating mode and the CPL/IOPL of the running program or procedure.</p>
<p>Decision Table for CLI Results:</p>
<div>
<table class="grid">
<tr><th>PE</th><th>VM</th><th>IOPL</th><th>CPL</th><th>PVI</th><th>VIP</th><th>VME</th><th>CLI Result</th></tr>
<tr><td>0</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>IF = 0</td></tr>
<tr><td>1</td><td>0</td><td>&gt;= CPL</td><td>X</td><td>X</td><td>X</td><td>X</td><td>IF = 0</td></tr>
<tr><td>1</td><td>0</td><td>&lt; CPL</td><td>3</td><td>1</td><td>X</td><td>X</td><td>VIF = 0</td></tr>
<tr><td>1</td><td>0</td><td>&lt; CPL</td><td>&lt; 3</td><td>X</td><td>X</td><td>X</td><td>GP Fault</td></tr>
<tr><td>1</td><td>0</td><td>&lt; CPL</td><td>X</td><td>0</td><td>X</td><td>X</td><td>GP Fault</td></tr>
<tr><td>1</td><td>1</td><td>3</td><td>X</td><td>X</td><td>X</td><td>X</td><td>IF = 0</td></tr>
<tr><td>1</td><td>1</td><td>&lt; 3</td><td>X</td><td>X</td><td>X</td><td>1</td><td>VIF = 0</td></tr>
<tr><td>1</td><td>1</td><td>&lt; 3</td><td>X</td><td>X</td><td>X</td><td>0</td><td>GP Fault</td></tr>
<tfoot>
<tr><td colspan="8">X = This setting has no impact.</td></tr>
</tfoot>
</table>
</div>
<br />0</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>PE <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> IF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//Reset Interrupt Flag</span>
<span class="keyword">else</span> {
	<span class="keyword">if</span><span class="operator">(</span>VM <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="keyword">if</span><span class="operator">(</span>IOPL <span class="operator">!=</span> CPL<span class="operator">)</span> IF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//Reset Interrupt Flag</span>
		<span class="keyword">else</span> {
			<span class="keyword">if</span><span class="operator">(</span>IOPL <span class="operator">&lt;</span> CPL <span class="operator">&amp;&amp;</span> CPL <span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&amp;&amp;</span> PVI <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> VIF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//Reset Virtual Interrupt Flag</span>
			<span class="keyword">else</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		}
	}
	<span class="keyword">else</span> {
		<span class="keyword">if</span><span class="operator">(</span>IOPL <span class="operator">==</span> <span class="number">3</span><span class="operator">)</span> IF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//Reset Interrupt Flag</span>
		<span class="keyword">else</span> {
			<span class="keyword">if</span><span class="operator">(</span>IOPL <span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&amp;&amp;</span> VME <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> VIF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//Reset Virtual Interrupt Flag</span>
			<span class="keyword">else</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		}
	}
}
</pre>
</td></tr><tr><td><strong>CLTS</strong><br />Clear Task-Switched Flag in CR0<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 06</code></td>
<td class="grid"><code>CLTS</code></td>
<td class="grid">Clears TS flag in CR0.</td>
</tr>
</table></td><td>
<p>Clears the task-switched (TS) flag in the CR0 register. This instruction is intended for use in operating-system procedures. It is a privileged instruction that can only be executed at a CPL of 0. It is allowed to be executed in real-address mode to allow initialization for protected mode.</p>
<p>The processor sets the TS flag every time a task switch occurs. The flag is used to synchronize the saving of FPU context in multitasking applications. See the description of the TS flag in the section titled &quot;Control Registers&quot; in Chapter 2 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3, for more information about this flag.</p>
<br />
<pre>CR0<span class="operator">.</span>TS <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
<p>The TS flag in CR0 register is cleared.
</p>
</td></tr><tr><td><strong>CMC</strong><br />Complement Carry Flag<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F5</code></td>
<td class="grid"><code>CMC</code></td>
<td class="grid">Complement CF flag.</td>
</tr>
</table></td><td>
<p>Complements the CF flag in the EFLAGS register.</p>
<br />
<pre>CF <span class="operator">=</span> <span class="operator">~</span>CF<span class="operator">;</span>
</pre>
</td><td>
<p>The CF flag contains the complement of its original value. The OF, ZF, SF, AF, and PF flags are unaffected.
</p>
</td></tr><tr><td><strong>CMOVcc</strong><br />Conditional Move<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 47 </code></td>
<td class="grid"><code>CMOVA r16, r/m16</code></td>
<td class="grid">Move if above (CF=0 and ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 47 </code></td>
<td class="grid"><code>CMOVA r32, r/m32</code></td>
<td class="grid">Move if above (CF=0 and ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 43 </code></td>
<td class="grid"><code>CMOVAE r16, r/m16</code></td>
<td class="grid">Move if above or equal (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 43 </code></td>
<td class="grid"><code>CMOVAE r32, r/m32</code></td>
<td class="grid">Move if above or equal (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 42 </code></td>
<td class="grid"><code>CMOVB r16, r/m16</code></td>
<td class="grid">Move if below (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 42 </code></td>
<td class="grid"><code>CMOVB r32, r/m32</code></td>
<td class="grid">Move if below (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 46 </code></td>
<td class="grid"><code>CMOVBE r16, r/m16</code></td>
<td class="grid">Move if below or equal (CF=1 or ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 46 </code></td>
<td class="grid"><code>CMOVBE r32, r/m32</code></td>
<td class="grid">Move if below or equal (CF=1 or ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 42 </code></td>
<td class="grid"><code>CMOVC r16, r/m16</code></td>
<td class="grid">Move if carry (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 42 </code></td>
<td class="grid"><code>CMOVC r32, r/m32</code></td>
<td class="grid">Move if carry (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 44 </code></td>
<td class="grid"><code>CMOVE r16, r/m16</code></td>
<td class="grid">Move if equal (ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 44 </code></td>
<td class="grid"><code>CMOVE r32, r/m32</code></td>
<td class="grid">Move if equal (ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 4F </code></td>
<td class="grid"><code>CMOVG r16, r/m16</code></td>
<td class="grid">Move if greater (ZF=0 and SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 4F </code></td>
<td class="grid"><code>CMOVG r32, r/m32</code></td>
<td class="grid">Move if greater (ZF=0 and SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 4D </code></td>
<td class="grid"><code>CMOVGE r16, r/m16</code></td>
<td class="grid">Move if greater or equal (SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 4D </code></td>
<td class="grid"><code>CMOVGE r32, r/m32</code></td>
<td class="grid">Move if greater or equal (SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 4C </code></td>
<td class="grid"><code>CMOVL r16, r/m16</code></td>
<td class="grid">Move if less (SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 4C </code></td>
<td class="grid"><code>CMOVL r32, r/m32</code></td>
<td class="grid">Move if less (SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 4E </code></td>
<td class="grid"><code>CMOVLE r16, r/m16</code></td>
<td class="grid">Move if less or equal (ZF=1 or SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 4E </code></td>
<td class="grid"><code>CMOVLE r32, r/m32</code></td>
<td class="grid">Move if less or equal (ZF=1 or SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 46 </code></td>
<td class="grid"><code>CMOVNA r16, r/m16</code></td>
<td class="grid">Move if not above (CF=1 or ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 46 </code></td>
<td class="grid"><code>CMOVNA r32, r/m32</code></td>
<td class="grid">Move if not above (CF=1 or ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 42 </code></td>
<td class="grid"><code>CMOVNAE r16, r/m16</code></td>
<td class="grid">Move if not above or equal (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 42 </code></td>
<td class="grid"><code>CMOVNAE r32, r/m32</code></td>
<td class="grid">Move if not above or equal (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 43 </code></td>
<td class="grid"><code>CMOVNB r16, r/m16</code></td>
<td class="grid">Move if not below (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 43 </code></td>
<td class="grid"><code>CMOVNB r32, r/m32</code></td>
<td class="grid">Move if not below (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 47 </code></td>
<td class="grid"><code>CMOVNBE r16, r/m16</code></td>
<td class="grid">Move if not below or equal (CF=0 and ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 47 </code></td>
<td class="grid"><code>CMOVNBE r32, r/m32</code></td>
<td class="grid">Move if not below or equal (CF=0 and ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 43 </code></td>
<td class="grid"><code>CMOVNC r16, r/m16</code></td>
<td class="grid">Move if not carry (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 43 </code></td>
<td class="grid"><code>CMOVNC r32, r/m32</code></td>
<td class="grid">Move if not carry (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 45 </code></td>
<td class="grid"><code>CMOVNE r16, r/m16</code></td>
<td class="grid">Move if not equal (ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 45 </code></td>
<td class="grid"><code>CMOVNE r32, r/m32</code></td>
<td class="grid">Move if not equal (ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 4E </code></td>
<td class="grid"><code>CMOVNG r16, r/m16</code></td>
<td class="grid">Move if not greater (ZF=1 or SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 4E </code></td>
<td class="grid"><code>CMOVNG r32, r/m32</code></td>
<td class="grid">Move if not greater (ZF=1 or SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 4C </code></td>
<td class="grid"><code>CMOVNGE r16, r/m16</code></td>
<td class="grid">Move if not greater or equal (SF&lt;&gt;OF.)</td>
</tr>
<tr>
<td class="grid"><code>0F 4C </code></td>
<td class="grid"><code>CMOVNGE r32, r/m32</code></td>
<td class="grid">Move if not greater or equal (SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 4D </code></td>
<td class="grid"><code>CMOVNL r16, r/m16</code></td>
<td class="grid">Move if not less (SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 4D </code></td>
<td class="grid"><code>CMOVNL r32, r/m32</code></td>
<td class="grid">Move if not less (SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 4F </code></td>
<td class="grid"><code>CMOVNLE r16, r/m16</code></td>
<td class="grid">Move if not less or equal (ZF=0 and SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 4F </code></td>
<td class="grid"><code>CMOVNLE r32, r/m32</code></td>
<td class="grid">Move if not less or equal (ZF=0 and SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 41 </code></td>
<td class="grid"><code>CMOVNO r16, r/m16</code></td>
<td class="grid">Move if not overflow (OF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 41 </code></td>
<td class="grid"><code>CMOVNO r32, r/m32</code></td>
<td class="grid">Move if not overflow (OF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 4B </code></td>
<td class="grid"><code>CMOVNP r16, r/m16</code></td>
<td class="grid">Move if not parity (PF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 4B </code></td>
<td class="grid"><code>CMOVNP r32, r/m32</code></td>
<td class="grid">Move if not parity (PF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 49 </code></td>
<td class="grid"><code>CMOVNS r16, r/m16</code></td>
<td class="grid">Move if not sign (SF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 49 </code></td>
<td class="grid"><code>CMOVNS r32, r/m32</code></td>
<td class="grid">Move if not sign (SF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F q5 </code></td>
<td class="grid"><code>CMOVNZ r16, r/m16</code></td>
<td class="grid">Move if not zero (ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 45 </code></td>
<td class="grid"><code>CMOVNZ r32, r/m32</code></td>
<td class="grid">Move if not zero (ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 40 </code></td>
<td class="grid"><code>CMOVO r16, r/m16</code></td>
<td class="grid">Move if overflow (OF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 40 </code></td>
<td class="grid"><code>CMOVO r32, r/m32</code></td>
<td class="grid">Move if overflow (OF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 4A </code></td>
<td class="grid"><code>CMOVP r16, r/m16</code></td>
<td class="grid">Move if parity (PF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 4A </code></td>
<td class="grid"><code>CMOVP r32, r/m32</code></td>
<td class="grid">Move if parity (PF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 4A </code></td>
<td class="grid"><code>CMOVPE r16, r/m16</code></td>
<td class="grid">Move if parity even (PF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 4A </code></td>
<td class="grid"><code>CMOVPE r32, r/m32</code></td>
<td class="grid">Move if parity even (PF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 4B </code></td>
<td class="grid"><code>CMOVPO r16, r/m16</code></td>
<td class="grid">Move if parity odd (PF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 4B </code></td>
<td class="grid"><code>CMOVPO r32, r/m32</code></td>
<td class="grid">Move if parity odd (PF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 48 </code></td>
<td class="grid"><code>CMOVS r16, r/m16</code></td>
<td class="grid">Move if sign (SF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 48 </code></td>
<td class="grid"><code>CMOVS r32, r/m32</code></td>
<td class="grid">Move if sign (SF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 44 </code></td>
<td class="grid"><code>CMOVZ r16, r/m16</code></td>
<td class="grid">Move if zero (ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 44 </code></td>
<td class="grid"><code>CMOVZ r32, r/m32</code></td>
<td class="grid">Move if zero (ZF=1).</td>
</tr>
</table></td><td>
<p>The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.</p>
<p>These instructions can move a 16- or 32-bit value from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.</p>
<p>The conditions for each CMOVcc mnemonic is given in the description column of the above table. The terms &quot;less&quot; and &quot;greater&quot; are used for comparisons of signed integers and the terms &quot;above&quot; and &quot;below&quot; are used for unsigned integers.</p>
<p>Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.</p>
<p>The CMOVcc instructions were introduced in the P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor's feature information with the CPUID instruction (see &quot;COMISS-Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS&quot; in this chapter).</p>
<br />
<pre>Temporary <span class="operator">=</span> Source<span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Condition <span class="operator">==</span> <span class="keyword">true</span><span class="operator">)</span> Destination <span class="operator">=</span> temp<span class="operator">;</span>
temp <span class="operator">=</span> Source<span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>CMP</strong><br />Compare Two Operands<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>3C ib</code></td>
<td class="grid"><code>CMP AL, imm8</code></td>
<td class="grid">Compare imm8 with AL.</td>
</tr>
<tr>
<td class="grid"><code>3D iw</code></td>
<td class="grid"><code>CMP AX, imm16</code></td>
<td class="grid">Compare imm16 with AX.</td>
</tr>
<tr>
<td class="grid"><code>3D id</code></td>
<td class="grid"><code>CMP EAX, imm32</code></td>
<td class="grid">Compare imm32 with EAX.</td>
</tr>
<tr>
<td class="grid"><code>80 /7 ib</code></td>
<td class="grid"><code>CMP r/m8, imm8</code></td>
<td class="grid">Compare imm8 with r/m8.</td>
</tr>
<tr>
<td class="grid"><code>81 /7 iw</code></td>
<td class="grid"><code>CMP r/m16, imm16</code></td>
<td class="grid">Compare imm16 with r/m16.</td>
</tr>
<tr>
<td class="grid"><code>81 /7 id</code></td>
<td class="grid"><code>CMP r/m32,imm32</code></td>
<td class="grid">Compare imm32 with r/m32.</td>
</tr>
<tr>
<td class="grid"><code>83 /7 ib</code></td>
<td class="grid"><code>CMP r/m16,imm8</code></td>
<td class="grid">Compare imm8 with r/m16.</td>
</tr>
<tr>
<td class="grid"><code>83 /7 ib</code></td>
<td class="grid"><code>CMP r/m32,imm8</code></td>
<td class="grid">Compare imm8 with r/m32.</td>
</tr>
<tr>
<td class="grid"><code>38 /r</code></td>
<td class="grid"><code>CMP r/m8,r8</code></td>
<td class="grid">Compare r8 with r/m8.</td>
</tr>
<tr>
<td class="grid"><code>39 /r</code></td>
<td class="grid"><code>CMP r/m16,r16</code></td>
<td class="grid">Compare r16 with r/m16.</td>
</tr>
<tr>
<td class="grid"><code>39 /r</code></td>
<td class="grid"><code>CMP r/m32,r32</code></td>
<td class="grid">Compare r32 with r/m32.</td>
</tr>
<tr>
<td class="grid"><code>3A /r</code></td>
<td class="grid"><code>CMP r8,r/m8</code></td>
<td class="grid">Compare r/m8 with r8.</td>
</tr>
<tr>
<td class="grid"><code>3B /r</code></td>
<td class="grid"><code>CMP r16,r/m16</code></td>
<td class="grid">Compare r/m16 with r16.</td>
</tr>
<tr>
<td class="grid"><code>3B /r</code></td>
<td class="grid"><code>CMP r32,r/m32</code></td>
<td class="grid">Compare r/m32 with r32.</td>
</tr>
</table></td><td>
<p>Compares the first source operand with the second source operand and sets the status flags in the EFLAGS register according to the results. The comparison is performed by subtracting the second operand from the first operand and then setting the status flags in the same manner as the SUB instruction. When an immediate value is used as an operand, it is sign-extended to the length of the first operand.</p>
<p>The CMP instruction is typically used in conjunction with a conditional jump (Jcc), condition move (CMOVcc), or SETcc instruction. The condition codes used by the Jcc, CMOVcc, and SETcc instructions are based on the results of a CMP instruction. Appendix B, EFLAGS Condition Codes, in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, shows the relationship of the status flags and the condition codes.</p>
<br />
<pre>temp <span class="operator">=</span> Source1 <span class="operator">-</span> SignExtend<span class="operator">(</span>Source2<span class="operator">)</span><span class="operator">;</span>
ModifyStatusFlags<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//Modify status flags in the same manner as the SUB instruction</span>
</pre>
</td><td>
<p>The CF, OF, SF, ZF, AF, and PF flags are set according to the result.
</p>
</td></tr><tr><td><strong>CMPPD</strong><br />Compare Packed Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F C2 /r ib</code></td>
<td class="grid"><code>CMPPD xmm1, xmm2/m128, imm8</code></td>
<td class="grid">Compare packed double-precision floating-point values in xmm2/m128 and xmm1 using imm8 as comparison predicate.</td>
</tr>
</table></td><td>
<p>Performs an SIMD compare of the two packed double-precision floating-point values in the source operand (second operand) and the destination operand (first operand) and returns the results of the comparison to the destination operand. The comparison predicate operand (third operand) specifies the type of comparison performed on each of the pairs of packed values. The result of each comparison is a quadword mask of all 1s (comparison true) or all 0s (comparison false). The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The comparison predicate operand is an 8-bit immediate the first 3 bits of which define the type of comparison to be made (see the following table); bits 4 through 7 of the immediate are reserved.</p>
<div>
<table class="grid">
<tr><th>Predicate</th><th>imm8 Encoding</th><th>Description</th><th>Relation where: A Is 1st Operand, B Is 2nd Operand</th><th>Emulation</th><th>Result if NaN Operand</th><th>QNaN Operand Signals Invalid</th></tr>
<tr><td>EQ</td><td>000B</td><td>Equal</td><td>A = B</td><td>-</td><td>False</td><td>No</td></tr>
<tr><td>LT</td><td>001B</td><td>Less-than</td><td>A &lt; B</td><td>-</td><td>False</td><td>Yes</td></tr>
<tr><td>LE</td><td>010B</td><td>Less-than-or-equal</td><td>A &lt;= B</td><td>-</td><td>False</td><td>Yes</td></tr>
<tr><td>-</td><td>-</td><td>Greater than</td><td>A &gt; B</td><td>Swap Operands, Use LT</td><td>False</td><td>Yes</td></tr>
<tr><td>-</td><td>-</td><td>Greater-than-or-equal</td><td>A &gt;= B</td><td>Swap Operands, Use LE</td><td>False</td><td>Yes</td></tr>
<tr><td>UNORD</td><td>011B</td><td>Unordered</td><td>A, B = Unordered</td><td>-</td><td>True</td><td>No</td></tr>
<tr><td>NEQ</td><td>100B</td><td>Not-equal</td><td>A != B</td><td>-</td><td>True</td><td>No</td></tr>
<tr><td>NLT</td><td>101B</td><td>Not-less-than</td><td>NOT(A &lt; B)</td><td>-</td><td>True</td><td>Yes</td></tr>
<tr><td>NLE</td><td>110B</td><td>Not-less-than-or-equal</td><td>NOT(A != B)</td><td>-</td><td>True</td><td>Yes</td></tr>
<tr><td>-</td><td>-</td><td>Not-greater-than</td><td>NOT(A &gt; B)</td><td>Swap Operands, Use NLT</td><td>True</td><td>Yes</td></tr>
<tr><td>-</td><td>-</td><td>Not-greater-than-or-equal</td><td>NOT(A &gt;= B)</td><td>Swap Operands, Use NLE</td><td>True</td><td>Yes</td></tr>
<tr><td>ORD</td><td>111B</td><td>Ordered</td><td>A , B = Ordered</td><td>-</td><td>False</td><td>No</td></tr>
</table>
</div>
<p>The unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.</p>
<p>A subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate an exception, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.</p>
<p>Note that the processor does not implement the greater-than, greater-than-or-equal, not-greaterthan, and not-greater-than-or-equal relations. These comparisons can be made either by using the inverse relationship (that is, use the &quot;not-less-than-or-equal&quot; to make a &quot;greater-than&quot; comparison) or by using software emulation. When using software emulation, the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in the following table under the heading Emulation.</p>
<p>Compilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPPD instruction. See the following table.</p>
<div>
<table class="grid">
<tr><th>Pseudo-Op</th><th>CMPPD Implementation</th></tr>
<tr><td>CMPEQPD xmm1, xmm2</td><td>CMPPD xmm1, xmm2, 0</td></tr>
<tr><td>CMPLTPD xmm1, xmm2</td><td>CMPPD xmm1, xmm2, 1</td></tr>
<tr><td>CMPLEPD xmm1, xmm2</td><td>CMPPD xmm1, xmm2, 2</td></tr>
<tr><td>CMPUNORDPD xmm1, xmm2</td><td>CMPPD xmm1, xmm2, 3</td></tr>
<tr><td>CMPNEQPD xmm1, xmm2</td><td>CMPPD xmm1, xmm2, 4</td></tr>
<tr><td>CMPNLTPD xmm1, xmm2</td><td>CMPPD xmm1, xmm2, 5</td></tr>
<tr><td>CMPNLEPD xmm1, xmm2</td><td>CMPPD xmm1, xmm2, 6</td></tr>
<tr><td>CMPORDPD xmm1, xmm2</td><td>CMPPD xmm1, xmm2, 7</td></tr>
</table>
</div>
<p>The greater-than relations that the processor does not implement require more than one instruction to emulate in software and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)</p>
<br />EQ</td><td>CMPEQPD xmm1, xmm2</td></tr><tr><td><strong>CMPPS</strong><br />Compare Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F C2 /r ib</code></td>
<td class="grid"><code>CMPPS xmm1, xmm2/m128, imm8</code></td>
<td class="grid">Compare packed single-precision floating-point values in xmm2/mem and xmm1 using imm8 as comparison predicate.</td>
</tr>
</table></td><td>
<p>Performs an SIMD compare of the four packed single-precision floating-point values in the source operand (second operand) and the destination operand (first operand) and returns the results of the comparison to the destination operand. The comparison predicate operand (third operand) specifies the type of comparison performed on each of the pairs of packed values. The result of each comparison is a doubleword mask of all 1s (comparison true) or all 0s (comparison false). The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The comparison predicate operand is an 8-bit immediate the first 3 bits of which define the type of comparison to be made (see the following table); bits 4 through 7 of the immediate are reserved.</p>
<p>The unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.</p>
<p>A subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate a fault, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.</p>
<p>Some of the comparisons listed in the following table (such as the greater-than, greater-than-or-equal, notgreater- than, and not-greater-than-or-equal relations) can be made only through software emulation.</p>
<p>For these comparisons the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in the following table under the heading Emulation.</p>
<p>Compilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPPS instruction. See the following table.</p>
<div>
<table class="grid">
<tr><th>Pseudo-Op</th><th>Implementation</th></tr>
<tr><td>CMPEQPS xmm1, xmm2</td><td>CMPPS xmm1, xmm2, 0</td></tr>
<tr><td>CMPLTPS xmm1, xmm2</td><td>CMPPS xmm1, xmm2, 1</td></tr>
<tr><td>CMPLEPS xmm1, xmm2</td><td>CMPPS xmm1, xmm2, 2</td></tr>
<tr><td>CMPUNORDPS xmm1, xmm2</td><td>CMPPS xmm1, xmm2, 3</td></tr>
<tr><td>CMPNEQPS xmm1, xmm2</td><td>CMPPS xmm1, xmm2, 4</td></tr>
<tr><td>CMPNLTPS xmm1, xmm2</td><td>CMPPS xmm1, xmm2, 5</td></tr>
<tr><td>CMPNLEPS xmm1, xmm2</td><td>CMPPS xmm1, xmm2, 6</td></tr>
<tr><td>CMPORDPS xmm1, xmm2</td><td>CMPPS xmm1, xmm2, 7</td></tr>
</table>
</div>
<p>The greater-than relations not implemented by the processor require more than one instruction to emulate in software and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)</p>
<br />CMPEQPS xmm1, xmm2</td><td>
<pre><span class="keyword">switch</span><span class="operator">(</span>ComparisonPredicate<span class="operator">)</span> {
	<span class="keyword">case</span> <span class="number">0</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorEqual<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">1</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorLessThan<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">2</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorLessOrEqual<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">3</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorUnordered<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">4</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorNotEqual<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">5</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorNotLessThan<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">6</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorNotLessOrEqual<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">7</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorOrdered<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
CMP0 <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> Operator Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
CMP1 <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> Operator Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
CMP2 <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> Operator Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
CMP4 <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> Operator Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>CMP0 <span class="operator">==</span> <span class="keyword">true</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>CMP1 <span class="operator">==</span> <span class="keyword">true</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>CMP2 <span class="operator">==</span> <span class="keyword">true</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>CMP3 <span class="operator">==</span> <span class="keyword">true</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>CMPS/CMPSB/CMPSW/CMPSD</strong><br />Compare String Operands<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>A6</code></td>
<td class="grid"><code>CMPS m8, m8</code></td>
<td class="grid">Compares byte at address DS:(E)SI with byte at address ES:(E)DI and sets the status flags accordingly.</td>
</tr>
<tr>
<td class="grid"><code>A7</code></td>
<td class="grid"><code>CMPS m16, m16</code></td>
<td class="grid">Compares word at address DS:(E)SI with word at address ES:(E)DI and sets the status flags accordingly.</td>
</tr>
<tr>
<td class="grid"><code>A7</code></td>
<td class="grid"><code>CMPS m32, m32</code></td>
<td class="grid">Compares doubleword at address DS:(E)SI with doubleword at address ES:(E)DI and sets the status flags accordingly.</td>
</tr>
<tr>
<td class="grid"><code>A6</code></td>
<td class="grid"><code>CMPSB</code></td>
<td class="grid">Compares byte at address DS:(E)SI with byte at address ES:(E)DI and sets the status flags accordingly.</td>
</tr>
<tr>
<td class="grid"><code>A7</code></td>
<td class="grid"><code>CMPSW</code></td>
<td class="grid">Compares word at address DS:(E)SI with word at address ES:(E)DI and sets the status flags accordingly.</td>
</tr>
<tr>
<td class="grid"><code>A7</code></td>
<td class="grid"><code>CMPSD</code></td>
<td class="grid">Compares doubleword at address DS:(E)SI with doubleword at address ES:(E)DI and sets the status flags accordingly.</td>
</tr>
</table></td><td>
<p>Compares the byte, word, or double word specified with the first source operand with the byte, word, or double word specified with the second source operand and sets the status flags in the EFLAGS register according to the results. Both source operands are located in memory. The address of the first source operand is read from either the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The address of the second source operand is read from either the ES:EDI or the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.</p>
<p>At the assembly-code level, two forms of this instruction are allowed: the &quot;explicit-operands&quot; form and the &quot;no-operands&quot; form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the source values. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords), but they do not have to specify the correct location.</p>
<p>The locations of the source operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the compare string instruction is executed.</p>
<p>The no-operands form provides &quot;short forms&quot; of the byte, word, and doubleword versions of the CMPS instructions. Here also the DS:(E)SI and ES:(E)DI registers are assumed by the processor to specify the location of the source operands. The size of the source operands is selected with the mnemonic: CMPSB (byte comparison), CMPSW (word comparison), or CMPSD (doubleword comparison).</p>
<p>After the comparison, the (E)SI and (E)DI registers increment or decrement automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register increment; if the DF flag is 1, the (E)SI and (E)DI registers decrement.) The registers increment or decrement by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.</p>
<p>The CMPS, CMPSB, CMPSW, and CMPSD instructions can be preceded by the REP prefix for block comparisons of ECX bytes, words, or doublewords. More often, however, these instructions will be used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made. See &quot;REP/REPE/REPZ/REPNE /REPNZ-Repeat String Operation Prefix&quot; in Chapter 4 for a description of the REP prefix.</p>
<br />
<pre>Temporary <span class="operator">=</span> Source1 <span class="operator">-</span> Source2<span class="operator">;</span>
SetStatusFlags<span class="operator">(</span>Temporary<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>IsByteOperation<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
	}
}
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>IsWordOperation<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
	}
}
<span class="keyword">else</span> { <span class="comment">//doubleword comparison</span>
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
	}
}
</pre>
</td><td>
<p>The CF, OF, SF, ZF, AF, and PF flags are set according to the temporary result of the comparison.
</p>
</td></tr><tr><td><strong>CMPSD</strong><br />Compare Scalar Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F C2 /r ib</code></td>
<td class="grid"><code>CMPSD xmm1, xmm2/m64, imm8</code></td>
<td class="grid">Compare low double-precision floating-point value in  xmm2/m64 and xmm1 using imm8 as comparison predicate.</td>
</tr>
</table></td><td>
<p>Compares the low double-precision floating-point values in the source operand (second operand) and the destination operand (first operand) and returns the results of the comparison to the destination operand. The comparison predicate operand (third operand) specifies the type of comparison performed. The comparison result is a quadword mask of all 1s (comparison true) or all 0s (comparison false). The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. The result is stored in the low quadword of the destination operand; the high quadword remains unchanged. The comparison predicate operand is an 8-bit immediate the first 3 bits of which define the type of comparison to be made (see the following table); bits 4 through 7 of the immediate are reserved.</p>
<p>The unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.</p>
<p>A subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate a fault, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.</p>
<p>Some of the comparisons listed in the following table can be achieved only through software emulation.</p>
<p>For these comparisons the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination operand), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in the following table under the heading Emulation.</p>
<p>Compilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPSD instruction. See the following table.</p>
<div>
<table class="grid">
<tr><th>Pseudo-Op</th><th>Implementation</th></tr>
<tr><td>CMPEQSD xmm1, xmm2</td><td>CMPSD xmm1,xmm2, 0</td></tr>
<tr><td>CMPLTSD xmm1, xmm2</td><td>CMPSD xmm1,xmm2, 1</td></tr>
<tr><td>CMPLESD xmm1, xmm2</td><td>CMPSD xmm1,xmm2, 2</td></tr>
<tr><td>CMPUNORDSD xmm1, xmm2</td><td>CMPSD xmm1,xmm2, 3</td></tr>
<tr><td>CMPNEQSD xmm1, xmm2</td><td>CMPSD xmm1,xmm2, 4</td></tr>
<tr><td>CMPNLTSD xmm1, xmm2</td><td>CMPSD xmm1,xmm2, 5</td></tr>
<tr><td>CMPNLESD xmm1, xmm2</td><td>CMPSD xmm1,xmm2, 6</td></tr>
<tr><td>CMPORDSD xmm1, xmm2</td><td>CMPSD xmm1,xmm2, 7</td></tr>
</table>
</div>
<p>The greater-than relations not implemented in the processor require more than one instruction to emulate in software and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)</p>
<br />CMPEQSD xmm1, xmm2</td><td>
<pre><span class="keyword">switch</span><span class="operator">(</span>ComparisonPredicate<span class="operator">)</span> {
	<span class="keyword">case</span> <span class="number">0</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorEqual<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">1</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorLessThan<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">2</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorLessOrEqual<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">3</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorUnordered<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">4</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorNotEqual<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">5</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorNotLessThan<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">6</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorNotLessOrEqual<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">7</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorOrdered<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">default</span><span class="operator">:</span>
		Reserved<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
}
CMP0 <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> Operator Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>CMP0 <span class="operator">==</span> <span class="keyword">true</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFFFFFFFFFF</span><span class="operator">;</span>
<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
<span class="comment">//Destination[64..127] remains unchanged</span>
</pre>
</td></tr><tr><td><strong>CMPSS</strong><br />Compare Scalar Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F C2 /r ib</code></td>
<td class="grid"><code>CMPSS xmm1, xmm2/m32, imm8</code></td>
<td class="grid">Compare low single-precision floating-point value in xmm2/m32 and xmm1 using imm8 as comparison predicate.</td>
</tr>
</table></td><td>
<p>Compares the low single-precision floating-point values in the source operand (second operand) and the destination operand (first operand) and returns the results of the comparison to the destination operand. The comparison predicate operand (third operand) specifies the type of comparison performed. The comparison result is a doubleword mask of all 1s (comparison true) or all 0s (comparison false). The source operand can be an XMM register or a 32-bit memory location.</p>
<p>The destination operand is an XMM register. The result is stored in the low doubleword of the destination operand; the 3 high-order doublewords remain unchanged. The comparison predicate operand is an 8-bit immediate the first 3 bits of which define the type of comparison to be made (see the following table); bits 4 through 7 of the immediate are reserved.</p>
<p>The unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN A subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate a fault, since a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.</p>
<p>Some of the comparisons listed in the following table can be achieved only through software emulation.</p>
<p>For these comparisons the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination operand), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in the following table under the heading Emulation.</p>
<p>Compilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPSS instruction. See the following table. The greater-than relations not implemented in the processor require more than one instruction to emulate in software and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)</p>
<div>
<table class="grid">
<tr><th>Pseudo-Op</th><th>CMPSS</th><th>Implementation</th></tr>
<tr><td>CMPEQSS xmm1, xmm2</td><td>CMPSS xmm1, xmm2, 0</td></tr>
<tr><td>CMPLTSS xmm1, xmm2</td><td>CMPSS xmm1, xmm2, 1</td></tr>
<tr><td>CMPLESS xmm1, xmm2</td><td>CMPSS xmm1, xmm2, 2</td></tr>
<tr><td>CMPUNORDSS xmm1, xmm2</td><td>CMPSS xmm1, xmm2, 3</td></tr>
<tr><td>CMPNEQSS xmm1, xmm2</td><td>CMPSS xmm1, xmm2, 4</td></tr>
<tr><td>CMPNLTSS xmm1, xmm2</td><td>CMPSS xmm1, xmm2, 5</td></tr>
<tr><td>CMPNLESS xmm1, xmm2</td><td>CMPSS xmm1, xmm2, 6</td></tr>
<tr><td>CMPORDSS xmm1, xmm2</td><td>CMPSS xmm1, xmm2, 7</td></tr>
</table>
</div>
<p>The greater-than relations not implemented in the processor require more than one instruction to emulate in software and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)</p>
<br />CMPEQSS xmm1, xmm2</td><td>
<pre><span class="keyword">switch</span><span class="operator">(</span>ComparisonPredicate<span class="operator">)</span> {
	<span class="keyword">case</span> <span class="number">0</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorEqual<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">1</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorLessThan<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">2</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorLessOrEqual<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">3</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorUnordered<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">4</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorNotEqual<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">5</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorNotLessThan<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">6</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorNotLessOrEqual<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">7</span><span class="operator">:</span>
		Operator <span class="operator">=</span> OperatorOrdered<span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">default</span><span class="operator">:</span>
		Reserved<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
}
CMP0 <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> Operator Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>CMP0 <span class="operator">==</span> <span class="keyword">true</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
<span class="comment">//Destination[32..127] remains unchanged</span>
</pre>
</td></tr><tr><td><strong>CMPXCHG</strong><br />Compare and Exchange<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F B0 /r</code></td>
<td class="grid"><code>CMPXCHG r/m8,r8</code></td>
<td class="grid">Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.</td>
</tr>
<tr>
<td class="grid"><code>0F B1 /r</code></td>
<td class="grid"><code>CMPXCHG r/m16,r16</code></td>
<td class="grid">Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX</td>
</tr>
<tr>
<td class="grid"><code>0F B1 /r</code></td>
<td class="grid"><code>CMPXCHG r/m32,r32</code></td>
<td class="grid">Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into EAX</td>
</tr>
</table></td><td>
<p>Compares the value in the AL, AX, or EAX register (depending on the size of the operand) with the first operand (destination operand). If the two values are equal, the second operand (source operand) is loaded into the destination operand. Otherwise, the destination operand is loaded into the AL, AX, or EAX register.</p>
<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<p>To simplify the interface to the processor's bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)</p>
<br />
<pre><span class="comment">/*</span>
<span class="comment">accumulator = AL, AX, or EAX, depending on whether</span>
<span class="comment">a byte, word, or doubleword comparison is being performed</span>
<span class="comment">*/</span>
<span class="keyword">if</span><span class="operator">(</span>accumulator <span class="operator">==</span> Destination<span class="operator">)</span> {
	ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
	Destination <span class="operator">=</span> Source<span class="operator">;</span>
}
<span class="keyword">else</span> {
	ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	accumulator <span class="operator">=</span> Destination<span class="operator">;</span>
}
</pre>
</td><td>
<p>The ZF flag is set if the values in the destination operand and register AL, AX, or EAX are equal; otherwise it is cleared. The CF, PF, AF, SF, and OF flags are set according to the results of the comparison operation.
</p>
</td></tr><tr><td><strong>CMPXCHG8B</strong><br />Compare and Exchange 8 Bytes<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F C7 /1 m64</code></td>
<td class="grid"><code>CMPXCHG8B m64</code></td>
<td class="grid">Compare EDX:EAX with m64. If equal, set ZF and load ECX:EBX into m64. Else, clear ZF and load m64 into EDX:EAX.</td>
</tr>
</table></td><td>
<p>Compares the 64-bit value in EDX:EAX with the operand (destination operand). If the values are equal, the 64-bit value in ECX:EBX is stored in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX. The destination operand is an 8-byte memory location. For the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the low-order 32 bits of a 64-bit value.</p>
<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<p>To simplify the interface to the processor's bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>EDX<span class="operator">:</span>EAX <span class="operator">==</span> Destination<span class="operator">)</span> {
	ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
	Destination <span class="operator">=</span> ECX<span class="operator">:</span>EBX<span class="operator">;</span>
}
<span class="keyword">else</span> {
	ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	EDX<span class="operator">:</span>EAX <span class="operator">=</span> Destination<span class="operator">;</span>
}
</pre>
</td><td>
<p>The ZF flag is set if the destination operand and EDX:EAX are equal; otherwise it is cleared.
The CF, PF, AF, SF, and OF flags are unaffected.
</p>
</td></tr><tr><td><strong>COMISD</strong><br />Compare Scalar Ordered Double-Precision Floating- Point Values and Set EFLAGS<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 2F /r</code></td>
<td class="grid"><code>COMISD xmm1, xmm2/m64</code></td>
<td class="grid">Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.</td>
</tr>
</table></td><td>
<p>Compares the double-precision floating-point values in the low quadwords of source operand 1 (first operand) and source operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).</p>
<p>Source operand 1 is an XMM register; source operand 2 can be an XMM register or a 64 bit memory location.</p>
<p>The COMISD instruction differs from the UCOMISD instruction in that it signals an SIMD floating-point invalid operation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISD instruction signals an invalid numeric exception only if a source operand is an SNaN.</p>
<p>The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.</p>
<br />
<pre>Result <span class="operator">=</span> OrderedCompare<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">,</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">switch</span><span class="operator">(</span>Result<span class="operator">)</span> {
	<span class="keyword">case</span> ResultUnordered<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ResultGreaterThan<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ResultLessThan<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ResultEqual<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
OF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
AF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
SF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
Invalid (if SNaN or QNaN operands), Denormal.
</td></tr><tr><td><strong>COMISS</strong><br />Compare Scalar Ordered Single-Precision Floating- Point Values and Set EFLAGS<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 2F /r</code></td>
<td class="grid"><code>COMISS xmm1, xmm2/m32</code></td>
<td class="grid">Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.</td>
</tr>
</table></td><td>
<p>Compares the single-precision floating-point values in the low doublewords of source operand 1 (first operand) and source operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF, and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).</p>
<p>Source operand 1 is an XMM register; source operand 2 can be an XMM register or a 32 bit memory location.</p>
<p>The COMISS instruction differs from the UCOMISS instruction in that it signals an SIMD floating-point invalid operation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISS instruction signals an invalid numeric exception only if a source operand is an SNaN.</p>
<p>The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.</p>
<br />
<pre>Result <span class="operator">=</span> OrderedCompare<span class="operator">(</span>Source1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">,</span> Source2<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">switch</span><span class="operator">(</span>Result<span class="operator">)</span> {
	<span class="keyword">case</span> ResultUnordered<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ResultGreaterThan<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ResultLessThan<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ResultEqual<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
OF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
AF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
SF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
Invalid (if SNaN or QNaN operands), Denormal.
</td></tr><tr><td><strong>CPUID</strong><br />CPU Identification<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F A2</code></td>
<td class="grid"><code>CPUID</code></td>
<td class="grid">Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, according to the input value entered initially in the EAX register.</td>
</tr>
</table></td><td>
<p>The ID flag (bit 21) in the EFLAGS register indicates support for the CPUID instruction. If a software procedure can set and clear this flag, the processor executing the procedure supports the CPUID instruction.</p>
<p>CPUID returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers. The instruction's output is dependent on the contents of the EAX register upon execution. For example, the following pseudocode loads EAX with 00H and causes CPUID to return a Maximum Return Value and the Vendor Identification String in the appropriate registers: MOV EAX, 00H CPUID. The following shows information returned, depending on the initial value loaded into the EAX register. The second table shows the maximum CPUID input value recognized for each family of IA- 32 processors on which CPUID is implemented.</p>
<p>Two types of information are returned: basic and extended function information. If a higher value entered than is valid for a particular processor, the information for the highest useful basic information value is returned. For example, if an input value of 5 is entered in EAX for a Pentium 4 processor, the information for an input value of 2 is returned. The exception to this rule is the input values that return extended function information. For a Pentium 4 processor, entering an input value of 80000005H or above returns the information for an input value of 2.</p>
<p>CPUID can be executed at any privilege level to serialize instruction execution. Serializing instruction execution guarantees that any modifications to flags, registers, and memory for previous instructions are completed before the next instruction is fetched and executed.</p>
<p>See also: &quot;Serializing Instructions&quot; in Chapter 7 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3 AP-485, Intel Processor Identification and the CPUID Instruction (Order Number 241618)</p>
<h3>INPUT EAX = 0: Returns CPUID's Highest Value for Basic Processor Information and the Vendor Identification String</h3><p>When CPUID executes with EAX set to 0, the processor returns the highest value the CPUID recognizes for returning basic processor information. The value is returned in the EAX register (see second table) and is processor specific.</p>
<p>Information Returned by CPUID Instruction</p>
<div>
<table class="grid">
<caption>Basic CPUID Information</caption>
<tr><th>Initial EAX Value</th><th>Register</th><th>Information Provided about the Processor</th></tr>
<tr><td>0H</td><td>EAX</td><td>Maximum Input Value for Basic CPUID Information (see second table)</td></tr>
<tr><td>-</td><td>EBX</td><td>&quot;Genu&quot;</td></tr>
<tr><td>-</td><td>ECX</td><td>&quot;ntel&quot;</td></tr>
<tr><td>-</td><td>EDX</td><td>&quot;ineI&quot;</td></tr>
<tr><td>01H</td><td>EAX</td><td>Version Information: Type, Family, Model, and Stepping ID</td></tr>
<tr><td>-</td><td>EBX</td><td>Bits 7-0: Brand Index</td></tr>
<tr><td>-</td><td>-</td><td>Bits 15-8: CLFLUSH line size (Value . 8 = cache line size in bytes)</td></tr>
<tr><td>-</td><td>-</td><td>Bits 23-16: Number of logical processors per physical processor; two for the Pentium 4 processor supporting Hyper-Threading Technology</td></tr>
<tr><td>-</td><td>-</td><td>Bits 31-24: Local APIC ID</td></tr>
<tr><td>-</td><td>ECX</td><td>Extended Feature Information (see fourth table)</td></tr>
<tr><td>-</td><td>EDX</td><td>Feature Information (see fifth table)</td></tr>
<tr><td>02H</td><td>EAX</td><td>Cache and TLB Information (see sixth table)</td></tr>
<tr><td>-</td><td>EBX</td><td>Cache and TLB Information</td></tr>
<tr><td>-</td><td>ECX</td><td>Cache and TLB Information</td></tr>
<tr><td>-</td><td>EDX</td><td>Cache and TLB Information</td></tr>
<tr><td>03H</td><td>EAX</td><td>Reserved.</td></tr>
<tr><td>-</td><td>EBX</td><td>Reserved.</td></tr>
<tr><td>-</td><td>ECX</td><td>Bits 00-31 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)</td></tr>
<tr><td>-</td><td>EDX</td><td>Bits 32-63 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)</td></tr>
<tr><td>-</td><td>-</td><td>NOTE: Processor serial number (PSN) is not supported in the Pentium 4 processor or later. On all models, use the PSN flag (returned using CPUID) to check for PSN support before accessing the feature. See AP-485, Intel Processor Identification and the CPUID Instruction (Order Number 241618) for more information on PSN.</td></tr>
<tr><td>04H</td><td>EAX</td><td>Bits 4-0: Cache Type**</td></tr>
<tr><td>-</td><td>-</td><td>Bits 7-5: Cache Level (starts at 1)</td></tr>
<tr><td>-</td><td>-</td><td>Bits 8: Self Initializing cache level (does not need SW initialization)</td></tr>
<tr><td>-</td><td>-</td><td>Bits 9: Fully Associative cache</td></tr>
<tr><td>-</td><td>-</td><td>Bits 13-10: Reserved</td></tr>
<tr><td>-</td><td>-</td><td>Bits 25-14: Number of threads sharing this cache*</td></tr>
<tr><td>-</td><td>-</td><td>Bits 31-26: Number of processor cores on this die (Multicore)*</td></tr>
<tr><td>-</td><td>EBX</td><td>Bits 11-00: L = System Coherency Line Size*</td></tr>
<tr><td>-</td><td>-</td><td>Bits 21-12: P = Physical Line partitions*</td></tr>
<tr><td>-</td><td>-</td><td>Bits 31-22: W = Ways of associativity*</td></tr>
<tr><td>-</td><td>ECX</td><td>Bits 31-00: S = Number of Sets*</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>-</td><td>0 = Null - No more caches</td></tr>
<tr><td>-</td><td>-</td><td>1 = Data Cache</td></tr>
<tr><td>-</td><td>-</td><td>2 = Instruction Cache</td></tr>
<tr><td>-</td><td>-</td><td>3 = Unified Cache</td></tr>
<tr><td>-</td><td>-</td><td>4-31 = Reserved</td></tr>
<tr><td>-</td><td>-</td><td>NOTE: CPUID leaves &gt; 3 &lt; 80000000 are only visible when IA32_CR_MISC_ENABLES.BOOT_NT4 (bit 22) is clear (Default)</td></tr>
<tr><td>5H</td><td>EAX</td><td>Bits 15-00: Smallest monitor-line size in bytes (default is processor's monitor granularity)</td></tr>
<tr><td>-</td><td>-</td><td>Bits 31-16: Reserved = 0</td></tr>
<tr><td>-</td><td>EBX</td><td>Bits 15-00: Largest monitor-line size in bytes (default is processor's monitor granularity)</td></tr>
<tr><td>-</td><td>-</td><td>Bits 31-16: Reserved = 0</td></tr>
<tr><td>-</td><td>ECX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved = 0</td></tr>
<tfoot>
<tr><td colspan="3">*Add one to the value in the register file to get the number. For example, the number of processor cores is EAX[31:26]+1.</td></tr>
<tr><td colspan="3">** Cache Types fields</td></tr>
</tfoot>
</table>
</div>
<div>
<table class="grid">
<caption>Extended Function CPUID Information</caption>
<tr><th>Initial EAX Value</th><th>Register</th><th>Information Provided about the Processor</th></tr>
<tr><td>80000000H</td><td>EAX</td><td>Maximum Input Value for Extended Function CPUID Information (see second table).</td></tr>
<tr><td>-</td><td>EBX</td><td>Reserved</td></tr>
<tr><td>-</td><td>ECX</td><td>Reserved</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved</td></tr>
<tr><td>80000001H</td><td>EAX</td><td>Extended Processor Signature and Extended Feature Bits. (Currently reserved)</td></tr>
<tr><td>-</td><td>EBX</td><td>Reserved</td></tr>
<tr><td>-</td><td>ECX</td><td>Reserved</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved</td></tr>
<tr><td>80000002H</td><td>EAX</td><td>Processor Brand String</td></tr>
<tr><td>-</td><td>EBX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>ECX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>EDX</td><td>Processor Brand String Continued</td></tr>
<tr><td>80000003H</td><td>EAX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>EBX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>ECX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>EDX</td><td>Processor Brand String Continued</td></tr>
<tr><td>80000004H</td><td>EAX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>EBX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>ECX</td><td>Processor Brand String Continued</td></tr>
<tr><td>-</td><td>EDX</td><td>Processor Brand String Continued</td></tr>
<tr><td>80000005H</td><td>EAX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EBX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>ECX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved = 0</td></tr>
<tr><td>80000006H</td><td>EAX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EBX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>ECX</td><td>Bits 0-7: Cache Line Size</td></tr>
<tr><td>-</td><td>-</td><td>Bits 15-12: L2 Associativity</td></tr>
<tr><td>-</td><td>-</td><td>Bits 31-16: Cache size in 1K units</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>80000007H EAX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EBX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>ECX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved = 0</td></tr>
<tr><td>80000008H</td><td>EAX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EBX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>ECX</td><td>Reserved = 0</td></tr>
<tr><td>-</td><td>EDX</td><td>Reserved = 0</td></tr>
</table>
</div>
<p>A vendor identification string is also returned in EBX, EDX, and ECX. For Intel processors, the string is &quot;GenuineIntel&quot; and is expressed: EBX = 756e6547h (* &quot;Genu&quot;, with G in the low nibble of BL *) EDX = 49656e69h (* &quot;ineI&quot;, with i in the low nibble of DL *) ECX = 6c65746eh (* &quot;ntel&quot;, with n in the low nibble of CL *)</p>
<h3>INPUT EAX = 80000000H: Returns CPUID's Highest Value for Extended Processor Information</h3><p>When CPUID executes with EAX set to 0, the processor returns the highest value the processor recognizes for returning extended processor information. The value is returned in the EAX register (see second table) and is processor specific.</p>
<div>
<table class="grid">
<caption>Highest CPUID Source Operand for IA-32 Processors</caption>
<tr><th>IA-32 Processors</th><th>Basic Information</th><th>Extended Function Information</th></tr>
<tr><td>Earlier Intel486 Processors</td><td>CPUID Not Implemented</td><td>CPUID Not Implemented</td></tr>
<tr><td>Later Intel486 Processors and Pentium Processors</td><td>01H</td><td>Not Implemented</td></tr>
<tr><td>Pentium Pro and Pentium II Processors, Intel&Atilde;&Acirc;&reg; Celeron&Atilde;&cent;&acirc;&Acirc;&cent; Processors</td><td>02H</td><td>Not Implemented</td></tr>
<tr><td>Pentium III Processors</td><td>03H</td><td>Not Implemented</td></tr>
<tr><td>Pentium 4 Processors</td><td>02H</td><td>80000004H</td></tr>
<tr><td>Intel Xeon Processors</td><td>02H</td><td>80000004H</td></tr>
<tr><td>Pentium M Processor</td><td>02H</td><td>80000004H</td></tr>
<tr><td>Pentium 4 Processor supporting Hyper-Threading Technology</td><td>05H</td><td>80000008H</td></tr>
</table>
</div>
<p>Returns Microcode Update Signature For processors that support the microcode update facility, the IA32_BIOS_SIGN_ID MSR is loaded with the update signature whenever CPUID executes. The signature is returned in the upper DWORD. For details, see Chapter 9 in the IA-32 Intel Architecture Software Developer's Manual, Volume 3.</p>
<h3>INPUT EAX = 1: Returns Model, Family, Stepping Information</h3><p>When CPUID executes with EAX set to 1, version information is returned in EAX. For example: model, family, and processor type for the first processor in the Intel Pentium 4 family is returned as follows:</p>
<ul>
<li>Model - 0000B</li>
<li>Family - 1111B</li>
<li>Processor Type - 00B</li>
</ul>
<p>See third table for available processor type values. Stepping IDs are provided as needed.</p>
<div>
<table class="grid">
<caption>Version Information Returned by CPUID in EAX</caption>
<tr><th>Bit #</th><th>Information</th></tr>
<tr><td>0-3</td><td>Stepping ID</td></tr>
<tr><td>4-7</td><td>Model</td></tr>
<tr><td>8-11</td><td>Family ID</td></tr>
<tr><td>12-13</td><td>Processor Type</td></tr>
<tr><td>14-15</td><td>Reserved</td></tr>
<tr><td>16-19</td><td>Extended Model ID</td></tr>
<tr><td>20-27</td><td>Extended Family ID</td></tr>
<tr><td>28-31</td><td>Reserved</td></tr>
</table>
</div>
<div>
<table class="grid">
<caption>Processor Type Field</caption>
<tr><th>Type</th><th>Encoding</th></tr>
<tr><td>Original OEM Processor</td><td>00B</td></tr>
<tr><td>Intel OverDrive&Atilde;&Acirc;&reg; Processor</td><td>01B</td></tr>
<tr><td>Dual processor (not applicable to Intel486 processors)</td><td>10B</td></tr>
<tr><td>Intel reserved</td><td>11B</td></tr>
<tfoot>
<tr><td colspan="2">NOTE See AP-485, Intel Processor Identification and the CPUID Instruction (Order Number 241618) and Chapter 14 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for information on identifying earlier IA-32 processors.</td></tr>
</tfoot>
</table>
</div>
<p>The Extended Family ID and Extended Model ID need be examined only if the Family ID reaches 0FH. Always display processor information as a combination of family, model, and stepping.</p>
<p>Integrate the ID fields into a display as: Displayed family = ((Extended Family ID(4-bits) &lt;&lt; 4)) (8-bits) + Family ID (4-bits zero extended to 8-bits).</p>
<p>Compute the displayed model from the Model ID and the Extended Model ID as: Displayed Model = ((Extended Model ID (4-bits) &lt;&lt; 4))(8-bits) + Model (4-bits zero extended to 8-bits)</p>
<h3>INPUT EAX = 1: Returns Additional Information in EBX</h3><p>When CPUID executes with EAX set to 1, additional information is returned to the EBX register: - Brand index (low byte of EBX) - this number provides an entry into a brand string table that contains brand strings for IA-32 processors. More information about this field is provided later in this section.</p>
<dl>
<dt>CLFLUSH instruction cache line size (second byte of EBX)</dt>
<dd>this number indicates the size of the cache line flushed with CLFLUSH instruction in 8-byte increments. This field was introduced in the Pentium 4 processor.</dd>
<dt>Local APIC ID (high byte of EBX)</dt>
<dd>this number is the 8-bit ID that is assigned to the local APIC on the processor during power up. This field was introduced in the Pentium 4 processor.</dd>
</dl>
<h3>INPUT EAX = 1: Returns Feature Information in ECX and EDX</h3><p>When CPUID executes with EAX set to 1, feature information is returned in ECX and EDX.</p>
<ul>
<li>Table four shows encodings for ECX.</li>
<li>Table five shows encodings for EDX.</li>
</ul>
<p>For all feature flags, a 1 indicates that the feature is supported. Use Intel to properly interpret feature flags.</p>
<p>NOTE Software must confirm that a processor feature is present using feature flags returned by CPUID prior to using the feature. Software should not depend on future offerings retaining all features.</p>
<div>
<table class="grid">
<caption>Extended Feature Information Returned in the ECX Register</caption>
<tr><th>Bit #</th><th>Mnemonic</th><th>Description</th></tr>
<tr><td>0</td><td>SSE3</td><td>Streaming SIMD Extensions 3 (SSE3). A value of 1 indicates the processor supports this technology.</td></tr>
<tr><td>1-2</td><td>-</td><td>Reserved</td></tr>
<tr><td>3</td><td>MONITOR</td><td>MONITOR/MWAIT. A value of 1 indicates the processor supports this feature.</td></tr>
<tr><td>4</td><td>DS-CPL</td><td>CPL Qualified Debug Store. A value of 1 indicates the processor supports the extensions to the Debug Store feature to allow for branch message storage qualified by CPL.</td></tr>
<tr><td>5-6</td><td>-</td><td>Reserved</td></tr>
<tr><td>7</td><td>EST</td><td>Enhanced Intel SpeedStep&Atilde;&Acirc;&reg; technology. A value of 1 indicates that the processor supports this technology.</td></tr>
<tr><td>8</td><td>TM2</td><td>Thermal Monitor 2. A value of 1 indicates whether the processor supports this technology.</td></tr>
<tr><td>9</td><td>-</td><td>Reserved</td></tr>
<tr><td>10</td><td>CNXT-ID</td><td>L1 Context ID. A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or shared mode. A value of 0 indicates this feature is not supported. See definition of the IA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode) for details.</td></tr>
<tr><td>11-31</td><td>-</td><td>Reserved</td></tr>
</table>
</div>
<div>
<table class="grid">
<caption>Feature Information Returned in the EDX Register</caption>
<tr><th>Bit #</th><th>Mnemonic</th><th>Description</th></tr>
<tr><td>0</td><td>FPU</td><td>Floating Point Unit On-Chip. The processor contains an x87 FPU.</td></tr>
<tr><td>1</td><td>VME</td><td>Virtual 8086 Mode Enhancements. Virtual 8086 mode enhancements, including CR4.VME for controlling the feature, CR4.PVI for protected mode virtual interrupts, software interrupt indirection, expansion of the TSS with the software indirection bitmap, and EFLAGS.VIF and EFLAGS.VIP flags.</td></tr>
<tr><td>2</td><td>DE</td><td>Debugging Extensions. Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional trapping of accesses to DR4 and DR5.</td></tr>
<tr><td>3</td><td>PSE</td><td>Page Size Extension. Large pages of size 4 MByte are supported, including CR4.PSE for controlling the feature, the defined dirty bit in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.</td></tr>
<tr><td>4</td><td>TSC</td><td>Time Stamp Counter. The RDTSC instruction is supported, including CR4.TSD for controlling privilege.</td></tr>
<tr><td>5</td><td>MSR</td><td>Model Specific Registers RDMSR and WRMSR Instructions. The RDMSR and WRMSR instructions are supported. Some of the MSRs are implementation dependent.</td></tr>
<tr><td>6</td><td>PAE</td><td>Physical Address Extension. Physical addresses greater than 32 bits are supported: extended page table entry formats, an extra level in the page translation tables is defined, 2-MByte pages are supported instead of 4 Mbyte pages if PAE bit is 1. The actual number of address bits beyond 32 is not defined, and is implementation specific.</td></tr>
<tr><td>7</td><td>MCE</td><td>Machine Check Exception. Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the feature. This feature does not define the model-specific implementations of machine-check error logging, reporting, and processor shutdowns. Machine Check exception handlers may have to depend on processor version to do model specific processing of the exception, or test for the presence of the Machine Check feature.</td></tr>
<tr><td>8</td><td>CX8</td><td>CMPXCHG8B Instruction. The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly locked and atomic).</td></tr>
<tr><td>9</td><td>APIC</td><td>APIC On-Chip. The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to memory mapped commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some processors permit the APIC to be relocated).</td></tr>
<tr><td>10</td><td>-</td><td>Reserved</td></tr>
<tr><td>11</td><td>SEP</td><td>SYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and associated MSRs are supported. 12 MTRR Memory Type Range Registers. MTRRs are supported. The MTRRcap MSR contains feature bits that describe what memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs are supported.</td></tr>
<tr><td>13</td><td>PGE</td><td>PTE Global Bit. The global bit in page directory entries (PDEs) and page table entries (PTEs) is supported, indicating TLB entries that are common to different processes and need not be flushed. The CR4.PGE bit controls this feature.</td></tr>
<tr><td>14</td><td>MCA</td><td>Machine Check Architecture. The Machine Check Architecture, which provides a compatible mechanism for error reporting in P6 family, Pentium 4, Intel Xeon processors, and future processors, is supported. The MCG_CAP MSR contains feature bits describing how many banks of error reporting MSRs are supported.</td></tr>
<tr><td>15</td><td>CMOV</td><td>Conditional Move Instructions. The conditional move instruction CMOV is supported. In addition, if x87 FPU is present as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported</td></tr>
<tr><td>16</td><td>PAT</td><td>Page Attribute Table. Page Attribute Table is supported. This feature augments the Memory Type Range Registers (MTRRs), allowing an operating system to specify attributes of memory on a 4K granularity through a linear address.</td></tr>
<tr><td>17</td><td>PSE-36</td><td>36-Bit Page Size Extension. Extended 4-MByte pages that are capable of addressing physical memory beyond 4 GBytes are supported. This feature indicates that the upper four bits of the physical address of the 4-MByte page is encoded by bits 13-16 of the page directory entry.</td></tr>
<tr><td>18</td><td>PSN</td><td>Processor Serial Number. The processor supports the 96-bit processor identification number feature and the feature is enabled.</td></tr>
<tr><td>19</td><td>CLFSH</td><td>CLFLUSH Instruction. CLFLUSH Instruction is supported. 20 Reserved Reserved</td></tr>
<tr><td>21</td><td>DS</td><td>Debug Store. The processor supports the ability to write debug information into a memory resident buffer. This feature is used by the branch trace store (BTS) and precise event-based sampling (PEBS) facilities (see Chapter 15, Debugging and Performance Monitoring, in the IA-32 Intel Architecture Software Developer's Manual, Volume 3).</td></tr>
<tr><td>22</td><td>ACPI</td><td>Thermal Monitor and Software Controlled Clock Facilities. The processor implements internal MSRs that allow processor temperature to be monitored and processor performance to be modulated in predefined duty cycles under software control.</td></tr>
<tr><td>23</td><td>MMX</td><td>Intel MMX Technology. The processor supports the Intel MMX technology.</td></tr>
<tr><td>24</td><td>FXSR</td><td>FXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are supported for fast save and restore of the floating point context. Presence of this bit also indicates that CR4.OSFXSR is available for an operating system to indicate that it supports the FXSAVE and FXRSTOR instructions.</td></tr>
<tr><td>25</td><td>SSE</td><td>SSE. The processor supports the SSE extensions.</td></tr>
<tr><td>26</td><td>SSE2</td><td>SSE2. The processor supports the SSE2 extensions.</td></tr>
<tr><td>27</td><td>SS</td><td>Self Snoop. The processor supports the management of conflicting memory types by performing a snoop of its own cache structure for transactions issued to the bus.</td></tr>
<tr><td>28</td><td>HTT</td><td>Hyper-Threading Technology. The processor supports Hyper-Threading Technology.</td></tr>
<tr><td>29</td><td>TM</td><td>Thermal Monitor. The processor implements the thermal monitor automatic thermal control circuitry (TCC).</td></tr>
<tr><td>30</td><td>-</td><td>Reserved</td></tr>
<tr><td>31</td><td>PBE</td><td>Pending Break Enable. The processor supports the use of the FERR#/PBE# pin when the processor is in the stop-clock state (STPCLK# is asserted) to signal the processor that an interrupt is pending and that the processor should return to normal operation to handle the interrupt. Bit 10 (PBE enable) in the IA32_MISC_ENABLE MSR enables this capability.</td></tr>
</table>
</div>
<h3>INPUT EAX = 2: Cache and TLB Information Returned in EAX, EBX, ECX, EDX</h3><p>When CPUID executes with EAX set to 2, the processor returns information about the processor's internal caches and TLBs in the EAX, EBX, ECX, and EDX registers.</p>
<p>The encoding is as follows: - The least-significant byte in register EAX (register AL) indicates the number of times the CPUID instruction must be executed with an input value of 2 to get a complete description of the processor's caches and TLBs. The first member of the family of Pentium 4 processors will return a 1.</p>
<ul>
<li>The most significant bit (bit 31) of each register indicates whether the register contains valid information (set to 0) or is reserved (set to 1).</li>
<li>If a register contains valid information, the information is contained in 1 byte descriptors.</li>
</ul>
<p>Table six shows the encoding of these descriptors. Note that the order of descriptors in the EAX, EBX, ECX, and EDX registers is not defined; that is, specific bytes are not designated to contain descriptors for specific cache or TLB types. The descriptors may appear in any order.</p>
<div>
<table class="grid">
<caption>Encoding of Cache and TLB Descriptors</caption>
<tr><th>Descriptor</th><th>Value Cache or TLB Description</th></tr>
<tr><td>00H</td><td>Null descriptor</td></tr>
<tr><td>01H</td><td>Instruction TLB: 4 KByte Pages, 4-way set associative, 32 entries</td></tr>
<tr><td>02H</td><td>Instruction TLB: 4 MByte Pages, 4-way set associative, 2 entries</td></tr>
<tr><td>03H</td><td>Data TLB: 4KByte Pages, 4-way set associative, 64 entries</td></tr>
<tr><td>04H</td><td>Data TLB: 4MByte Pages, 4-way set associative, 8 entries</td></tr>
<tr><td>06H</td><td>1st-level instruction cache: 8 KBytes, 4-way set associative, 32 byte line size</td></tr>
<tr><td>08H</td><td>1st-level instruction cache: 16 KBytes, 4-way set associative, 32 byte line size</td></tr>
<tr><td>0AH</td><td>1st-level data cache: 8 KBytes, 2-way set associative, 32 byte line size</td></tr>
<tr><td>0CH</td><td>1st-level data cache: 16 KBytes, 4-way set associative, 32 byte line size</td></tr>
<tr><td>22H</td><td>3rd-level cache: 512 KBytes, 4-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>23H</td><td>3rd-level cache: 1 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>25H</td><td>3rd-level cache: 2 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>29H</td><td>3rd-level cache: 4M Bytes, 8-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>2CH</td><td>1st-level data cache: 32K Bytes, 8-way set associative, 64 byte line size</td></tr>
<tr><td>30H</td><td>1st-level instruction cache: 32K Bytes, 8-way set associative, 64 byte line size</td></tr>
<tr><td>40H</td><td>No 2nd-level cache or, if processor contains a valid 2nd-level cache, no 3rd-level cache</td></tr>
<tr><td>41H</td><td>2nd-level cache: 128 KBytes, 4-way set associative, 32 byte line size</td></tr>
<tr><td>42H</td><td>2nd-level cache: 256 KBytes, 4-way set associative, 32 byte line size</td></tr>
<tr><td>43H</td><td>2nd-level cache: 512 KBytes, 4-way set associative, 32 byte line size</td></tr>
<tr><td>44H</td><td>2nd-level cache: 1 MByte, 4-way set associative, 32 byte line size</td></tr>
<tr><td>45H</td><td>2nd-level cache: 2 MByte, 4-way set associative, 32 byte line size</td></tr>
<tr><td>50H</td><td>Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 64 entries</td></tr>
<tr><td>51H</td><td>Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 128 entries</td></tr>
<tr><td>52H</td><td>Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 256 entries</td></tr>
<tr><td>5BH</td><td>Data TLB: 4 KByte and 4 MByte pages, 64 entries</td></tr>
<tr><td>5CH</td><td>Data TLB: 4 KByte and 4 MByte pages,128 entries</td></tr>
<tr><td>5DH</td><td>Data TLB: 4 KByte and 4 MByte pages,256 entries</td></tr>
<tr><td>60H</td><td>1st-level data cache: 16 KByte, 8-way set associative, 64 byte line size</td></tr>
<tr><td>66H</td><td>1st-level data cache: 8 KByte, 4-way set associative, 64 byte line size</td></tr>
<tr><td>67H</td><td>1st-level data cache: 16 KByte, 4-way set associative, 64 byte line size</td></tr>
<tr><td>68H</td><td>1st-level data cache: 32 KByte, 4-way set associative, 64 byte line size</td></tr>
<tr><td>70H</td><td>Trace cache: 12 K-&Atilde;&Acirc;&micro;op, 8-way set associative</td></tr>
<tr><td>71H</td><td>Trace cache: 16 K-&Atilde;&Acirc;&micro;op, 8-way set associative</td></tr>
<tr><td>72H</td><td>Trace cache: 32 K-&Atilde;&Acirc;&micro;op, 8-way set associative</td></tr>
<tr><td>78H</td><td>2nd-level cache: 1 MByte, 4-way set associative, 64byte line size</td></tr>
<tr><td>79H</td><td>2nd-level cache: 128 KByte, 8-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>7AH</td><td>2nd-level cache: 256 KByte, 8-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>7BH</td><td>2nd-level cache: 512 KByte, 8-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>7CH</td><td>2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size, 2 lines per sector</td></tr>
<tr><td>7DH</td><td>2nd-level cache: 2 MByte, 8-way set associative, 64byte line size</td></tr>
<tr><td>7FH</td><td>2nd-level cache: 512 KByte, 2-way set associative, 64-byte line size</td></tr>
<tr><td>82H</td><td>2nd-level cache: 256 KByte, 8-way set associative, 32 byte line size</td></tr>
<tr><td>83H</td><td>2nd-level cache: 512 KByte, 8-way set associative, 32 byte line size</td></tr>
<tr><td>84H</td><td>2nd-level cache: 1 MByte, 8-way set associative, 32 byte line size</td></tr>
<tr><td>85H</td><td>2nd-level cache: 2 MByte, 8-way set associative, 32 byte line size</td></tr>
<tr><td>86H</td><td>2nd-level cache: 512 KByte, 4-way set associative, 64 byte line size</td></tr>
<tr><td>87H</td><td>2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size</td></tr>
<tr><td>B0H</td><td>Instruction TLB: 4 KByte Pages, 4-way set associative, 128 entries</td></tr>
<tr><td>B3H</td><td>Data TLB: 4 KByte Pages, 4-way set associative, 128 entries</td></tr>
<tr><td>F0H</td><td>64-Byte Prefetching</td></tr>
<tr><td>F1H</td><td>128-Byte Prefetching</td></tr>
</table>
</div>
<p>Example of Cache and TLB Interpretation The first member of the family of Pentium 4 processors returns the following information about caches and TLBs when the CPUID executes with an input value of 2: EAX 66 5B 50 01H EBX 0H ECX 0H EDX 00 7A 70 00H Which means: - The least-significant byte (byte 0) of register EAX is set to 01H. This indicates that CPUID needs to be executed once with an input value of 2 to retrieve complete information about caches and TLBs.</p>
<ul>
<li>The most-significant bit of all four registers (EAX, EBX, ECX, and EDX) is set to 0, indicating that each register contains valid 1-byte descriptors.</li>
<li>Bytes 1, 2, and 3 of register EAX indicate that the processor has: 50H -&gt; a 64-entry instruction TLB, for mapping 4-KByte and 2-MByte or 4-MByte pages;	5BH -&gt; a 64-entry data TLB, for mapping 4-KByte and 4-MByte pages; 66H -&gt; an 8-KByte 1st level data cache, 4-way set associative, with a 64-Byte cache line size.</li>
<li>The descriptors in registers EBX and ECX are valid, but contain NULL descriptors.</li>
<li>Bytes 0, 1, 2, and 3 of register EDX indicate that the processor has: 00H -&gt; NULL descriptor; 70H -&gt; a 12-KByte 1st level code cache, 4-way set associative, with a 64-byte cache line size; 7AH -&gt; a 256-KByte 2nd level cache, 8-way set associative, with a sectored, 64-byte cache line size; 00H -&gt; NULL descriptor.</li>
</ul>
<h3>Methods for returning branding information</h3><p>Use the following techniques to access branding information: 1. Processor brand string method; this method also returns the processor's maximum operating frequency 2. Processor brand index; this method uses a software supplied brand string table.</p>
<p>These two methods are discussed in the following sections. For methods that are available in early processors, see Section: &quot;Identification of Earlier IA-32 Processors&quot; in Chapter 14 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1.</p>
<p>The Processor Brand String Method describes the algorithm used for detection of the brand string. Processor brand identification software should execute this algorithm on all IA-32 architecture compatible processors.</p>
<p>This method (introduced with Pentium 4 processors) returns an ASCII brand identification string and the maximum operating frequency of the processor to the EAX, EBX, ECX, and EDX registers.</p>
<h3>Determination of Support for the Processor Brand String</h3><pre>EAX = 1
CPUID
IF (EAX &gt;= 080000004H)
THEN
	* Processor Brand String Supported *
ELSE
	* Processor Brand String Not Supported *
FI;
</pre>
<p>How Brand Strings Work To use the brand string method, execute CPUID with EAX input of 8000002H through 80000004H. For each input value, CPUID returns 16 ASCII characters using EAX, EBX, ECX, and EDX. The returned string will be NULL terminated.</p>
<p>Table seven shows the brand string that is returned by the first processor in the Pentium 4 processor family.</p>
<div>
<table class="grid">
<caption>Processor Brand String Returned with Pentium 4 Processor</caption>
<tr><th>EAX Input Value</th><th>Return Values</th><th>ASCII Equivalent</th></tr>
<tr><td>80000002H</td><td>EAX = 20202020H</td><td>&quot; &quot;</td></tr>
<tr><td>-</td><td>EBX = 20202020H</td><td>&quot; &quot;</td></tr>
<tr><td>-</td><td>ECX = 20202020H</td><td>&quot; &quot;</td></tr>
<tr><td>-</td><td>EDX = 6E492020H</td><td>&quot;nI &quot;</td></tr>
<tr><td>80000003H</td><td>EAX = 286C6574H</td><td>&quot;(let&quot;</td></tr>
<tr><td>-</td><td>EBX = 50202952H</td><td>&quot;P )R&quot;</td></tr>
<tr><td>-</td><td>ECX = 69746E65H</td><td>&quot;itne&quot;</td></tr>
<tr><td>-</td><td>EDX = 52286D75H</td><td>&quot;R(mu&quot;</td></tr>
<tr><td>80000004H</td><td>EAX = 20342029H</td><td>&quot; 4 )&quot;</td></tr>
<tr><td>-</td><td>EBX = 20555043H</td><td>&quot; UPC&quot;</td></tr>
<tr><td>-</td><td>ECX = 30303531H</td><td>&quot;0051&quot;</td></tr>
<tr><td>-</td><td>EDX = 007A484DH</td><td>&quot; zHM&quot;</td></tr>
</table>
</div>
<p>Extracting the Maximum Processor Frequency from Brand Strings provides an algorithm which software can use to extract the maximum processor operating frequency from the processor brand string.</p>
<p>NOTE When a frequency is given in a brand string, it is the maximum qualified frequency of the processor, not the frequency at which the processor is currently running.</p>
<h3>Algorithm for Extracting Maximum Processor Frequency</h3><pre>Scan &quot;Brand String&quot; in Reverse Byte Order for (&quot;zHM&quot;, &quot;zHG&quot;, &quot;zHT&quot;)
IF Substring Matched
	SWITCH Substring
		CASE &quot;zHM&quot;: Multiplier = 10^6
		CASE &quot;zHG&quot;: Multiplier = 10^9
		CASE &quot;zHT&quot;: Multiplier = 10^12
	Scan Digits Until Blank In Reverse Order
	Freq = Reverse Digits To Decimal Value
	(* &quot;Freq&quot; = XY.Z if Digits = &quot;Z.YX&quot; *)
	Max. Qualifed Frequency = &quot;Freq&quot; x &quot;Multiplier&quot;
ELSE Report Error
</pre>
<p>The Processor Brand Index Method The brand index method (introduced with Pentium III Xeon processors) provides an entry point into a brand identification table that is maintained in memory by system software and is accessible from system- and user-level code. In this table, each brand index is associate with an ASCII brand identification string that identifies the official Intel family and model number of a processor.</p>
<p>When CPUID executes with EAX set to 1, the processor returns a brand index to the low byte in EBX. Software can then use this index to locate the brand identification string for the processor in the brand identification table. The first entry (brand index 0) in this table is reserved, allowing for backward compatibility with processors that do not support the brand identification feature.</p>
<p>Table eight shows brand indices that have identification strings associated with them.</p>
<div>
<table class="grid">
<caption>Mapping of Brand Indices and IA-32 Processor Brand Strings</caption>
<tr><th>Brand Index</th><th>Brand String</th></tr>
<tr><td>00H</td><td>This processor does not support the brand identification feature</td></tr>
<tr><td>01H</td><td>Intel(R) Celeron(R) processor</td></tr>
<tr><td>02H</td><td>Intel(R) Pentium(R) III processor</td></tr>
<tr><td>03H</td><td>Intel(R) Pentium(R) III XeonTM processor; If processor signature = 000006B1h, then Intel(R) Celeron(R) processor</td></tr>
<tr><td>04H</td><td>Intel(R) Pentium(R) III processor</td></tr>
<tr><td>06H</td><td>Mobile Intel(R) Pentium(R) III processor-M</td></tr>
<tr><td>07H</td><td>Mobile Intel(R) Celeron(R) processor</td></tr>
<tr><td>08H</td><td>Intel(R) Pentium(R) 4 processor</td></tr>
<tr><td>09H</td><td>Intel(R) Pentium(R) 4 processor</td></tr>
<tr><td>0AH</td><td>Intel(R) Celeron(R) processor</td></tr>
<tr><td>0BH</td><td>Intel(R) Xeon(TM) processor; If processor signature = 00000F13h, then Intel(R) Xeon(TM) processor MP</td></tr>
<tr><td>0CH</td><td>Intel(R) Xeon(TM) processor MP</td></tr>
<tr><td>0EH</td><td>Mobile Intel(R) Pentium(R) 4 processor-M; If processor signature = 00000F13h, then Intel(R) Xeon(TM) processor</td></tr>
<tr><td>0FH</td><td>Mobile Intel(R) Celeron(R) processor</td></tr>
<tr><td>11H</td><td>Mobile Genuine Intel(R) processor</td></tr>
<tr><td>12H</td><td>Intel(R) Celeron(R) M processor</td></tr>
<tr><td>13H</td><td>Mobile Intel(R) Celeron(R) processor</td></tr>
<tr><td>14H</td><td>Intel(R) Celeron(R) processor</td></tr>
<tr><td>15H</td><td>Mobile Genuine Intel(R) processor</td></tr>
<tr><td>16H</td><td>Intel(R) Pentium(R) M processor</td></tr>
<tr><td>17H</td><td>Mobile Intel(R) Celeron(R) processor</td></tr>
<tr><td>18H-0FFH</td><td>RESERVED</td></tr>
</table>
</div>
<br />0H</td><td>80000000H</td></tr><tr><td><strong>CVTDQ2PD</strong><br />Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F E6</code></td>
<td class="grid"><code>CVTDQ2PD xmm1, xmm2/m64</code></td>
<td class="grid">Convert two packed signed doubleword integers from xmm2/m128 to two packed double-precision floating-point values in xmm1.</td>
</tr>
</table></td><td>
<p>Converts two packed signed doubleword integers in the source operand (second operand) to two packed double-precision floating-point values in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. When the source operand is an XMM register, the packed integers are located in the low quadword of the register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertIntegerToDouble<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> ConvertIntegerToDouble<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>CVTDQ2PS</strong><br />Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 5B /r</code></td>
<td class="grid"><code>CVTDQ2PS xmm1, xmm2/m128</code></td>
<td class="grid">Convert four packed signed doubleword integers from xmm2/m128 to four packed single-precision floating-point values in xmm1.</td>
</tr>
</table></td><td>
<p>Converts four packed signed doubleword integers in the source operand (second operand) to four packed single-precision floating-point values in the destination operand (first operand). The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. When a conversion is inexact, rounding is performed according to the rounding control bits in the MXCSR register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertIntegerToFloat<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertIntegerToFloat<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> ConvertIntegerToFloat<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> ConvertIntegerToFloat<span class="operator">(</span>Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
Precision.
</td></tr><tr><td><strong>CVTPD2DQ</strong><br />Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F E6</code></td>
<td class="grid"><code>CVTPD2DQ xmm1, xmm2/m128</code></td>
<td class="grid">Convert two packed double-precision floating-point values from xmm2/m128 to two packed signed doubleword integers in xmm1.</td>
</tr>
</table></td><td>
<p>Converts two packed double-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The result is stored in the low quadword of the destination operand and the high quadword is cleared to all 0s.</p>
<p>When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertDoubleToInteger<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertDoubleToInteger<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
Invalid, Precision.
</td></tr><tr><td><strong>CVTPD2PI</strong><br />Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 2D /r</code></td>
<td class="grid"><code>CVTPD2PI mm, xmm/m128</code></td>
<td class="grid">Convert two packed double-precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm.</td>
</tr>
</table></td><td>
<p>Converts two packed double-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand).</p>
<p>The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register.</p>
<p>When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p>
<p>This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPD2PI instruction is executed.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertDoubleToInteger<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertDoubleToInteger<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
Invalid, Precision.
</td></tr><tr><td><strong>CVTPD2PS</strong><br />Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 5A /r</code></td>
<td class="grid"><code>CVTPD2PS xmm1, xmm2/m128 Convert two packed double-precision floating-point values in xmm2/m128 to two packed singleprecision floating-point values in xmm1.</code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Converts two packed double-precision floating-point values in the source operand (second operand) to two packed single-precision floating-point values in the destination operand (first operand). The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The result is stored in the low quadword of the destination operand, and the high quadword is cleared to all 0s. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertDoubleToFloat<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertDoubleToFloat<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>Overflow,</code></td><td>Underflow, Invalid, Precision, Denormal.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>CVTPI2PD</strong><br />Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 2A /r</code></td>
<td class="grid"><code>CVTPI2PD xmm, mm/m64</code></td>
<td class="grid">Convert two packed signed doubleword integers from mm/mem64 to two packed double-precision floating-point values in xmm.</td>
</tr>
</table></td><td>
<p>Converts two packed signed doubleword integers in the source operand (second operand) to two packed double-precision floating-point values in the destination operand (first operand). The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an XMM register.</p>
<p>This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPI2PD instruction is executed.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertIntegerToDouble<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> ConvertIntegerToDouble<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>CVTPI2PS</strong><br />Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 2A /r</code></td>
<td class="grid"><code>CVTPI2PS xmm, mm/m64</code></td>
<td class="grid">Convert two signed doubleword integers from mm/m64 to two single-precision floating-point values in xmm.</td>
</tr>
</table></td><td>
<p>Converts two packed signed doubleword integers in the source operand (second operand) to two packed single-precision floating-point values in the destination operand (first operand). The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an XMM register. The results are stored in the low quadword of the destination operand, and the high quadword remains unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.</p>
<p>This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPI2PS instruction is executed.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertIntegerToFloat<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertIntegerToFloat<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
<span class="comment">//high quadword of destination remains unchanged</span>
</pre>
</td><td>
Precision.
</td></tr><tr><td><strong>CVTPS2DQ</strong><br />Convert Packed Single-Precision Floating-Point Values to Packed Doubleword Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 5B /r</code></td>
<td class="grid"><code>CVTPS2DQ xmm1, xmm2/m128</code></td>
<td class="grid">Convert four packed single-precision floating-point values from xmm2/m128 to four packed signed doubleword integers in xmm1.</td>
</tr>
</table></td><td>
<p>Converts four packed single-precision floating-point values in the source operand (second operand) to four packed signed doubleword integers in the destination operand (first operand).</p>
<p>The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p>
<p>When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToInteger<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToInteger<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToInteger<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToInteger<span class="operator">(</span>Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
Invalid, Precision.
</td></tr><tr><td><strong>CVTPS2PD</strong><br />Convert Packed Single-Precision Floating-Point Values to Packed Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 5A /r</code></td>
<td class="grid"><code>CVTPS2PD xmm1, xmm2/m64</code></td>
<td class="grid">Convert two packed single-precision floating-point values in xmm2/m64 to two packed double-precision floating-point values in xmm1.</td>
</tr>
</table></td><td>
<p>Converts two packed single-precision floating-point values in the source operand (second operand) to two packed double-precision floating-point values in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. When the source operand is an XMM register, the packed single-precision floating-point values are contained in the low quadword of the register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToDouble<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToDouble<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
Invalid, Denormal.
</td></tr><tr><td><strong>CVTPS2PI</strong><br />Convert Packed Single-Precision Floating-Point Values to Packed Doubleword Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 2D /r</code></td>
<td class="grid"><code>CVTPS2PI mm, xmm/m64</code></td>
<td class="grid">Convert two packed single-precision floating-point values from xmm/m64 to two packed signed doubleword integers in mm.</td>
</tr>
</table></td><td>
<p>Converts two packed single-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand).</p>
<p>The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register. When the source operand is an XMM register, the two single-precision floating-point values are contained in the low quadword of the register.</p>
<p>When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p>
<p>This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPS2PI instruction is executed.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToInteger<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToInteger<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
Invalid, Precision.
</td></tr><tr><td><strong>CVTSD2SI</strong><br />Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 2D /r</code></td>
<td class="grid"><code>CVTSD2SI r32, xmm/m64</code></td>
<td class="grid">Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer r32.</td>
</tr>
</table></td><td>
<p>Converts a double-precision floating-point value in the source operand (second operand) to a signed doubleword integer in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register.</p>
<p>When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertDoubleToInteger<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
Invalid, Precision.
</td></tr><tr><td><strong>CVTSD2SS</strong><br />Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 5A /r</code></td>
<td class="grid"><code>CVTSD2SS xmm1, xmm2/m64</code></td>
<td class="grid">Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1.</td>
</tr>
</table></td><td>
<p>Converts a double-precision floating-point value in the source operand (second operand) to a single-precision floating-point value in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register. The result is stored in the low doubleword of the destination operand, and the upper 3 doublewords are left unchanged. When the conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertDoubleToFloat<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
<span class="comment">//Destination[32..127] remains unchanged</span>
</pre>
</td><td>
Overflow, Underflow, Invalid, Precision, Denormal.
</td></tr><tr><td><strong>CVTSI2SD</strong><br />Convert Doubleword Integer to Scalar Double- Precision Floating-Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 2A /r</code></td>
<td class="grid"><code>CVTSI2SD xmm, r/m32</code></td>
<td class="grid">Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm.</td>
</tr>
</table></td><td>
<p>Converts a signed doubleword integer in the source operand (second operand) to a double-precision floating-point value in the destination operand (first operand). The source operand can be a general-purpose register or a 32-bit memory location. The destination operand is an XMM register. The result is stored in the low quadword of the destination operand, and the high quadword left unchanged.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertIntegerToDouble<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
<span class="comment">//Destination[64..127] remains unchanged</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>CVTSI2SS</strong><br />Convert Doubleword Integer to Scalar Single- Precision Floating-Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 2A /r</code></td>
<td class="grid"><code>CVTSI2SS xmm, r/m32</code></td>
<td class="grid">Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm.</td>
</tr>
</table></td><td>
<p>Converts a signed doubleword integer in the source operand (second operand) to a single-precision floating-point value in the destination operand (first operand). The source operand can be a general-purpose register or a 32-bit memory location. The destination operand is an XMM register. The result is stored in the low doubleword of the destination operand, and the upper three doublewords are left unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertIntegerToFloat<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
<span class="comment">//Destination[32..127] remains unchanged</span>
</pre>
</td><td>
Precision.
</td></tr><tr><td><strong>CVTSS2SD</strong><br />Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 5A /r</code></td>
<td class="grid"><code>CVTSS2SD xmm1, xmm2/m32</code></td>
<td class="grid">Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1.</td>
</tr>
</table></td><td>
<p>Converts a single-precision floating-point value in the source operand (second operand) to a double-precision floating-point value in the destination operand (first operand). The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register. The result is stored in the low quadword of the destination operand, and the high quadword is left unchanged.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToDouble<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
<span class="comment">//Destination[64..127] remains unchanged</span>
</pre>
</td><td>
Invalid, Denormal.
</td></tr><tr><td><strong>CVTSS2SI</strong><br />Convert Scalar Single-Precision Floating-Point Value to Doubleword Integer<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 2D /r</code></td>
<td class="grid"><code>CVTSS2SI r32, xmm/m32</code></td>
<td class="grid">Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32.</td>
</tr>
</table></td><td>
<p>Converts a single-precision floating-point value in the source operand (second operand) to a signed doubleword integer in the destination operand (first operand). The source operand can be an XMM register or a 32-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register.</p>
<p>When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToInteger<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
Invalid, Precision.
</td></tr><tr><td><strong>CVTTPD2PI</strong><br />Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 2C /r</code></td>
<td class="grid"><code>CVTTPD2PI mm, xmm/m128</code></td>
<td class="grid">Convert two packer double-precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm using truncation.</td>
</tr>
</table></td><td>
<p>Converts two packed double-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand).</p>
<p>The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register.</p>
<p>When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p>
<p>This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTTPD2PI instruction is executed.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertDoubleToIntegerTruncate<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertDoubleToIntegerTruncate<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
Invalid, Precision.
</td></tr><tr><td><strong>CVTTPD2DQ</strong><br />Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F E6</code></td>
<td class="grid"><code>CVTTPD2DQ xmm1, xmm2/m128</code></td>
<td class="grid">Convert two packed double-precision floating-point values from xmm2/m128 to two packed signed doubleword integers in xmm1 using truncation.</td>
</tr>
</table></td><td>
<p>Converts two packed double-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The result is stored in the low quadword of the destination operand and the high quadword is cleared to all 0s.</p>
<p>When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertDoubleToIntegerTruncate<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertDoubleToIntegerTruncate<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
Invalid, Precision.
</td></tr><tr><td><strong>CVTTPS2DQ</strong><br />Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Doubleword Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 5B /r</code></td>
<td class="grid"><code>CVTTPS2DQ xmm1, xmm2/m128</code></td>
<td class="grid">Convert four single-precision floating-point values from xmm2/m128 to four signed doubleword integers in xmm1 using truncation.</td>
</tr>
</table></td><td>
<p>Converts four packed single-precision floating-point values in the source operand (second operand) to four packed signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToIntegerTruncate<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToIntegerTruncate<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToIntegerTruncate<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToIntegerTruncate<span class="operator">(</span>Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
Invalid, Precision.
</td></tr><tr><td><strong>CVTTPS2PI</strong><br />Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Doubleword Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 2C /r</code></td>
<td class="grid"><code>CVTTPS2PI mm, xmm/m64</code></td>
<td class="grid">Convert two single-precision floating-point values from xmm/m64 to two signed doubleword signed integers in mm using truncation.</td>
</tr>
</table></td><td>
<p>Converts two packed single-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand).</p>
<p>The source operand can be an XMM register or a 64-bit memory location. The destination operand is an MMX technology register. When the source operand is an XMM register, the two single-precision floating-point values are contained in the low quadword of the register.</p>
<p>When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p>
<p>This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTTPS2PI instruction is executed.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToIntegerTruncate<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToIntegerTruncate<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
Invalid, Precision.
</td></tr><tr><td><strong>CVTTSD2SI</strong><br />Convert with Truncation Scalar Double-Precision Floating-Point Value to Signed Doubleword Integer<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 2C /r</code></td>
<td class="grid"><code>CVTTSD2SI r32, xmm/m64</code></td>
<td class="grid">Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer in r32 using truncation.</td>
</tr>
</table></td><td>
<p>Converts a double-precision floating-point value in the source operand (second operand) to a signed doubleword integer in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register.</p>
<p>When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertDoubleToIntegerTruncate<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
Invalid, Precision.
</td></tr><tr><td><strong>CVTTSS2SI</strong><br />Convert with Truncation Scalar Single-Precision Floating-Point Value to Doubleword Integer<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 2C /r</code></td>
<td class="grid"><code>CVTTSS2SI r32, xmm/m32</code></td>
<td class="grid">Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32 using truncation.</td>
</tr>
</table></td><td>
<p>Converts a single-precision floating-point value in the source operand (second operand) to a signed doubleword integer in the destination operand (first operand). The source operand can be an XMM register or a 32-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register.</p>
<p>When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ConvertFloatToIntegerTruncate<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
Invalid, Precision.
</td></tr><tr><td><strong>CWD/CDQ</strong><br />Convert Word to Doubleword/Convert Doubleword to Quadword<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>99</code></td>
<td class="grid"><code>CWD</code></td>
<td class="grid">DX:AX = sign-extend of AX</td>
</tr>
<tr>
<td class="grid"><code>99</code></td>
<td class="grid"><code>CDQ</code></td>
<td class="grid">EDX:EAX = sign-extend of EAX</td>
</tr>
</table></td><td>
<p>Doubles the size of the operand in register AX or EAX (depending on the operand size) by means of sign extension and stores the result in registers DX:AX or EDX:EAX, respectively.</p>
<p>The CWD instruction copies the sign (bit 15) of the value in the AX register into every bit position in the DX register (see Figure 7-6 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1). The CDQ instruction copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register.</p>
<p>The CWD instruction can be used to produce a doubleword dividend from a word before a word division, and the CDQ instruction can be used to produce a quadword dividend from a doubleword before doubleword division.</p>
<p>The CWD and CDQ mnemonics reference the same opcode. The CWD instruction is intended for use when the operand-size attribute is 16 and the CDQ instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when CWD is used and to 32 when CDQ is used. Others may treat these mnemonics as synonyms (CWD/CDQ) and use the current setting of the operand-size attribute to determine the size of values to be converted, regardless of the mnemonic used.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> DX <span class="operator">=</span> SignExtend<span class="operator">(</span>AX<span class="operator">)</span><span class="operator">;</span> <span class="comment">//CWD instruction</span>
<span class="keyword">else</span> EDX <span class="operator">=</span> SignExtend<span class="operator">(</span>EAX<span class="operator">)</span><span class="operator">;</span> <span class="comment">//OperandSize = 32, CDQ instruction</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>DAA</strong><br />Decimal Adjust AL after Addition<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>27</code></td>
<td class="grid"><code>DAA</code></td>
<td class="grid">Decimal adjust AL after addition.</td>
</tr>
</table></td><td>
<p>Adjusts the sum of two packed BCD values to create a packed BCD result. The AL register is the implied source and destination operand. The DAA instruction is only useful when it follows an ADD instruction that adds (binary addition) two 2-digit, packed BCD values and stores a byte result in the AL register. The DAA instruction then adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal carry is detected, the CF and AF flags are set accordingly.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>AL <span class="operator">&amp;</span> <span class="number">0xF</span> <span class="operator">&gt;</span> <span class="number">9</span> <span class="operator">||</span> AF <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> {
	CF <span class="operator">=</span> OldCF <span class="operator">|</span> GetCarry<span class="operator">(</span>AL <span class="operator">=</span> AL <span class="operator">+</span> <span class="number">6</span><span class="operator">)</span><span class="operator">;</span>
	AF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
}
<span class="keyword">else</span> AF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>

<span class="keyword">if</span><span class="operator">(</span>OldAL <span class="operator">&gt;</span> <span class="number">0x99</span> <span class="operator">||</span> OldCF <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> {
	AL <span class="operator">=</span> AL <span class="operator">+</span> <span class="number">0x60</span><span class="operator">;</span>
	CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
}
<span class="keyword">else</span> CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
<p>The CF and AF flags are set if the adjustment of the value results in a decimal carry in either digit of the result (see the &quot;Operations&quot; section above). The SF, ZF, and PF flags are set according to the result. The OF flag is undefined.
</p>
</td></tr><tr><td><strong>DAS</strong><br />Decimal Adjust AL after Subtraction<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>2F</code></td>
<td class="grid"><code>DAS</code></td>
<td class="grid">Decimal adjust AL after subtraction.</td>
</tr>
</table></td><td>
<p>Adjusts the result of the subtraction of two packed BCD values to create a packed BCD result.</p>
<p>The AL register is the implied source and destination operand. The DAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtraction) one 2-digit, packed BCD value from another and stores a byte result in the AL register. The DAS instruction then adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal borrow is detected, the CF and AF flags are set accordingly.</p>
<br />
<pre>OldAL <span class="operator">=</span> AL<span class="operator">;</span>
OldCF <span class="operator">=</span> CF<span class="operator">;</span>
CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>

<span class="keyword">if</span><span class="operator">(</span>AL <span class="operator">&amp;</span> <span class="number">0xF</span> <span class="operator">&gt;</span> <span class="number">9</span> <span class="operator">||</span> AF <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> {
	CF <span class="operator">=</span> OldCF <span class="operator">|</span> GetBorrow<span class="operator">(</span>AL <span class="operator">=</span> AL <span class="operator">-</span> <span class="number">6</span><span class="operator">)</span><span class="operator">;</span>
	AF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
}
<span class="keyword">else</span> AF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>

<span class="keyword">if</span><span class="operator">(</span>OldAL <span class="operator">&gt;</span> <span class="number">0x99</span> <span class="operator">||</span> OldCF <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> {
	AL <span class="operator">=</span> AL <span class="operator">-</span> <span class="number">0x60</span><span class="operator">;</span>
	CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
}
<span class="keyword">else</span> CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
<p>The CF and AF flags are set if the adjustment of the value results in a decimal borrow in either digit of the result (see the &quot;Operations&quot; section above). The SF, ZF, and PF flags are set according to the result. The OF flag is undefined.
</p>
</td></tr><tr><td><strong>DEC</strong><br />Decrement by 1<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>FE /1</code></td>
<td class="grid"><code>DEC r/m8</code></td>
<td class="grid">Decrement r/m8 by 1.</td>
</tr>
<tr>
<td class="grid"><code>FF /1</code></td>
<td class="grid"><code>DEC r/m16</code></td>
<td class="grid">Decrement r/m16 by 1.</td>
</tr>
<tr>
<td class="grid"><code>FF /1</code></td>
<td class="grid"><code>DEC r/m32</code></td>
<td class="grid">Decrement r/m32 by 1.</td>
</tr>
<tr>
<td class="grid"><code>48+rw</code></td>
<td class="grid"><code>DEC r16</code></td>
<td class="grid">Decrement r16 by 1.</td>
</tr>
<tr>
<td class="grid"><code>48+rd</code></td>
<td class="grid"><code>DEC r32</code></td>
<td class="grid">Decrement r32 by 1.</td>
</tr>
</table></td><td>
<p>Subtracts 1 from the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (To perform a decrement operation that updates the CF flag, use a SUB instruction with an immediate operand of 1.) This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<br />
<pre>Destination <span class="operator">=</span> Destination <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
</pre>
</td><td>
<p>The CF flag is not affected. The OF, SF, ZF, AF, and PF flags are set according to the result.
</p>
</td></tr><tr><td><strong>DIV</strong><br />Unsigned Divide<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F6 /6</code></td>
<td class="grid"><code>DIV r/m8</code></td>
<td class="grid">Unsigned divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder.</td>
</tr>
<tr>
<td class="grid"><code>F7 /6</code></td>
<td class="grid"><code>DIV r/m16</code></td>
<td class="grid">Unsigned divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.</td>
</tr>
<tr>
<td class="grid"><code>F7 /6</code></td>
<td class="grid"><code>DIV r/m32</code></td>
<td class="grid">Unsigned divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.</td>
</tr>
</table></td><td>
<p>Divides (unsigned) the value in the AX, DX:AX, or EDX:EAX registers (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, or EDX:EAX registers.</p>
<div>
<table class="grid">
<caption>DIV Action</caption>
<tr><th>Operand Size</th><th>Dividend</th><th>Divisor</th><th>Quotient</th><th>Remainder</th><th>Maximum Quotient</th></tr>
<tr><td>Word/byte</td><td>AX</td><td>r/m8</td><td>AL</td><td>AH</td><td>2^8 - 1</td></tr>
<tr><td>Doubleword/word</td><td>DX:AX</td><td>r/m16</td><td>AX</td><td>DX</td><td>2^16 - 1</td></tr>
<tr><td>Quadword/doubleword</td><td>EDX:EAX</td><td>r/m32</td><td>EAX</td><td>EDX</td><td>2^32 - 1</td></tr>
</table>
</div>
<p>The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor). See the table above.</p>
<p>Non-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magnitude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.</p>
<br />Word/byte</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>Source <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>DE<span class="operator">)</span><span class="operator">;</span> <span class="comment">//divide error</span>

<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">8</span><span class="operator">)</span> { <span class="comment">//word/byte operation</span>
	Temporary <span class="operator">=</span> AX / Source<span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Temporary <span class="operator">&gt;</span> <span class="number">0xFF</span><span class="operator">)</span> Exception<span class="operator">(</span>DE<span class="operator">)</span><span class="operator">;</span> <span class="comment">//divide error</span>
	<span class="keyword">else</span> {
		AL <span class="operator">=</span> Temporary<span class="operator">;</span>
		AH <span class="operator">=</span> AX <span class="operator">%</span> Source<span class="operator">;</span>
	}
}
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> { <span class="comment">//doubleword/word operation</span>
	Temporary <span class="operator">=</span> DX<span class="operator">:</span>AX / Source<span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Temporary <span class="operator">&gt;</span> <span class="number">0xFFFF</span><span class="operator">)</span> Exception<span class="operator">(</span>DE<span class="operator">)</span><span class="operator">;</span> <span class="comment">//divide error</span>
	<span class="keyword">else</span> {
		AX <span class="operator">=</span> Temporary<span class="operator">;</span>
		DX <span class="operator">=</span> DX<span class="operator">:</span>AX <span class="operator">%</span> Source<span class="operator">;</span>
	}
}
<span class="keyword">else</span> { <span class="comment">//quadword/doubleword operation</span>
	Temporary <span class="operator">=</span> EDX<span class="operator">:</span>EAX / Source<span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Temporary <span class="operator">&gt;</span> <span class="number">0xFFFFFFFF</span><span class="operator">)</span> Exception<span class="operator">(</span>DE<span class="operator">)</span><span class="operator">;</span> <span class="comment">//divide error</span>
	<span class="keyword">else</span> {
		EAX <span class="operator">=</span> Temporary<span class="operator">;</span>
		EDX <span class="operator">=</span> EDX<span class="operator">:</span>EAX <span class="operator">%</span> Source<span class="operator">;</span>
	}
}
</pre>
</td></tr><tr><td><strong>DIVPD</strong><br />Divide Packed Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 5E /r</code></td>
<td class="grid"><code>DIVPD xmm1, xmm2/m128</code></td>
<td class="grid">Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values xmm2/m128.</td>
</tr>
</table></td><td>
<p>Performs an SIMD divide of the four packed double-precision floating-point values in the destination operand (first operand) by the four packed double-precision floating-point values in the source operand (second operand), and stores the packed double-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 11-3 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD double-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> / Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> / Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
Overflow, Underflow, Invalid, Divide-by-Zero, Precision, Denormal.
</td></tr><tr><td><strong>DIVPS</strong><br />Divide Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 5E /r</code></td>
<td class="grid"><code>DIVPS xmm1, xmm2/m128</code></td>
<td class="grid">Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values xmm2/m128.</td>
</tr>
</table></td><td>
<p>Performs an SIMD divide of the two packed single-precision floating-point values in the destination operand (first operand) by the two packed single-precision floating-point values in the source operand (second operand), and stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD single-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> / Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> / Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> / Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> / Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
Overflow, Underflow, Invalid, Divide-by-Zero, Precision, Denormal.
</td></tr><tr><td><strong>DIVSD</strong><br />Divide Scalar Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 5E /r</code></td>
<td class="grid"><code>DIVSD xmm1, xmm2/m64</code></td>
<td class="grid">Divide low double-precision floating-point value n xmm1 by low double-precision floating-point value in xmm2/mem64.</td>
</tr>
</table></td><td>
<p>Divides the low double-precision floating-point value in the destination operand (first operand) by the low double-precision floating-point value in the source operand (second operand), and stores the double-precision floating-point result in the destination operand. The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. The high quadword of the destination operand remains unchanged. See Figure 11-4 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of a scalar double-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> / Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[64..127] remains unchanged</span>
</pre>
</td><td>
Overflow, Underflow, Invalid, Divide-by-Zero, Precision, Denormal.
</td></tr><tr><td><strong>DIVSS</strong><br />Divide Scalar Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 5E /r</code></td>
<td class="grid"><code>DIVSS xmm1, xmm2/m32</code></td>
<td class="grid">Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32.</td>
</tr>
</table></td><td>
<p>Divides the low single-precision floating-point value in the destination operand (first operand) by the low single-precision floating-point value in the source operand (second operand), and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of a scalar single-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> / Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[32..127] remains unchanged</span>
</pre>
</td><td>
Overflow, Underflow, Invalid, Divide-by-Zero, Precision, Denormal.
</td></tr><tr><td><strong>EMMS</strong><br />Empty MMX Technology State<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 77</code></td>
<td class="grid"><code>EMMS</code></td>
<td class="grid">Set the x87 FPU tag word to empty.</td>
</tr>
</table></td><td>
<p>Sets the values of all the tags in the x87 FPU tag word to empty (all 1s). This operation marks the x87 FPU data registers (which are aliased to the MMX technology registers) as available for use by x87 FPU floating-point instructions. (See Figure 8-7 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for the format of the x87 FPU tag word.) All other MMX instructions (other than the EMMS instruction) set all the tags in x87 FPU tag word to valid (all 0s).</p>
<p>The EMMS instruction must be used to clear the MMX technology state at the end of all MMX technology procedures or subroutines and before calling other procedures or subroutines that may execute x87 floating-point instructions. If a floating-point instruction loads one of the registers in the x87 FPU data register stack before the x87 FPU tag word has been reset by the EMMS instruction, an x87 floating-point register stack overflow can occur that will result in an x87 floating-point exception or incorrect result.</p>
<br />
<pre>x87FPUTagWord <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>ENTER</strong><br />Make Stack Frame for Procedure Parameters<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>C8 iw 00</code></td>
<td class="grid"><code>ENTER imm16,0</code></td>
<td class="grid">Create a stack frame for a procedure.</td>
</tr>
<tr>
<td class="grid"><code>C8 iw 01</code></td>
<td class="grid"><code>ENTER imm16,1</code></td>
<td class="grid">Create a nested stack frame for a procedure.</td>
</tr>
<tr>
<td class="grid"><code>C8 iw ib</code></td>
<td class="grid"><code>ENTER imm16,imm8</code></td>
<td class="grid">Create a nested stack frame for a procedure.</td>
</tr>
</table></td><td>
<p>Creates a stack frame for a procedure. The first operand (size operand) specifies the size of the stack frame (that is, the number of bytes of dynamic storage allocated on the stack for the procedure).</p>
<p>The second operand (nesting level operand) gives the lexical nesting level (0 to 31) of the procedure. The nesting level determines the number of stack frame pointers that are copied into the &quot;display area&quot; of the new stack frame from the preceding frame. Both of these operands are immediate values.</p>
<p>The stack-size attribute determines whether the BP (16 bits) or EBP (32 bits) register specifies the current frame pointer and whether SP (16 bits) or ESP (32 bits) specifies the stack pointer.</p>
<p>The ENTER and companion LEAVE instructions are provided to support block structured languages. The ENTER instruction (when used) is typically the first instruction in a procedure and is used to set up a new stack frame for a procedure. The LEAVE instruction is then used at the end of the procedure (just before the RET instruction) to release the stack frame.</p>
<p>If the nesting level is 0, the processor pushes the frame pointer from the EBP register onto the stack, copies the current stack pointer from the ESP register into the EBP register, and loads the ESP register with the current stack-pointer value minus the value in the size operand. For nesting levels of 1 or greater, the processor pushes additional frame pointers on the stack before adjusting the stack pointer. These additional frame pointers provide the called procedure with access points to other nested frames on the stack. See &quot;Procedure Calls for Block-Structured Languages&quot; in Chapter 6 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for more information about the actions of the ENTER instruction.</p>
<br />
<pre>NestingLevel <span class="operator">=</span> NestingLevel <span class="operator">%</span> <span class="number">32</span><span class="operator">;</span>

<span class="keyword">if</span><span class="operator">(</span>StackSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
	Push<span class="operator">(</span>EBP<span class="operator">)</span><span class="operator">;</span>
	FrameTemp <span class="operator">=</span> ESP<span class="operator">;</span>
}
<span class="keyword">else</span> { <span class="comment">//StackSize = 16</span>
	Push<span class="operator">(</span>BP<span class="operator">)</span><span class="operator">;</span>
	FrameTemp <span class="operator">=</span> SP<span class="operator">;</span>
}

<span class="keyword">if</span><span class="operator">(</span>NestingLevel <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> <span class="keyword">goto</span> Continue<span class="operator">;</span>
<span class="keyword">else</span> {
	<span class="keyword">for</span><span class="operator">(</span>i <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> i <span class="operator">&lt;</span> NestingLevel<span class="operator">;</span> <span class="operator">++</span>i<span class="operator">)</span> {
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
			<span class="keyword">if</span><span class="operator">(</span>StackSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
				EBP <span class="operator">=</span> EBP <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
				Push<span class="operator">(</span>EBP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//doubleword push</span>
			}
			<span class="keyword">else</span> { <span class="comment">//StackSize == 16</span>
				BP <span class="operator">=</span> BP <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
				Push<span class="operator">(</span>BP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//doubleword push</span>
			}
		}
		<span class="keyword">else</span> { <span class="comment">//OperandSize = 16</span>
			<span class="keyword">if</span><span class="operator">(</span>StackSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
				EBP <span class="operator">=</span> EBP <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
				Push<span class="operator">(</span>EBP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//doubleword push</span>
			}
			<span class="keyword">else</span> { <span class="comment">//StackSize == 16</span>
				BP <span class="operator">=</span> BP <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
				Push<span class="operator">(</span>BP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//doubleword push</span>
			}
		}
	}
	
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> Push<span class="operator">(</span>FrameTemp<span class="operator">)</span><span class="operator">;</span> <span class="comment">//doubleword push</span>
	<span class="keyword">else</span> Push<span class="operator">(</span>FrameTemp<span class="operator">)</span><span class="operator">;</span> <span class="comment">//OperandSize == 16, word push</span>
}

Continue<span class="operator">:</span>
<span class="keyword">if</span><span class="operator">(</span>StackSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
	EBP <span class="operator">=</span> FramTemp<span class="operator">;</span>
	ESP <span class="operator">=</span> EBP <span class="operator">-</span> Size<span class="operator">;</span>
}
<span class="keyword">else</span> { <span class="comment">//StackSize == 16</span>
	BP <span class="operator">=</span> FramTemp<span class="operator">;</span>
	SP <span class="operator">=</span> BP <span class="operator">-</span> Size<span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>F2XM1</strong><br />Compute 2x-1<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 F0</code></td>
<td class="grid"><code>F2XM1</code></td>
<td class="grid">Replace ST(0) with (2ST(0) - 1).</td>
</tr>
</table></td><td>
<p>Computes the exponential value of 2 to the power of the source operand minus 1. The source operand is located in register ST(0) and the result is also stored in ST(0). The value of the source operand must lie in the range -1.0 to +1.0. If the source value is outside this range, the result is undefined.</p>
<p>The following table shows the results obtained when computing the exponential value of various classes of numbers, assuming that neither overflow nor underflow occurs.</p>
<div>
<table class="grid">
<caption>Results Obtained from F2XM1</caption>
<tr><th>ST(0) Source</th><th>ST(0) Destination</th></tr>
<tr><td>-1.0 to -0</td><td>-0.5 to -0</td></tr>
<tr><td>-0</td><td>-0</td></tr>
<tr><td>+0</td><td>+0</td></tr>
<tr><td>+0 to +1.0</td><td>+0 to 1.0</td></tr>
</table>
</div>
<p>Values other than 2 can be exponentiated using the following formula:</p>
<pre>x^y = 2 * (y * log_2(x))
</pre>
<br />-1.0 to -0</td><td>
<pre>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> <span class="number">2</span> <span class="operator">*</span> ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FABS</strong><br />Absolute Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 E1</code></td>
<td class="grid"><code>FABS</code></td>
<td class="grid">Replace ST with its absolute value.</td>
</tr>
</table></td><td>
<p>Clears the sign bit of ST(0) to create the absolute value of the operand. The following table shows the results obtained when creating the absolute value of various classes of numbers.</p>
<div>
<table class="grid">
<caption>Results Obtained from FABS</caption>
<tr><th>ST(0) Source</th><th>ST(0) Destination</th></tr>
<tr><td>-inf</td><td>+inf</td></tr>
<tr><td>-F</td><td>+F</td></tr>
<tr><td>-0</td><td>+0</td></tr>
<tr><td>+0</td><td>+0</td></tr>
<tr><td>+F</td><td>+F</td></tr>
<tr><td>+inf</td><td>+inf</td></tr>
<tr><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="2">NOTE: F Means finite floating-point value.</td></tr>
</tfoot>
</table>
</div>
<br />-inf</td><td>
<pre>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FADD/FADDP/FIADD</strong><br />Add<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D8 /0</code></td>
<td class="grid"><code>FADD m32fp</code></td>
<td class="grid">Add m32fp to ST(0) and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>DC /0</code></td>
<td class="grid"><code>FADD m64fp</code></td>
<td class="grid">Add m64fp to ST(0) and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>D8 C0+i</code></td>
<td class="grid"><code>FADD ST(0), ST(i)</code></td>
<td class="grid">Add ST(0) to ST(i) and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>DC C0+i</code></td>
<td class="grid"><code>FADD ST(i), ST(0)</code></td>
<td class="grid">Add ST(i) to ST(0) and store result in ST(i).</td>
</tr>
<tr>
<td class="grid"><code>DE C0+i</code></td>
<td class="grid"><code>FADDP ST(i), ST(0)</code></td>
<td class="grid">Add ST(0) to ST(i), store result in ST(i), and pop the register stack.</td>
</tr>
<tr>
<td class="grid"><code>DE C1</code></td>
<td class="grid"><code>FADDP</code></td>
<td class="grid">Add ST(0) to ST(1), store result in ST(1), and pop the register stack.</td>
</tr>
<tr>
<td class="grid"><code>DA /0</code></td>
<td class="grid"><code>FIADD m32int</code></td>
<td class="grid">Add m32int to ST(0) and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>DE /0</code></td>
<td class="grid"><code>FIADD m16int</code></td>
<td class="grid">Add m16int to ST(0) and store result in ST(0).</td>
</tr>
</table></td><td>
<p>Adds the destination and source operands and stores the sum in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.</p>
<p>The no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-operand version adds the contents of a memory location (either a floating-point or an integer value) to the contents of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice versa. The value in ST(0) can be doubled by coding: FADD ST(0), ST(0); The FADDP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. (The no-operand version of the floating-point add instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FADD rather than FADDP.) The FIADD instructions convert an integer source operand to double extended-precision floating-point format before performing the addition.</p>
<p>The table on the following page shows the results obtained when adding various classes of numbers, assuming that neither overflow nor underflow occurs.</p>
<p>When the sum of two operands with opposite signs is 0, the result is +0, except for the round toward -infinite mode, in which case the result is -0. When the source operand is an integer 0, it is treated as a +0.</p>
<p>When both operand are infinities of the same sign, the result is infinite of the expected sign. If both operands are infinities of opposite signs, an invalid-operation exception is generated. See the following table.</p>
<div>
<table class="grid">
<caption>FADD/FADDP/FIADD Results</caption>
<tr><td>-</td><td>Destination: -inf</td><td>Destination: -F</td><td>Destination: -0</td><td>Destination: +0</td><td>Destination: +F</td><td>Destination: +inf</td><td>Destination: NaN</td></tr>
<tr><td>Source: -inf</td><td>-inf</td><td>-inf</td><td>-inf</td><td>-inf</td><td>-inf</td><td>*</td><td>NaN</td></tr>
<tr><td>Source: -F or -I</td><td>-inf</td><td>-F</td><td>Source</td><td>Source</td><td>+-F or +-0</td><td>+inf</td><td>NaN</td></tr>
<tr><td>Source: -0</td><td>-inf</td><td>Destination</td><td>-0</td><td>+-0</td><td>Destination</td><td>+inf</td><td>NaN</td></tr>
<tr><td>Source: +0</td><td>-inf</td><td>Destination</td><td>+-0</td><td>+0</td><td>Destination</td><td>+inf</td><td>NaN</td></tr>
<tr><td>Source: +F or +I</td><td>-inf</td><td>+-F or +-0</td><td>Source</td><td>Source</td><td>+F</td><td>+inf</td><td>NaN</td></tr>
<tr><td>Source: +inf</td><td>*</td><td>+inf</td><td>+inf</td><td>+inf</td><td>+inf</td><td>+8</td><td>NaN</td></tr>
<tr><td>Source: NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="8">NOTES: F Means finite floating-point value.</td></tr>
<tr><td colspan="8">I Means integer.</td></tr>
<tr><td colspan="8">* Indicates floating-point invalid-arithmetic-operand (#IA) exception.</td></tr>
</tfoot>
</table>
</div>
<br />Source: -inf</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FIADD<span class="operator">)</span> Destination <span class="operator">=</span> Destination <span class="operator">+</span> ConvertToExtendedDouble<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">else</span> Destination <span class="operator">=</span> Destination <span class="operator">+</span> Source<span class="operator">;</span> <span class="comment">//source operand is floating-point value</span>
<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FADDP<span class="operator">)</span> PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FBLD</strong><br />Load Binary Coded Decimal<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>DF /4</code></td>
<td class="grid"><code>FBLD m80</code></td>
<td class="grid">dec Convert BCD value to floating-point and push onto the FPU stack.</td>
</tr>
</table></td><td>
<p>Converts the BCD source operand into double extended-precision floating-point format and pushes the value onto the FPU stack. The source operand is loaded without rounding errors. The sign of the source operand is preserved, including that of -0.</p>
<p>The packed BCD digits are assumed to be in the range 0 through 9; the instruction does not check for invalid digits (AH through FH). Attempting to load an invalid encoding produces an undefined result.</p>
<br />
<pre>TOP <span class="operator">=</span> TOP <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> ConvertToExtendedDouble<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>C1 Set to 1 if stack overflow occurred; otherwise, set to 0.
C0, C2, C3 Undefined.
</p>
</td></tr><tr><td><strong>FBSTP</strong><br />Store BCD Integer and Pop<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>DF /6</code></td>
<td class="grid"><code>FBSTP m80bcd</code></td>
<td class="grid">Store ST(0) in m80bcd and pop ST(0).</td>
</tr>
</table></td><td>
<p>Converts the value in the ST(0) register to an 18-digit packed BCD integer, stores the result in the destination operand, and pops the register stack. If the source value is a non-integral value, it is rounded to an integer value, according to rounding mode specified by the RC field of the FPU control word. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.</p>
<p>The destination operand specifies the address where the first byte destination value is to be stored. The BCD value (including its sign bit) requires 10 bytes of space in memory.</p>
<p>The following table shows the results obtained when storing various classes of numbers in packed BCD format.</p>
<div>
<table class="grid">
<caption>FBSTP Results</caption>
<tr><th>ST(0)</th><th>Destination</th></tr>
<tr><td>-inf or Value Too Large for Destination Format</td><td>*</td></tr>
<tr><td>F &lt;= -1</td><td>-D</td></tr>
<tr><td>-1 &lt; F &lt; -0</td><td>**</td></tr>
<tr><td>-0</td><td>-0</td></tr>
<tr><td>+0</td><td>+0</td></tr>
<tr><td>+0 &lt; F &lt; +1</td><td>**</td></tr>
<tr><td>F &gt;= +1</td><td>+D</td></tr>
<tr><td>+inf or Value Too Large for Destination Format</td><td>*</td></tr>
<tr><td>NaN</td><td>*</td></tr>
<tfoot>
<tr><td colspan="2">NOTES: F Means finite floating-point value.</td></tr>
<tr><td colspan="2">D Means packed-BCD number.</td></tr>
<tr><td colspan="2">* Indicates floating-point invalid-operation (#IA) exception.</td></tr>
<tr><td colspan="2">** +-0 or +-1, depending on the rounding mode.</td></tr>
</tfoot>
</table>
</div>
<p>If the converted value is too large for the destination format, or if the source operand is an infinite, SNaN, QNAN, or is in an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination operand. If the invalid-operation exception is masked, the packed BCD indefinite value is stored in memory.</p>
<br />-inf or Value Too Large for Destination Format</td><td>
<pre>Destination <span class="operator">=</span> BCD<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FCHS</strong><br />Change Sign<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 E0</code></td>
<td class="grid"><code>FCHS</code></td>
<td class="grid">Complements sign of ST(0)</td>
</tr>
</table></td><td>
<p>Complements the sign bit of ST(0). This operation changes a positive value into a negative value of equal magnitude or vice versa. The following table shows the results obtained when changing the sign of various classes of numbers.</p>
<div>
<table class="grid">
<caption>FCHS Results</caption>
<tr><th>ST(0) Source</th><th>ST(0) Destination</th></tr>
<tr><td>-inf</td><td>+inf</td></tr>
<tr><td>-F</td><td>+F</td></tr>
<tr><td>-0</td><td>+0</td></tr>
<tr><td>+0</td><td>-0</td></tr>
<tr><td>+F</td><td>-F</td></tr>
<tr><td>+inf</td><td>-inf</td></tr>
<tr><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="2">NOTE: F Means finite floating-point value.</td></tr>
</tfoot>
</table>
</div>
<br />-inf</td><td>
<pre>SignBit<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">~</span>SignBit<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FCLEX/FNCLEX</strong><br />Clear Exceptions<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>9B DB E2</code></td>
<td class="grid"><code>FCLEX</code></td>
<td class="grid">Clear floating-point exception flags after checking for pending unmasked floating-point exceptions.</td>
</tr>
<tr>
<td class="grid"><code>DB E2</code></td>
<td class="grid"><code>FNCLEX*</code></td>
<td class="grid">Clear floating-point exception flags without checking for pending unmasked floating-point exceptions. See the IA-32 Architecture Compatibility section below.</td>
</tr>
</table></td><td>
<p>Clears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE), the exception summary status flag (ES), the stack fault flag (SF), and the busy flag (B) in the FPU status word. The FCLEX instruction checks for and handles any pending unmasked floating-point exceptions before clearing the exception flags; the FNCLEX instruction does not.</p>
<p>The assembler issues two instructions for the FCLEX instruction (an FWAIT instruction followed by an FNCLEX instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.</p>
<br />
<pre>FPUStatusWord<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
FPUStatusWord<span class="operator">[</span><span class="number">15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
<p>The PE, UE, OE, ZE, DE, IE, ES, SF, and B flags in the FPU status word are cleared. The C0,
C1, C2, and C3 flags are undefined.
</p>
</td></tr><tr><td><strong>FCMOVcc</strong><br />Floating-Point Conditional Move<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>DA C0+i</code></td>
<td class="grid"><code>FCMOVB ST(0), ST(i)</code></td>
<td class="grid">Move if below (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>DA C8+i</code></td>
<td class="grid"><code>FCMOVE ST(0), ST(i)</code></td>
<td class="grid">Move if equal (ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>DA D0+i</code></td>
<td class="grid"><code>FCMOVBE ST(0), ST(i)</code></td>
<td class="grid">Move if below or equal (CF=1 or ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>DA D8+i</code></td>
<td class="grid"><code>FCMOVU ST(0), ST(i)</code></td>
<td class="grid">Move if unordered (PF=1).</td>
</tr>
<tr>
<td class="grid"><code>DB C0+i</code></td>
<td class="grid"><code>FCMOVNB ST(0), ST(i)</code></td>
<td class="grid">Move if not below (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>DB C8+i</code></td>
<td class="grid"><code>FCMOVNE ST(0), ST(i)</code></td>
<td class="grid">Move if not equal (ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>DB D0+i</code></td>
<td class="grid"><code>FCMOVNBE ST(0), ST(i)</code></td>
<td class="grid">Move if not below or equal (CF=0 and ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>DB D8+i</code></td>
<td class="grid"><code>FCMOVNU ST(0), ST(i)</code></td>
<td class="grid">Move if not unordered (PF=0).</td>
</tr>
</table></td><td>
<p>Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic is given in the Descriptions column above and in Table 7-4 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).</p>
<p>The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.</p>
<p>A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor's feature information with the CPUID instruction (see &quot;COMISS-Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS&quot; in this chapter). If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Condition <span class="operator">==</span> <span class="keyword">true</span><span class="operator">)</span> ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span>i<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>C1 Set to 0 if stack underflow occurred.
C0, C2, C3 Undefined.
</p>
</td></tr><tr><td><strong>FCOM/FCOMP/FCOMPP</strong><br />Compare Floating Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D8 /2</code></td>
<td class="grid"><code>FCOM m32fp</code></td>
<td class="grid">Compare ST(0) with m32fp.</td>
</tr>
<tr>
<td class="grid"><code>DC /2</code></td>
<td class="grid"><code>FCOM m64fp</code></td>
<td class="grid">Compare ST(0) with m64fp.</td>
</tr>
<tr>
<td class="grid"><code>D8 D0+i</code></td>
<td class="grid"><code>FCOM ST(i)</code></td>
<td class="grid">Compare ST(0) with ST(i).</td>
</tr>
<tr>
<td class="grid"><code>D8 D1</code></td>
<td class="grid"><code>FCOM</code></td>
<td class="grid">Compare ST(0) with ST(1).</td>
</tr>
<tr>
<td class="grid"><code>D8 /3</code></td>
<td class="grid"><code>FCOMP m32fp</code></td>
<td class="grid">Compare ST(0) with m32fp and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>DC /3</code></td>
<td class="grid"><code>FCOMP m64fp</code></td>
<td class="grid">Compare ST(0) with m64fp and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>D8 D8+i</code></td>
<td class="grid"><code>FCOMP ST(i)</code></td>
<td class="grid">Compare ST(0) with ST(i) and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>D8 D9</code></td>
<td class="grid"><code>FCOMP</code></td>
<td class="grid">Compare ST(0) with ST(1) and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>DE D9</code></td>
<td class="grid"><code>FCOMPP</code></td>
<td class="grid">Compare ST(0) with ST(1) and pop register stack twice.</td>
</tr>
</table></td><td>
<p>Compares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below). The source operand can be a data register or a memory location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is ignored, so that -0.0 is equal to +0.0.</p>
<div>
<table class="grid">
<caption>FCOM/FCOMP/FCOMPP Results</caption>
<tr><th>Condition</th><th>C3</th><th>C2</th><th>C0</th></tr>
<tr><td>ST(0) &gt; Source</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>ST(0) &lt; Source</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>ST(0) = Source</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>Unordered*</td><td>1</td><td>1</td><td>1</td></tr>
<tfoot>
<tr><td colspan="4">NOTE: * Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</td></tr>
</tfoot>
</table>
</div>
<p>This instruction checks the class of the numbers being compared (see &quot;FXAM-Examine&quot; in this chapter). If either operand is a NaN or is in an unsupported format, an invalid-arithmeticoperand exception (#IA) is raised and, if the exception is masked, the condition flags are set to &quot;unordered.&quot; If the invalid-arithmetic-operand exception is unmasked, the condition code flags are not set.</p>
<p>The FCOMP instruction pops the register stack following the comparison operation and the FCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.</p>
<p>The FCOM instructions perform the same operation as the FUCOM instructions. The only difference is how they handle QNaN operands. The FCOM instructions raise an invalid-arithmetic- operand exception (#IA) when either or both of the operands is a NaN value or is in an unsupported format. The FUCOM instructions perform the same operation as the FCOM instructions, except that they do not generate an invalid-arithmetic-operand exception for QNaNs.</p>
<br />ST(0) &gt; Source</td><td>
<pre>OperandRelation <span class="operator">=</span> Compare<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">,</span> Source<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">switch</span><span class="operator">(</span>OperandRelation<span class="operator">)</span> {
	RelationGreaterThan<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	RelationLessThan<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	RelationEqual<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
<span class="keyword">if</span><span class="operator">(</span>IsNaN<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span> <span class="operator">||</span> IsNaN<span class="operator">(</span>Source<span class="operator">)</span> <span class="operator">||</span> IsUnsupportedFormat<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span> <span class="operator">||</span> IsUnsupportedFormat<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>IA<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>FPUControlWord<span class="operator">.</span>IM <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> {
	C3 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
	C2 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
	C0 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
}
<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FCOMP<span class="operator">)</span> PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FCOMPP<span class="operator">)</span> {
	PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
}
</pre>
</td></tr><tr><td><strong>FCOMI/FCOMIP/FUCOMI/FUCOMIP</strong><br />Compare Floating Point Values and Set EFLAGS<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>DB F0+i</code></td>
<td class="grid"><code>FCOMI ST, ST(i)</code></td>
<td class="grid">Compare ST(0) with ST(i) and set status flags accordingly.</td>
</tr>
<tr>
<td class="grid"><code>DF F0+i</code></td>
<td class="grid"><code>FCOMIP ST, ST(i)</code></td>
<td class="grid">Compare ST(0) with ST(i), set status flags accordingly, and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>DB E8+i</code></td>
<td class="grid"><code>FUCOMI ST, ST(i)</code></td>
<td class="grid">Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly.</td>
</tr>
<tr>
<td class="grid"><code>DF E8+i</code></td>
<td class="grid"><code>FUCOMIP ST, ST(i)</code></td>
<td class="grid">Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack.</td>
</tr>
</table></td><td>
<p>Performs an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and CF in the EFLAGS register according to the results (see the table below). The sign of zero is ignored for comparisons, so that -0.0 is equal to +0.0.</p>
<div>
<table class="grid">
<caption>FCOMI/FCOMIP/FUCOMI/FUCOMIP Results</caption>
<tr><th>Comparison Results</th><th>ZF</th><th>PF</th><th>CF</th></tr>
<tr><td>ST0 &gt; ST(i)</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>ST0 &lt; ST(i)</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>ST0 = ST(i)</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>Unordered*</td><td>1</td><td>1</td><td>1</td></tr>
<tfoot>
<tr><td colspan="4">NOTE: * Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</td></tr>
</tfoot>
</table>
</div>
<p>An unordered comparison checks the class of the numbers being compared (see &quot;FXAM-Examine&quot; in this chapter). The FUCOMI/FUCOMIP instructions perform the same operations as the FCOMI/FCOMIP instructions. The only difference is that the FUCOMI/FUCOMIP instructions raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format; QNaNs cause the condition code flags to be set to unordered, but do not cause an exception to be generated. The FCOMI/FCOMIP instructions raise an invalid-operation exception when either or both of the operands are a NaN value of any kind or are in an unsupported format.</p>
<p>If the operation results in an invalid-arithmetic-operand exception being raised, the status flags in the EFLAGS register are set only if the exception is masked.</p>
<p>The FCOMI/FCOMIP and FUCOMI/FUCOMIP instructions clear the OF flag in the EFLAGS register (regardless of whether an invalid-operation exception is detected).</p>
<p>The FCOMIP and FUCOMIP instructions also pop the register stack following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.</p>
<br />ST0 &gt; ST(i)</td><td>
<pre>OperandRelation <span class="operator">=</span> Compare<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">,</span> ST<span class="operator">(</span>i<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">switch</span><span class="operator">(</span>OperandRelation<span class="operator">)</span> {
	RelationGreaterThan<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	RelationLessThan<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	RelationEqual<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}

<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FCOMI <span class="operator">||</span> Instruction <span class="operator">==</span> FCOMIP<span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>IsQNaN<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span> <span class="operator">||</span> IsQNaN<span class="operator">(</span>ST<span class="operator">(</span>i<span class="operator">)</span><span class="operator">)</span><span class="operator">)</span> {
		ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		Exception<span class="operator">(</span>IA<span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span>FPUControlWord<span class="operator">.</span>IM <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> {
			ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
			PF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
			CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		}
	}
}

<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FCOMIP <span class="operator">||</span> Instruction <span class="operator">==</span> FUCOMIP<span class="operator">)</span> PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FCOS</strong><br />Cosine<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 FF</code></td>
<td class="grid"><code>FCOS</code></td>
<td class="grid">Replace ST(0) with its cosine.</td>
</tr>
</table></td><td>
<p>Computes the cosine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range -2^63 to +2^63. The following table shows the results obtained when taking the cosine of various classes of numbers.</p>
<div>
<table class="grid">
<caption>FCOS Results</caption>
<tr><th>ST(0) Source</th><th>ST(0) Destination</th></tr>
<tr><td>-inf</td><td>*</td></tr>
<tr><td>-F</td><td>-1 to +1</td></tr>
<tr><td>-0</td><td>+1</td></tr>
<tr><td>+0</td><td>+1</td></tr>
<tr><td>+F</td><td>-1 to +1</td></tr>
<tr><td>+inf</td><td>*</td></tr>
<tr><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="2">NOTES: F Means finite floating-point value.</td></tr>
<tr><td colspan="2">* Indicates floating-point invalid-arithmetic-operand (#IA) exception.</td></tr>
</tfoot>
</table>
</div>
<p>If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-ofrange conditions. Source values outside the range -2^63 to +2^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2 * pi or by using the FPREM instruction with a divisor of 2 * pi. See the section titled &quot;Pi&quot; in Chapter 8 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for a discussion of the proper value to use for pi in performing such reductions.</p>
<br />-inf</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>GetAbsoluteValue<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="operator">(</span><span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">63</span><span class="operator">)</span><span class="operator">)</span> {
	C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> Cosine<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
}
<span class="keyword">else</span> C2 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//source operand is out-of-range</span>
</pre>
</td></tr><tr><td><strong>FDECSTP</strong><br />Decrement Stack-Top Pointer<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 F6</code></td>
<td class="grid"><code>FDECSTP</code></td>
<td class="grid">Decrement TOP field in FPU status word.</td>
</tr>
</table></td><td>
<p>Subtracts one from the TOP field of the FPU status word (decrements the top-of-stack pointer).</p>
<p>If the TOP field contains a 0, it is set to 7. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Top <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Top <span class="operator">=</span> <span class="number">7</span><span class="operator">;</span>
<span class="keyword">else</span> Top <span class="operator">=</span> Top <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
</pre>
</td><td>
<p>The C1 flag is set to 0. The C0, C2, and C3 flags are undefined.
</p>
</td></tr><tr><td><strong>FDIV/FDIVP/FIDIV</strong><br />Divide<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D8 /6</code></td>
<td class="grid"><code>FDIV m32fp</code></td>
<td class="grid">Divide ST(0) by m32fp and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>DC /6</code></td>
<td class="grid"><code>FDIV m64fp</code></td>
<td class="grid">Divide ST(0) by m64fp and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>D8 F0+i</code></td>
<td class="grid"><code>FDIV ST(0), ST(i)</code></td>
<td class="grid">Divide ST(0) by ST(i) and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>DC F8+i</code></td>
<td class="grid"><code>FDIV ST(i), ST(0)</code></td>
<td class="grid">Divide ST(i) by ST(0) and store result in ST(i).</td>
</tr>
<tr>
<td class="grid"><code>DE F8+i</code></td>
<td class="grid"><code>FDIVP ST(i), ST(0)</code></td>
<td class="grid">Divide ST(i) by ST(0), store result in ST(i), and pop the register stack.</td>
</tr>
<tr>
<td class="grid"><code>DE F9</code></td>
<td class="grid"><code>FDIVP</code></td>
<td class="grid">Divide ST(1) by ST(0), store result in ST(1), and pop the register stack.</td>
</tr>
<tr>
<td class="grid"><code>DA /6</code></td>
<td class="grid"><code>FIDIV m32int</code></td>
<td class="grid">Divide ST(0) by m32int and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>DE /6</code></td>
<td class="grid"><code>FIDIV m16int</code></td>
<td class="grid">Divide ST(0) by m64int and store result in ST(0).</td>
</tr>
</table></td><td>
<p>Divides the destination operand by the source operand and stores the result in the destination location. The destination operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory location. Source operands in memory can be in singleprecision or double-precision floating-point format, word or doubleword integer format.</p>
<p>The no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0) register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location (either a floating-point or an integer value). The twooperand version, divides the contents of the ST(0) register by the contents of the ST(i) register or vice versa.</p>
<p>The FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIV rather than FDIVP.</p>
<p>The FIDIV instructions convert an integer source operand to double extended-precision floating-point format before performing the division. When the source operand is an integer 0, it is treated as a +0.</p>
<p>If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an infinite of the appropriate sign is stored in the destination operand.</p>
<p>The following table shows the results obtained when dividing various classes of numbers, assuming that neither overflow nor underflow occurs.</p>
<div>
<table class="grid">
<caption>FDIV/FDIVP/FIDIV Results</caption>
<tr><td>-</td><td>Destination: -inf</td><td>Destination: -F</td><td>Destination: -0</td><td>Destination: +0</td><td>Destination: +F</td><td>Destination: +inf</td><td>Destination: NaN</td></tr>
<tr><td>Source: -inf</td><td>*</td><td>+0</td><td>+0</td><td>-0</td><td>-0</td><td>*</td><td>NaN</td></tr>
<tr><td>Source: -F</td><td>+inf</td><td>+F</td><td>+0</td><td>-0</td><td>-F</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Source: -I</td><td>+inf</td><td>+F</td><td>+0</td><td>-0</td><td>-F</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Source: -0</td><td>+inf</td><td>**</td><td>*</td><td>*</td><td>**</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Source: +0</td><td>-inf</td><td>**</td><td>*</td><td>*</td><td>**</td><td>+inf</td><td>NaN</td></tr>
<tr><td>Source: +I</td><td>-inf</td><td>-F</td><td>-0</td><td>+0</td><td>+F</td><td>+inf</td><td>NaN</td></tr>
<tr><td>Source: +F</td><td>-inf</td><td>-F</td><td>-0</td><td>+0</td><td>+F</td><td>+inf</td><td>NaN</td></tr>
<tr><td>Source: +8</td><td>*</td><td>-0</td><td>-0</td><td>+0</td><td>+0</td><td>*</td><td>NaN</td></tr>
<tr><td>Source: NaN NaN NaN NaN NaN NaN NaN NaN</td></tr>
<tfoot>
<tr><td colspan="1">F Means finite floating-point value.</td></tr>
<tr><td colspan="1">I Means integer.</td></tr>
<tr><td colspan="1">* Indicates floating-point invalid-arithmetic-operand (#IA) exception.</td></tr>
<tr><td colspan="1">** Indicates floating-point zero-divide (#Z) exception.</td></tr>
</tfoot>
</table>
</div>
<br />Source: -inf</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>Source <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>Z<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">else</span> {
	<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FIDIV<span class="operator">)</span> Destination <span class="operator">=</span> ConvertToExtendedDouble<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">else</span> Destination <span class="operator">=</span> Destination / Source<span class="operator">;</span>
}
<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FDIVP<span class="operator">)</span> PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FDIVR/FDIVRP/FIDIVR</strong><br />Reverse Divide<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D8 /7</code></td>
<td class="grid"><code>FDIVR m32fp</code></td>
<td class="grid">Divide m32fp by ST(0) and store result in ST(0)</td>
</tr>
<tr>
<td class="grid"><code>DC /7</code></td>
<td class="grid"><code>FDIVR m64fp</code></td>
<td class="grid">Divide m64fp by ST(0) and store result in ST(0)</td>
</tr>
<tr>
<td class="grid"><code>D8 F8+i</code></td>
<td class="grid"><code>FDIVR ST(0), ST(i)</code></td>
<td class="grid">Divide ST(i) by ST(0) and store result in ST(0)</td>
</tr>
<tr>
<td class="grid"><code>DC F0+i</code></td>
<td class="grid"><code>FDIVR ST(i), ST(0)</code></td>
<td class="grid">Divide ST(0) by ST(i) and store result in ST(i)</td>
</tr>
<tr>
<td class="grid"><code>DE F0+i</code></td>
<td class="grid"><code>FDIVRP ST(i), ST(0)</code></td>
<td class="grid">Divide ST(0) by ST(i), store result in ST(i), and pop the register stack</td>
</tr>
<tr>
<td class="grid"><code>DE F1</code></td>
<td class="grid"><code>FDIVRP</code></td>
<td class="grid">Divide ST(0) by ST(1), store result in ST(1), and pop the register stack</td>
</tr>
<tr>
<td class="grid"><code>DA /7</code></td>
<td class="grid"><code>FIDIVR m32int</code></td>
<td class="grid">Divide m32int by ST(0) and store result in ST(0)</td>
</tr>
<tr>
<td class="grid"><code>DE /7</code></td>
<td class="grid"><code>FIDIVR m16int</code></td>
<td class="grid">Divide m16int by ST(0) and store result in ST(0)</td>
</tr>
</table></td><td>
<p>Divides the source operand by the destination operand and stores the result in the destination location. The destination operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory location. Source operands in memory can be in singleprecision or double-precision floating-point format, word or doubleword integer format.</p>
<p>These instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions.</p>
<p>They are provided to support more efficient coding.</p>
<p>The no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1) register. The one-operand version divides the contents of a memory location (either a floating-point or an integer value) by the contents of the ST(0) register. The twooperand version, divides the contents of the ST(i) register by the contents of the ST(0) register or vice versa.</p>
<p>The FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIVR rather than FDIVRP.</p>
<p>The FIDIVR instructions convert an integer source operand to double extended-precision floating-point format before performing the division.</p>
<p>If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an infinite of the appropriate sign is stored in the destination operand.</p>
<p>The following table shows the results obtained when dividing various classes of numbers, assuming that neither overflow nor underflow occurs.</p>
<div>
<table class="grid">
<caption>FDIVR/FDIVRP/FIDIVR	Results</caption>
<tr><td>-</td><td>Destination: -inf</td><td>Destination: -F</td><td>Destination: -0</td><td>Destination: +0</td><td>Destination: +F</td><td>Destination: +inf</td><td>Destination: NaN</td></tr>
<tr><td>Source: -inf</td><td>*</td><td>+inf</td><td>+inf</td><td>-inf</td><td>-inf</td><td>*</td><td>NaN</td></tr>
<tr><td>Source: -F</td><td>+0</td><td>+F</td><td>**</td><td>**</td><td>-F</td><td>-0</td><td>NaN</td></tr>
<tr><td>Source: -I</td><td>+0</td><td>+F</td><td>**</td><td>**</td><td>-F</td><td>-0</td><td>NaN</td></tr>
<tr><td>Source: -0</td><td>+0</td><td>+0</td><td>*</td><td>*</td><td>-0</td><td>-0</td><td>NaN</td></tr>
<tr><td>Source: +0</td><td>-0</td><td>-0</td><td>*</td><td>*</td><td>+0</td><td>+0</td><td>NaN</td></tr>
<tr><td>Source: +I</td><td>-0</td><td>-F</td><td>**</td><td>**</td><td>+F</td><td>+0</td><td>NaN</td></tr>
<tr><td>Source: +F</td><td>-0</td><td>-F</td><td>**</td><td>**</td><td>+F</td><td>+0</td><td>NaN</td></tr>
<tr><td>Source: +inf</td><td>*</td><td>-inf</td><td>-inf</td><td>+inf</td><td>+inf</td><td>*</td><td>NaN</td></tr>
<tr><td>Source: NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="8">F Means finite floating-point value.</td></tr>
<tr><td colspan="8">I Means integer.</td></tr>
<tr><td colspan="8">* Indicates floating-point invalid-arithmetic-operand (#IA) exception.</td></tr>
<tr><td colspan="8">** Indicates floating-point zero-divide (#Z) exception.</td></tr>
</tfoot>
</table>
</div>
[/table]<p>When the source operand is an integer 0, it is treated as a +0.</p>
<br />Source: -inf</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>Destination <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>Z<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">else</span> {
	<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FIDIVR<span class="operator">)</span> Destination <span class="operator">=</span> ConvertToExtendedDouble<span class="operator">(</span>Source<span class="operator">)</span> / Destination<span class="operator">;</span>
	<span class="keyword">else</span> Destination <span class="operator">=</span> Source / Destination<span class="operator">;</span> <span class="comment">//source operand is floating-point value</span>
}
<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FDIVRP<span class="operator">)</span> PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FFREE</strong><br />Free Floating-Point Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>DD C0+i</code></td>
<td class="grid"><code>FFREE</code></td>
<td class="grid">ST(i) Sets tag for ST(i) to empty.</td>
</tr>
</table></td><td>
<p>Sets the tag in the FPU tag register associated with register ST(i) to empty (11B). The contents of ST(i) and the FPU stack-top pointer (TOP) are not affected.</p>
<br />
<pre>Tag<span class="operator">(</span>i<span class="operator">)</span> <span class="operator">=</span> <span class="number">3</span><span class="operator">;</span> <span class="comment">//11B</span>
</pre>
</td><td>
<p>C0, C1, C2, C3 undefined.
</p>
</td></tr><tr><td><strong>FICOM/FICOMP</strong><br />Compare Integer<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>DE /2</code></td>
<td class="grid"><code>FICOM m16int</code></td>
<td class="grid">Compare ST(0) with m16int.</td>
</tr>
<tr>
<td class="grid"><code>DA /2</code></td>
<td class="grid"><code>FICOM m32int</code></td>
<td class="grid">Compare ST(0) with m32int.</td>
</tr>
<tr>
<td class="grid"><code>DE /3</code></td>
<td class="grid"><code>FICOMP m16int</code></td>
<td class="grid">Compare ST(0) with m16int and pop stack register.</td>
</tr>
<tr>
<td class="grid"><code>DA /3</code></td>
<td class="grid"><code>FICOMP m32int</code></td>
<td class="grid">Compare ST(0) with m32int and pop stack register.</td>
</tr>
</table></td><td>
<p>Compares the value in ST(0) with an integer source operand and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results (see table below). The integer value is converted to double extended-precision floating-point format before the comparison is made.</p>
<div>
<table class="grid">
<caption>FICOM/FICOMP Results</caption>
<tr><th>Condition</th><th>C3</th><th>C2</th><th>C0</th></tr>
<tr><td>ST(0) &gt; Source</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>ST(0) &lt; Source</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>ST(0) = Source</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>Unordered</td><td>1</td><td>1</td><td>1</td></tr>
</table>
</div>
<p>These instructions perform an &quot;unordered comparison.&quot; An unordered comparison also checks the class of the numbers being compared (see &quot;FXAM-Examine&quot; in this chapter). If either operand is a NaN or is in an undefined format, the condition flags are set to &quot;unordered.&quot; The sign of zero is ignored, so that -0.0 = +0.0.</p>
<p>The FICOMP instructions pop the register stack following the comparison. To pop the register stack, the processor marks the ST(0) register empty and increments the stack pointer (TOP) by 1.</p>
<br />ST(0) &gt; Source</td><td>
<pre>OperandRelation <span class="operator">=</span> Compare<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">,</span> Source<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">switch</span><span class="operator">(</span>OperandRelation<span class="operator">)</span> {
	RelationGreaterThan<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	RelationLessThan<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	RelationEqual<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	RelationUnordered<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}

<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FICOMP<span class="operator">)</span> PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FILD</strong><br />Load Integer<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>DF /0</code></td>
<td class="grid"><code>FILD m16int</code></td>
<td class="grid">Push m16int onto the FPU register stack.</td>
</tr>
<tr>
<td class="grid"><code>DB /0</code></td>
<td class="grid"><code>FILD m32int</code></td>
<td class="grid">Push m32int onto the FPU register stack.</td>
</tr>
<tr>
<td class="grid"><code>DF /5</code></td>
<td class="grid"><code>FILD m64int</code></td>
<td class="grid">Push m64int onto the FPU register stack.</td>
</tr>
</table></td><td>
<p>Converts the signed-integer source operand into double extended-precision floating-point format and pushes the value onto the FPU register stack. The source operand can be a word, doubleword, or quadword integer. It is loaded without rounding errors. The sign of the source operand is preserved.</p>
<br />
<pre>Top <span class="operator">=</span> Top <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> ConvertToExtendedDouble<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>C1 Set to 1 if stack overflow occurred; set to 0 otherwise.
C0, C2, C3 Undefined.
</p>
</td></tr><tr><td><strong>FINCSTP</strong><br />Increment Stack-Top Pointer<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 F7</code></td>
<td class="grid"><code>FINCSTP</code></td>
<td class="grid">Increment the TOP field in the FPU status register.</td>
</tr>
</table></td><td>
<p>Adds one to the TOP field of the FPU status word (increments the top-of-stack pointer). If the TOP field contains a 7, it is set to 0. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected. This operation is not equivalent to popping the stack, because the tag for the previous top-of-stack register is not marked empty.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Top <span class="operator">==</span> <span class="number">7</span><span class="operator">)</span> Top <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
<span class="keyword">else</span> Top <span class="operator">=</span> Top <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
</pre>
</td><td>
<p>The C1 flag is set to 0. The C0, C2, and C3 flags are undefined.
</p>
</td></tr><tr><td><strong>FINIT/FNINIT</strong><br />Initialize Floating-Point Unit<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>9B DB E3</code></td>
<td class="grid"><code>FINIT</code></td>
<td class="grid">Initialize FPU after checking for pending unmasked floating-point exceptions.</td>
</tr>
<tr>
<td class="grid"><code>DB E3</code></td>
<td class="grid"><code>FNINIT</code></td>
<td class="grid">Initialize FPU without checking for pending unmasked floating-point exceptions. See the IA-32 Architecture Compatibility section below.</td>
</tr>
</table></td><td>
<p>Sets the FPU control, status, tag, instruction pointer, and data pointer registers to their default states. The FPU control word is set to 037FH (round to nearest, all exceptions masked, 64-bit precision). The status word is cleared (no exception flags set, TOP is set to 0). The data registers in the register stack are left unchanged, but they are all tagged as empty (11B). Both the instruction and data pointers are cleared.</p>
<p>The FINIT instruction checks for and handles any pending unmasked floating-point exceptions before performing the initialization; the FNINIT instruction does not.</p>
<p>The assembler issues two instructions for the FINIT instruction (an FWAIT instruction followed by an FNINIT instruction), and the processor executes each of these instructions in separately.</p>
<p>If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.</p>
<br />
<pre>FPUControlWord <span class="operator">=</span> <span class="number">0x37F</span><span class="operator">;</span>
FPUStatusWord <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
FPUTagWord <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
FPUDataPointer <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
FPUInstructionPointer <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
FPULastInstructionOpcode <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
<p>C0, C1, C2, C3 set to 0.
</p>
</td></tr><tr><td><strong>FIST/FISTP</strong><br />Store Integer<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>DF /2</code></td>
<td class="grid"><code>FIST m16int</code></td>
<td class="grid">Store ST(0) in m16int.</td>
</tr>
<tr>
<td class="grid"><code>DB /2</code></td>
<td class="grid"><code>FIST m32int</code></td>
<td class="grid">Store ST(0) in m32int.</td>
</tr>
<tr>
<td class="grid"><code>DF /3</code></td>
<td class="grid"><code>FISTP m16int</code></td>
<td class="grid">Store ST(0) in m16int and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>DB /3</code></td>
<td class="grid"><code>FISTP m32int</code></td>
<td class="grid">Store ST(0) in m32int and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>DF /7</code></td>
<td class="grid"><code>FISTP m64int</code></td>
<td class="grid">Store ST(0) in m64int and pop register stack.</td>
</tr>
</table></td><td>
<p>The FIST instruction converts the value in the ST(0) register to a signed integer and stores the result in the destination operand. Values can be stored in word or doubleword integer format.</p>
<p>The destination operand specifies the address where the first byte of the destination value is to be stored.</p>
<p>The FISTP instruction performs the same operation as the FIST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FISTP instruction also stores values in quadword integer format.</p>
<p>The following table shows the results obtained when storing various classes of numbers in integer format.</p>
<div>
<table class="grid">
<caption>FIST/FISTP Results</caption>
<tr><th>ST(0)</th><th>Destination</th></tr>
<tr><td>-inf or Value Too Large for Destination Format</td><td>*</td></tr>
<tr><td>F = -1</td><td>-I</td></tr>
<tr><td>-1 &lt; F &lt; -0</td><td>**</td></tr>
<tr><td>-0</td><td>0</td></tr>
<tr><td>+0</td><td>0</td></tr>
<tr><td>+0 &lt; F &lt; +1</td><td>**</td></tr>
<tr><td>F = +1</td><td>+I</td></tr>
<tr><td>+inf or Value Too Large for Destination Format</td><td>*</td></tr>
<tr><td>NaN</td><td>*</td></tr>
<tfoot>
<tr><td colspan="2">F Means finite floating-point value.</td></tr>
<tr><td colspan="2">I Means integer.</td></tr>
<tr><td colspan="2">* Indicates floating-point invalid-operation (#IA) exception.</td></tr>
<tr><td colspan="2">** 0 or +-1, depending on the rounding mode.</td></tr>
</tfoot>
</table>
</div>
<p>If the source value is a non-integral value, it is rounded to an integer value, according to the rounding mode specified by the RC field of the FPU control word.</p>
<p>If the converted value is too large for the destination format, or if the source operand is an infinite, SNaN, QNAN, or is in an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination operand. If the invalid-operation exception is masked, the integer indefinite value is stored in memory.</p>
<br />-inf or Value Too Large for Destination Format</td><td>
<pre>Destination <span class="operator">=</span> Integer<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FISTP<span class="operator">)</span> PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FISTTP</strong><br />Store Integer with Truncation<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>DF /1</code></td>
<td class="grid"><code>FISTTP m16int</code></td>
<td class="grid">Store ST as a signed integer (truncate) in m16int and pop ST.</td>
</tr>
<tr>
<td class="grid"><code>DB /1</code></td>
<td class="grid"><code>FISTTP m32int</code></td>
<td class="grid">Store ST as a signed integer (truncate) in m32int and pop ST.</td>
</tr>
<tr>
<td class="grid"><code>DD /1</code></td>
<td class="grid"><code>FISTTP m64int</code></td>
<td class="grid">Store ST as a signed integer (truncate) in m64int and pop ST.</td>
</tr>
</table></td><td>
<p>FISTTP converts the value in ST into a signed integer using truncation (chop) as rounding mode, transfers the result to the destination, and pop ST. FISTTP accepts word, short integer, and long integer destinations.</p>
<p>The following table shows the results obtained when storing various classes of numbers in integer format.</p>
<div>
<table class="grid">
<caption>FISTTP Results</caption>
<tr><th>ST(0)</th><th>Destination</th></tr>
<tr><td>-inf or Value Too Large for Destination</td><td>Format *</td></tr>
<tr><td>F = -1</td><td>-I</td></tr>
<tr><td>- 1 &lt; F &lt; +1</td><td>0</td></tr>
<tr><td>F = +1</td><td>+I</td></tr>
<tr><td>+inf or Value Too Large for Destination Format</td><td>*</td></tr>
<tr><td>NaN</td><td>*</td></tr>
<tfoot>
<tr><td colspan="2">F Means finite floating-point value.</td></tr>
<tr><td colspan="2">I Means integer.</td></tr>
<tr><td colspan="2">* Indicates floating-point invalid-operation (#IA) exception.</td></tr>
</tfoot>
</table>
</div>
<br />-inf or Value Too Large for Destination</td><td>
<pre>Destination <span class="operator">=</span> ST<span class="operator">;</span>
ST <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FLD</strong><br />Load Floating Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 /0</code></td>
<td class="grid"><code>FLD m32fp</code></td>
<td class="grid">Push m32fp onto the FPU register stack.</td>
</tr>
<tr>
<td class="grid"><code>DD /0</code></td>
<td class="grid"><code>FLD m64fp</code></td>
<td class="grid">Push m64fp onto the FPU register stack.</td>
</tr>
<tr>
<td class="grid"><code>DB /5</code></td>
<td class="grid"><code>FLD m80fp</code></td>
<td class="grid">Push m80fp onto the FPU register stack.</td>
</tr>
<tr>
<td class="grid"><code>D9 C0+i</code></td>
<td class="grid"><code>FLD ST(i)</code></td>
<td class="grid">Push ST(i) onto the FPU register stack.</td>
</tr>
</table></td><td>
<p>Pushes the source operand onto the FPU register stack. The source operand can be in singleprecision, double-precision, or double extended-precision floating-point format. If the source operand is in single-precision or double-precision floating-point format, it is automatically converted to the double extended-precision floating-point format before being pushed on the stack.</p>
<p>The FLD instruction can also push the value in a selected FPU register [ST(i)] onto the stack.</p>
<p>Here, pushing register ST(0) duplicates the stack top.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Source <span class="operator">==</span> ST<span class="operator">(</span>i<span class="operator">)</span><span class="operator">)</span> Temporary <span class="operator">=</span> ST<span class="operator">(</span>i<span class="operator">)</span><span class="operator">;</span>
Top <span class="operator">=</span> Top <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>IsMemoryOperand<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">)</span> ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> ConvertToExtendedDouble<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">else</span> ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> Temporary<span class="operator">;</span>
</pre>
</td><td>
<p>C1 Set to 1 if stack overflow occurred; otherwise, set to 0.
C0, C2, C3 Undefined.
</p>
</td></tr><tr><td><strong>FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ</strong><br />Load Constant<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 E8</code></td>
<td class="grid"><code>FLD1</code></td>
<td class="grid">Push +1.0 onto the FPU register stack.</td>
</tr>
<tr>
<td class="grid"><code>D9 E9</code></td>
<td class="grid"><code>FLDL2T</code></td>
<td class="grid">Push log_2(10) onto the FPU register stack.</td>
</tr>
<tr>
<td class="grid"><code>D9 EA</code></td>
<td class="grid"><code>FLDL2E</code></td>
<td class="grid">Push log_2(e) onto the FPU register stack.</td>
</tr>
<tr>
<td class="grid"><code>D9 EB</code></td>
<td class="grid"><code>FLDPI</code></td>
<td class="grid">Push pi onto the FPU register stack.</td>
</tr>
<tr>
<td class="grid"><code>D9 EC</code></td>
<td class="grid"><code>FLDLG2</code></td>
<td class="grid">Push log_10(2) onto the FPU register stack.</td>
</tr>
<tr>
<td class="grid"><code>D9 ED</code></td>
<td class="grid"><code>FLDLN2</code></td>
<td class="grid">Push log_e(2) onto the FPU register stack.</td>
</tr>
<tr>
<td class="grid"><code>D9 EE</code></td>
<td class="grid"><code>FLDZ</code></td>
<td class="grid">Push +0.0 onto the FPU register stack.</td>
</tr>
</table></td><td>
<p>Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log_10(2), log_e(2), pi, log_2(10), and log_2(e). For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extendedprecision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.</p>
<p>See the section titled &quot;Pi&quot; in Chapter 8 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for a description of the pi constant.</p>
<br />
<pre>Top <span class="operator">=</span> Top <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> Constant<span class="operator">;</span>
</pre>
</td><td>
<p>C1 Set to 1 if stack overflow occurred; otherwise, set to 0.
C0, C2, C3 Undefined.
</p>
</td></tr><tr><td><strong>FLDCW</strong><br />Load x87 FPU Control Word<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 /5</code></td>
<td class="grid"><code>FLDCW m2byte</code></td>
<td class="grid">Load FPU control word from m2byte.</td>
</tr>
</table></td><td>
<p>Loads the 16-bit source operand into the FPU control word. The source operand is a memory location. This instruction is typically used to establish or change the FPU's mode of operation.</p>
<p>If one or more exception flags are set in the FPU status word prior to loading a new FPU control word and the new control word unmasks one or more of those exceptions, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled &quot;Software Exception Handling&quot; in Chapter 8 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1). To avoid raising exceptions when changing FPU operating modes, clear any pending exceptions (using the FCLEX or FNCLEX instruction) before loading the new control word.</p>
<br />
<pre>FPUControlWord <span class="operator">=</span> Source<span class="operator">;</span>
</pre>
</td><td>
<p>C0, C1, C2, C3 undefined.
</p>
</td></tr><tr><td><strong>FLDENV</strong><br />Load x87 FPU Environment<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 /4</code></td>
<td class="grid"><code>FLDENV m14/28byte</code></td>
<td class="grid">Load FPU environment from m14byte or m28byte.</td>
</tr>
</table></td><td>
<p>Loads the complete x87 FPU operating environment from memory into the FPU registers. The source operand specifies the first byte of the operating-environment data in memory. This data is typically written to the specified memory location by a FSTENV or FNSTENV instruction.</p>
<p>The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, show the layout in memory of the loaded environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.</p>
<p>The FLDENV instruction should be executed in the same operating mode as the corresponding FSTENV/FNSTENV instruction.</p>
<p>If one or more unmasked exception flags are set in the new FPU status word, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled &quot;Software Exception Handling&quot; in Chapter 8 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1). To avoid generating exceptions when loading a new environment, clear all the exception flags in the FPU status word that is being loaded.</p>
<p>If a page or limit fault occurs during the execution of this instruction, the state of the x87 FPU registers as seen by the fault handler may be different than the state being loaded from memory.</p>
<p>In such situations, the fault handler should ignore the status of the x87 FPU registers, handle the fault, and return. The FLDENV instruction will then complete the loading of the x87 FPU registers with no resulting context inconsistency.</p>
<br />
<pre>FPUControlWord <span class="operator">=</span> Source<span class="operator">.</span>FPUControlWord<span class="operator">;</span>
FPUStatusWord <span class="operator">=</span> Source<span class="operator">.</span>FPUStatusWord<span class="operator">;</span>
FPUTagWord <span class="operator">=</span> Source<span class="operator">.</span>FPUTagWord<span class="operator">;</span>
FPUDataPointer <span class="operator">=</span> Source<span class="operator">.</span>FPUDataPointer<span class="operator">;</span>
FPUInstructionPointer <span class="operator">=</span> Source<span class="operator">.</span>FPUInstructionPointer<span class="operator">;</span>
FPULastInstructionOpcode <span class="operator">=</span> Source<span class="operator">.</span>FPULastInstructionOpcode<span class="operator">;</span>
</pre>
</td><td>
<p>The C0, C1, C2, C3 flags are loaded.
</p>
</td></tr><tr><td><strong>FMUL/FMULP/FIMUL</strong><br />Multiply<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D8 /1</code></td>
<td class="grid"><code>FMUL m32fp</code></td>
<td class="grid">Multiply ST(0) by m32fp and store result in ST(0)</td>
</tr>
<tr>
<td class="grid"><code>DC /1</code></td>
<td class="grid"><code>FMUL m64fp</code></td>
<td class="grid">Multiply ST(0) by m64fp and store result in ST(0)</td>
</tr>
<tr>
<td class="grid"><code>D8 C8+i</code></td>
<td class="grid"><code>FMUL ST(0), ST(i)</code></td>
<td class="grid">Multiply ST(0) by ST(i) and store result in ST(0)</td>
</tr>
<tr>
<td class="grid"><code>DC C8+i</code></td>
<td class="grid"><code>FMUL ST(i), ST(0)</code></td>
<td class="grid">Multiply ST(i) by ST(0) and store result in ST(i)</td>
</tr>
<tr>
<td class="grid"><code>DE C8+i</code></td>
<td class="grid"><code>FMULP ST(i), ST(0)</code></td>
<td class="grid">Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack</td>
</tr>
<tr>
<td class="grid"><code>DE C9</code></td>
<td class="grid"><code>FMULP</code></td>
<td class="grid">Multiply ST(1) by ST(0), store result in ST(1), and pop the register stack</td>
</tr>
<tr>
<td class="grid"><code>DA /1</code></td>
<td class="grid"><code>FIMUL m32int</code></td>
<td class="grid">Multiply ST(0) by m32int and store result in ST(0)</td>
</tr>
<tr>
<td class="grid"><code>DE /1</code></td>
<td class="grid"><code>FIMUL m16int</code></td>
<td class="grid">Multiply ST(0) by m16int and store result in ST(0)</td>
</tr>
</table></td><td>
<p>Multiplies the destination and source operands and stores the product in the destination location.</p>
<p>The destination operand is always an FPU data register; the source operand can be an FPU data register or a memory location. Source operands in memory can be in single-precision or doubleprecision floating-point format or in word or doubleword integer format.</p>
<p>The no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0) register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0) register by the contents of a memory location (either a floating point or an integer value) and stores the product in the ST(0) register. The two-operand version, multiplies the contents of the ST(0) register by the contents of the ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the destination operand).</p>
<p>The FMULP instructions perform the additional operation of popping the FPU register stack after storing the product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FMUL rather than FMULP.</p>
<p>The FIMUL instructions convert an integer source operand to double extended-precision floating-point format before performing the multiplication.</p>
<p>The sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multiplied is 0 or infinite. When the source operand is an integer 0, it is treated as a +0.</p>
<p>The following table shows the results obtained when multiplying various classes of numbers, assuming that neither overflow nor underflow occurs.</p>
<div>
<table class="grid">
<caption>FMUL/FMULP/FIMUL Results</caption>
<tr><td>-</td><td>Destination: -inf</td><td>Destination: -F</td><td>Destination: -0</td><td>Destination: +0</td><td>Destination: +F</td><td>Destination: +inf</td><td>Destination: NaN</td></tr>
<tr><td>Source: -inf</td><td>+inf</td><td>+inf</td><td>*</td><td>*</td><td>-inf</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Source: -F</td><td>+inf</td><td>+F</td><td>+0</td><td>-0</td><td>-F</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Source: -I</td><td>+inf</td><td>+F</td><td>+0</td><td>-0</td><td>-F</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Source: -0</td><td>*</td><td>+0</td><td>+0</td><td>-0</td><td>-0</td><td>*</td><td>NaN</td></tr>
<tr><td>Source: +0</td><td>*</td><td>-0</td><td>-0</td><td>+0</td><td>+0</td><td>*</td><td>NaN</td></tr>
<tr><td>Source: +I</td><td>-inf</td><td>-F</td><td>-0</td><td>+0</td><td>+F</td><td>+inf</td><td>NaN</td></tr>
<tr><td>Source: +F</td><td>-inf</td><td>-F</td><td>-0</td><td>+0</td><td>+F</td><td>+inf</td><td>NaN</td></tr>
<tr><td>Source: +inf</td><td>-inf</td><td>-inf</td><td>*</td><td>*</td><td>+inf</td><td>+inf</td><td>NaN</td></tr>
<tr><td>Source: NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="8">F Means finite floating-point value.</td></tr>
<tr><td colspan="8">I Means Integer.</td></tr>
<tr><td colspan="8">* Indicates invalid-arithmetic-operand (#IA) exception.</td></tr>
</tfoot>
</table>
</div>
<br />Source: -inf</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FIMUL<span class="operator">)</span> Destination <span class="operator">=</span> Destination <span class="operator">*</span> ConvertToExtendedDouble<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">else</span> Destination <span class="operator">=</span> Destination <span class="operator">*</span> Source<span class="operator">;</span> <span class="comment">//source operand is floating-point value</span>

<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FMULP<span class="operator">)</span> PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FNOP</strong><br />No operation<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 D0</code></td>
<td class="grid"><code>FNOP</code></td>
<td class="grid">No operation is performed.</td>
</tr>
</table></td><td>
<p>Performs no FPU operation. This instruction takes up space in the instruction stream but does not affect the FPU or machine context, except the EIP register.</p>
<br />
None.
</td><td>
<div>
<table class="operations_table">
<tr><td><code>#NM</code></td><td>EM or TS in CR0 is set.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>FPATAN</strong><br />Partial Arctangent<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 F3</code></td>
<td class="grid"><code>FPATAN</code></td>
<td class="grid">Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack.</td>
</tr>
</table></td><td>
<p>Computes the arctangent of the source operand in register ST(1) divided by the source operand in register ST(0), stores the result in ST(1), and pops the FPU register stack. The result in register ST(0) has the same sign as the source operand ST(1) and a magnitude less than +infinite.</p>
<p>The FPATAN instruction returns the angle between the X axis and the line from the origin to the point (X,Y), where Y (the ordinate) is ST(1) and X (the abscissa) is ST(0). The angle depends on the sign of X and Y independently, not just on the sign of the ratio Y/X. This is because a point (-X,Y) is in the second quadrant, resulting in an angle between pi/2 and pi, while a point (X,-Y) is in the fourth quadrant, resulting in an angle between 0 and -pi/2. A point (- X,-Y) is in the third quadrant, giving an angle between -pi/2 and -pi.</p>
<p>The following table shows the results obtained when computing the arctangent of various classes of numbers, assuming that underflow does not occur.</p>
<div>
<table class="grid">
<caption>FPATAN Results</caption>
<tr><td>-</td><td>ST(0): -inf</td><td>ST(0): -F</td><td>ST(0): -0</td><td>ST(0): +0</td><td>ST(0): +F</td><td>ST(0): +inf</td><td>ST(0): NaN</td></tr>
<tr><td>ST(1): -inf</td><td>-3p/4*</td><td>-p/2</td><td>-p/2</td><td>-p/2</td><td>-p/2</td><td>-p/4*</td><td>NaN</td></tr>
<tr><td>ST(1): -F</td><td>-p</td><td>-p</td><td>to</td><td>-p/2</td><td>-p/2</td><td>-p/2</td><td>-p/2</td><td>to</td><td>-0</td><td>-0</td><td>NaN</td></tr>
<tr><td>ST(1): -0</td><td>-p</td><td>-p</td><td>-p*</td><td>-0*</td><td>-0</td><td>-0</td><td>NaN</td></tr>
<tr><td>ST(1): +0</td><td>+p</td><td>+p</td><td>+p*</td><td>+0*</td><td>+0</td><td>+0</td><td>NaN</td></tr>
<tr><td>ST(1): +F</td><td>+p</td><td>+p</td><td>to</td><td>+p/2</td><td>+p/2</td><td>+p/2</td><td>+p/2</td><td>to</td><td>+0</td><td>+0</td><td>NaN</td></tr>
<tr><td>ST(1): +inf</td><td>+3p/4*</td><td>+p/2</td><td>+p/2</td><td>+p/2</td><td>+p/2</td><td>+p/4*</td><td>NaN</td></tr>
<tr><td>ST(1): NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="8">F Means finite floating-point value.</td></tr>
<tr><td colspan="8">* Table 8-10 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, specifies that the ratios 0/0 and infinite/infinite generate the floating-point invalid arithmetic-operation exception and, if this exception is masked, the floating-point QNaN indefinite value is returned. With the FPATAN instruction, the 0/0 or infinite/infinite value is actually not calculated using division. Instead, the arctangent of the two variables is derived from a standard mathematical formulation that is generalized to allow complex numbers as arguments. In this complex variable formulation, arctangent(0,0) etc. has well defined values. These values are needed to develop a library to compute transcendental functions with complex arguments, based on the FPU functions that only allow floating-point values as arguments.</td></tr>
</tfoot>
</table>
</div>
<p>There is no restriction on the range of source operands that FPATAN can accept.</p>
<br />ST(1): -inf</td><td>
<pre>ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">=</span> ArcTangent<span class="operator">(</span>ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span> / ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FPREM</strong><br />Partial Remainder<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 F8</code></td>
<td class="grid"><code>FPREM</code></td>
<td class="grid">Replace ST(0) with the remainder obtained from dividing ST(0) by ST(1).</td>
</tr>
</table></td><td>
<p>Computes the remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following value: Remainder = ST(0) - (Q * ST(1)) Here, Q is an integer value that is obtained by truncating the floating-point number quotient of [ST(0) / ST(1)] toward zero. The sign of the remainder is the same as the sign of the dividend. The magnitude of the remainder is less than that of the modulus, unless a partial remainder was computed (as described below).</p>
<p>This instruction produces an exact result; the inexact-result exception does not occur and the rounding control has no effect. The following table shows the results obtained when computing the remainder of various classes of numbers, assuming that underflow does not occur.</p>
<div>
<table class="grid">
<caption>FPREM Results</caption>
<tr><td>-</td><td>ST(0): -inf</td><td>ST(0): -F</td><td>ST(0): -0</td><td>ST(0): +0</td><td>ST(0): +F</td><td>ST(0): +inf</td><td>ST(0): NaN</td></tr>
<tr><td>ST(1): -inf</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td><td>NaN</td></tr>
<tr><td>ST(1): -F</td><td>ST(0)</td><td>-F</td><td>or</td><td>-0</td><td>**</td><td>**</td><td>-F</td><td>or</td><td>-0</td><td>ST(0)</td><td>NaN</td></tr>
<tr><td>ST(1): -0</td><td>-0</td><td>-0</td><td>*</td><td>*</td><td>-0</td><td>-0</td><td>NaN</td></tr>
<tr><td>ST(1): +0</td><td>+0</td><td>+0</td><td>*</td><td>*</td><td>+0</td><td>+0</td><td>NaN</td></tr>
<tr><td>ST(1): +F</td><td>ST(0)</td><td>+F</td><td>or</td><td>+0</td><td>**</td><td>**</td><td>+F</td><td>or</td><td>+0</td><td>ST(0)</td><td>NaN</td></tr>
<tr><td>ST(1): +inf</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td><td>NaN</td></tr>
<tr><td>ST(1): NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="8">F Means finite floating-point value.</td></tr>
<tr><td colspan="8">* Indicates floating-point invalid-arithmetic-operand (#IA) exception.</td></tr>
<tr><td colspan="8">** Indicates floating-point zero-divide (#Z) exception.</td></tr>
</tfoot>
</table>
</div>
<p>When the result is 0, its sign is the same as that of the dividend. When the modulus is infinite, the result is equal to the value in ST(0).</p>
<p>The FPREM instruction does not compute the remainder specified in IEEE Std 754. The IEEE specified remainder can be computed with the FPREM1 instruction. The FPREM instruction is provided for compatibility with the Intel 8087 and Intel287 math coprocessors.</p>
<p>The FPREM instruction gets its name &quot;partial remainder&quot; because of the way it computes the remainder. This instructions arrives at a remainder through iterative subtraction. It can, however, reduce the exponent of ST(0) by no more than 63 in one execution of the instruction.</p>
<p>If the instruction succeeds in producing a remainder that is less than the modulus, the operation is complete and the C2 flag in the FPU status word is cleared. Otherwise, C2 is set, and the result in ST(0) is called the partial remainder. The exponent of the partial remainder will be less than the exponent of the original dividend by at least 32. Software can re-execute the instruction (using the partial remainder in ST(0) as the dividend) until C2 is cleared. (Note that while executing such a remainder-computation loop, a higher-priority interrupting routine that needs the FPU can force a context switch in-between the instructions in the loop.) An important use of the FPREM instruction is to reduce the arguments of periodic functions.</p>
<p>When reduction is complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU status word. This information is important in argument reduction for the tangent function (using a modulus of pi/4), because it locates the original angle in the correct one of eight sectors of the unit circle.</p>
<br />ST(1): -inf</td><td>
<pre>D <span class="operator">=</span> GetExponent<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span> <span class="operator">-</span> GetExponent<span class="operator">(</span>ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>D <span class="operator">&lt;</span> <span class="number">64</span><span class="operator">)</span> {
	Q <span class="operator">=</span> Integer<span class="operator">(</span>TruncateTowardZero<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> / ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">-</span> <span class="operator">(</span>ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">*</span> Q<span class="operator">)</span><span class="operator">;</span>
	C0 <span class="operator">=</span> GetLeastSignificantBit<span class="operator">(</span>Q2<span class="operator">)</span><span class="operator">;</span>
	C1 <span class="operator">=</span> GetLeastSignificantBit<span class="operator">(</span>Q0<span class="operator">)</span><span class="operator">;</span>
	C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	C3 <span class="operator">=</span> GetLeastSignificantBit<span class="operator">(</span>Q1<span class="operator">)</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	C2 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
	N <span class="operator">=</span> Constant<span class="operator">;</span> <span class="comment">//This is an implementation-dependent number between 32 and 63.</span>
	QQ <span class="operator">=</span> Integer<span class="operator">(</span>TruncateTowardZero<span class="operator">(</span><span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> / ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span><span class="operator">)</span> / <span class="number">2</span> <span class="operator">*</span> <span class="operator">(</span>D <span class="operator">-</span> N<span class="operator">)</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">-</span> <span class="operator">(</span>ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">*</span> QQ <span class="operator">*</span> <span class="number">2</span><span class="operator">(</span>D <span class="operator">-</span> N<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
}
</pre>
</td></tr><tr><td><strong>FPREM1</strong><br />Partial Remainder<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 F5</code></td>
<td class="grid"><code>FPREM1</code></td>
<td class="grid">Replace ST(0) with the IEEE remainder obtained from dividing ST(0) by ST(1).</td>
</tr>
</table></td><td>
<p>Computes the IEEE remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or modulus), and stores the result in ST(0).</p>
<p>The remainder represents the following value: Remainder = ST(0) - (Q * ST(1)) Here, Q is an integer value that is obtained by rounding the floating-point number quotient of [ST(0) / ST(1)] toward the nearest integer value. The magnitude of the remainder is less than or equal to half the magnitude of the modulus, unless a partial remainder was computed (as described below).</p>
<p>This instruction produces an exact result; the precision (inexact) exception does not occur and the rounding control has no effect. The following table shows the results obtained when computing the remainder of various classes of numbers, assuming that underflow does not occur.</p>
<div>
<table class="grid">
<caption>FPREM1 Results</caption>
<tr><td>-</td><td>ST(0): -inf</td><td>ST(0): -F</td><td>ST(0): -0</td><td>ST(0): +0</td><td>ST(0): +F</td><td>ST(0): +inf</td><td>ST(0): NaN</td></tr>
<tr><td>ST(1): -inf</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td><td>NaN</td></tr>
<tr><td>ST(1): -F</td><td>ST(0)</td><td>-F</td><td>or</td><td>-0</td><td>**</td><td>**</td><td>-F</td><td>or</td><td>-0</td><td>ST(0)</td><td>NaN</td></tr>
<tr><td>ST(1): -0</td><td>-0</td><td>-0</td><td>*</td><td>*</td><td>-0</td><td>-0</td><td>NaN</td></tr>
<tr><td>ST(1): +0</td><td>+0</td><td>+0</td><td>*</td><td>*</td><td>+0</td><td>+0</td><td>NaN</td></tr>
<tr><td>ST(1): +F</td><td>ST(0)</td><td>+F</td><td>or</td><td>+0</td><td>**</td><td>**</td><td>+F</td><td>or</td><td>+0</td><td>ST(0)</td><td>NaN</td></tr>
<tr><td>ST(1): +inf</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td><td>NaN</td></tr>
<tr><td>ST(1): NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="8">F Means finite floating-point value.</td></tr>
<tr><td colspan="8">* Indicates floating-point invalid-arithmetic-operand (#IA) exception.</td></tr>
<tr><td colspan="8">** Indicates floating-point zero-divide (#Z) exception.</td></tr>
</tfoot>
</table>
</div>
<p>When the result is 0, its sign is the same as that of the dividend. When the modulus is infinite, the result is equal to the value in ST(0).</p>
<p>The FPREM1 instruction computes the remainder specified in IEEE Standard 754. This instruction operates differently from the FPREM instruction in the way that it rounds the quotient of ST(0) divided by ST(1) to an integer (see the &quot;Operations&quot; section below).</p>
<p>Like the FPREM instruction, FPREM1 computes the remainder through iterative subtraction, but can reduce the exponent of ST(0) by no more than 63 in one execution of the instruction. If the instruction succeeds in producing a remainder that is less than one half the modulus, the operation is complete and the C2 flag in the FPU status word is cleared. Otherwise, C2 is set, and the result in ST(0) is called the partial remainder. The exponent of the partial remainder will be less than the exponent of the original dividend by at least 32. Software can re-execute the instruction (using the partial remainder in ST(0) as the dividend) until C2 is cleared. (Note that while executing such a remainder-computation loop, a higher-priority interrupting routine that needs the FPU can force a context switch in-between the instructions in the loop.) An important use of the FPREM1 instruction is to reduce the arguments of periodic functions.</p>
<p>When reduction is complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU status word. This information is important in argument reduction for the tangent function (using a modulus of pi/4), because it locates the original angle in the correct one of eight sectors of the unit circle.</p>
<br />ST(1): -inf</td><td>
<pre>D <span class="operator">=</span> GetExponent<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span> <span class="operator">-</span> GetExponent<span class="operator">(</span>ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>D <span class="operator">&lt;</span> <span class="number">64</span><span class="operator">)</span> {
	Q <span class="operator">=</span> Integer<span class="operator">(</span>RoundTowardNearestInteger<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> / ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">-</span> <span class="operator">(</span>ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">*</span> Q<span class="operator">)</span><span class="operator">;</span>
	C0 <span class="operator">=</span> GetLeastSignificantBit<span class="operator">(</span>Q2<span class="operator">)</span><span class="operator">;</span>
	C1 <span class="operator">=</span> GetLeastSignificantBit<span class="operator">(</span>Q0<span class="operator">)</span><span class="operator">;</span>
	C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	C3 <span class="operator">=</span> GetLeastSignificantBit<span class="operator">(</span>Q1<span class="operator">)</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	C2 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
	N <span class="operator">=</span> Constant<span class="operator">;</span> <span class="comment">//This is an implementation-dependent number between 32 and 63.</span>
	QQ <span class="operator">=</span> Integer<span class="operator">(</span>TruncateTowardZero<span class="operator">(</span><span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> / ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span><span class="operator">)</span> / <span class="number">2</span><span class="operator">(</span>D <span class="operator">-</span> N<span class="operator">)</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">-</span> <span class="operator">(</span>ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">*</span> QQ <span class="operator">*</span> <span class="number">2</span><span class="operator">(</span>D <span class="operator">-</span> N<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
}
</pre>
</td></tr><tr><td><strong>FPTAN</strong><br />Partial Tangent<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 F2</code></td>
<td class="grid"><code>FPTAN Replace ST(0) with its tangent and push 1 onto the FPU stack.</code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Computes the tangent of the source operand in register ST(0), stores the result in ST(0), and pushes a 1.0 onto the FPU register stack. The source operand must be given in radians and must be less than +-2^63. The following table shows the unmasked results obtained when computing the partial tangent of various classes of numbers, assuming that underflow does not occur.</p>
<div>
<table class="grid">
<caption>FPTAN Results</caption>
<tr><th>ST(0) Source</th><th>ST(0) Destination</th></tr>
<tr><td>-inf</td><td>*</td></tr>
<tr><td>-F</td><td>-F to +F</td></tr>
<tr><td>-0</td><td>-0</td></tr>
<tr><td>+0</td><td>+0</td></tr>
<tr><td>+F</td><td>-F to +F</td></tr>
<tr><td>+inf</td><td>*</td></tr>
<tr><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="2">F Means finite floating-point value.</td></tr>
<tr><td colspan="2">* Indicates floating-point invalid-arithmetic-operand (#IA) exception.</td></tr>
</tfoot>
</table>
</div>
<p>If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-ofrange conditions. Source values outside the range -2^63 to +2^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2 * pi or by using the FPREM instruction with a divisor of 2 * pi. See the section titled &quot;Pi&quot; in Chapter 8 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for a discussion of the proper value to use for pi in performing such reductions.</p>
<p>The value 1.0 is pushed onto the register stack after the tangent has been computed to maintain compatibility with the Intel 8087 and Intel287 math coprocessors. This operation also simplifies the calculation of other trigonometric functions. For instance, the cotangent (which is the reciprocal of the tangent) can be computed by executing a FDIVR instruction after the FPTAN instruction.</p>
<br />-inf</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="operator">(</span><span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">63</span><span class="operator">)</span><span class="operator">)</span> {
	C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> Tangens<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	Top <span class="operator">=</span> Top <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
	ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> <span class="number">1.0</span><span class="operator">;</span>
}
<span class="keyword">else</span> C2 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//source operand is out-of-range</span>
</pre>
</td></tr><tr><td><strong>FRNDINT</strong><br />Round to Integer<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 FC</code></td>
<td class="grid"><code>FRNDINT</code></td>
<td class="grid">Round ST(0) to an integer.</td>
</tr>
</table></td><td>
<p>Rounds the source value in the ST(0) register to the nearest integral value, depending on the current rounding mode (setting of the RC field of the FPU control word), and stores the result in ST(0).</p>
<p>If the source value is infinite, the value is not changed. If the source value is not an integral value, the floating-point inexact-result exception (#P) is generated.</p>
<br />
<pre>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> RoundToIntegralValue<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>C1 Set to 0 if stack underflow occurred.
Set if result was rounded up; cleared otherwise.
C0, C2, C3 Undefined.
</p>
</td></tr><tr><td><strong>FRSTOR</strong><br />Restore x87 FPU State<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>DD /4</code></td>
<td class="grid"><code>FRSTOR m94/108byte</code></td>
<td class="grid">Load FPU state from m94byte or m108byte.</td>
</tr>
</table></td><td>
<p>Loads the FPU state (operating environment and register stack) from the memory area specified with the source operand. This state data is typically written to the specified memory location by a previous FSAVE/FNSAVE instruction.</p>
<p>The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately following the operating environment image.</p>
<p>The FRSTOR instruction should be executed in the same operating mode as the corresponding FSAVE/FNSAVE instruction.</p>
<p>If one or more unmasked exception bits are set in the new FPU status word, a floating-point exception will be generated. To avoid raising exceptions when loading a new operating environment, clear all the exception flags in the FPU status word that is being loaded.</p>
<br />
<pre>FPUControlWord <span class="operator">=</span> Source<span class="operator">.</span>FPUControlWord<span class="operator">;</span>
FPUStatusWord <span class="operator">=</span> Source<span class="operator">.</span>FPUStatusWord<span class="operator">.</span><span class="operator">;</span>
FPUTagWord <span class="operator">=</span> Source<span class="operator">.</span>FPUTagWord<span class="operator">.</span><span class="operator">;</span>
FPUDataPointer <span class="operator">=</span> Source<span class="operator">.</span>FPUDataPointer<span class="operator">;</span>
FPUInstructionPointer <span class="operator">=</span> Source<span class="operator">.</span>FPUInstructionPointer<span class="operator">;</span>
FPULastInstructionOpcode <span class="operator">=</span> Source<span class="operator">.</span>FPULastInstructionOpcode<span class="operator">.</span><span class="operator">;</span>
ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> Source<span class="operator">.</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">;</span>
ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">=</span> Source<span class="operator">.</span>ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span><span class="operator">;</span>
ST<span class="operator">(</span><span class="number">2</span><span class="operator">)</span> <span class="operator">=</span> Source<span class="operator">.</span>ST<span class="operator">(</span><span class="number">2</span><span class="operator">)</span><span class="operator">;</span>
ST<span class="operator">(</span><span class="number">3</span><span class="operator">)</span> <span class="operator">=</span> Source<span class="operator">.</span>ST<span class="operator">(</span><span class="number">3</span><span class="operator">)</span><span class="operator">;</span>
ST<span class="operator">(</span><span class="number">4</span><span class="operator">)</span> <span class="operator">=</span> Source<span class="operator">.</span>ST<span class="operator">(</span><span class="number">4</span><span class="operator">)</span><span class="operator">;</span>
ST<span class="operator">(</span><span class="number">5</span><span class="operator">)</span> <span class="operator">=</span> Source<span class="operator">.</span>ST<span class="operator">(</span><span class="number">5</span><span class="operator">)</span><span class="operator">;</span>
ST<span class="operator">(</span><span class="number">6</span><span class="operator">)</span> <span class="operator">=</span> Source<span class="operator">.</span>ST<span class="operator">(</span><span class="number">6</span><span class="operator">)</span><span class="operator">;</span>
ST<span class="operator">(</span><span class="number">7</span><span class="operator">)</span> <span class="operator">=</span> Source<span class="operator">.</span>ST<span class="operator">(</span><span class="number">7</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>The C0, C1, C2, C3 flags are loaded.
</p>
</td></tr><tr><td><strong>FSAVE/FNSAVE</strong><br />Store x87 FPU State<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>9B DD /6</code></td>
<td class="grid"><code>FSAVE m94/108byte</code></td>
<td class="grid">Store FPU state to m94byte or m108byte after checking for pending unmasked floating-point exceptions. Then reinitialize the FPU.</td>
</tr>
<tr>
<td class="grid"><code>DD /6</code></td>
<td class="grid"><code>FNSAVE m94/108byte</code></td>
<td class="grid">Store FPU environment to m94byte or m108byte without checking for pending unmasked floating-point exceptions. Then re-initialize the FPU. See the IA-32 Architecture Compatibility section below.</td>
</tr>
</table></td><td>
<p>Stores the current FPU state (operating environment and register stack) at the specified destination in memory, and then re-initializes the FPU. The FSAVE instruction checks for and handles pending unmasked floating-point exceptions before storing the FPU state; the FNSAVE instruction does not.</p>
<p>The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately follow the operating environment image.</p>
<p>The saved image reflects the state of the FPU after all floating-point instructions preceding the FSAVE/FNSAVE instruction in the instruction stream have been executed.</p>
<p>After the FPU state has been saved, the FPU is reset to the same default values it is set to with the FINIT/FNINIT instructions (see &quot;FINIT/FNINIT-Initialize Floating-Point Unit&quot; in this chapter).</p>
<p>The FSAVE/FNSAVE instructions are typically used when the operating system needs to perform a context switch, an exception handler needs to use the FPU, or an application program needs to pass a &quot;clean&quot; FPU to a procedure.</p>
<p>The assembler issues two instructions for the FSAVE instruction (an FWAIT instruction followed by an FNSAVE instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.</p>
<br />
<pre><span class="comment">//Save FPU State and Registers</span>
Destination<span class="operator">.</span>FPUControlWord <span class="operator">=</span> FPUControlWord<span class="operator">;</span>
Destination<span class="operator">.</span>FPUStatusWord <span class="operator">=</span> FPUStatusWord<span class="operator">;</span>
Destination<span class="operator">.</span>FPUTagWord <span class="operator">=</span> FPUTagWord<span class="operator">;</span>
Destination<span class="operator">.</span>FPUDataPointer <span class="operator">=</span> FPUDataPointer<span class="operator">;</span>
Destination<span class="operator">.</span>FPUInstructionPointer <span class="operator">=</span> FPUInstructionPointer<span class="operator">;</span>
Destination<span class="operator">.</span>FPULastInstructionOpcode <span class="operator">=</span> FPULastInstructionOpcode<span class="operator">;</span>
Destination<span class="operator">.</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">.</span>ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">.</span>ST<span class="operator">(</span><span class="number">2</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">2</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">.</span>ST<span class="operator">(</span><span class="number">3</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">3</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">.</span>ST<span class="operator">(</span><span class="number">4</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">4</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">.</span>ST<span class="operator">(</span><span class="number">5</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">5</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">.</span>ST<span class="operator">(</span><span class="number">6</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">6</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">.</span>ST<span class="operator">(</span><span class="number">7</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">7</span><span class="operator">)</span><span class="operator">;</span>
<span class="comment">//Initialize FPU</span>
FPUControlWord <span class="operator">=</span> <span class="number">0x37F</span><span class="operator">;</span>
FPUStatusWord <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
FPUTagWord <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
FPUDataPointer <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
FPUInstructionPointer <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
FPULastInstructionOpcode <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
<p>The C0, C1, C2, and C3 flags are saved and then cleared.
</p>
</td></tr><tr><td><strong>FSCALE</strong><br />Scale<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 FD</code></td>
<td class="grid"><code>FSCALE</code></td>
<td class="grid">Scale ST(0) by ST(1).</td>
</tr>
</table></td><td>
<p>Truncates the value in the source operand (toward 0) to an integral value and adds that value to the exponent of the destination operand. The destination and source operands are floating-point values located in registers ST(0) and ST(1), respectively. This instruction provides rapid multiplication or division by integral powers of 2. The following table shows the results obtained when scaling various classes of numbers, assuming that neither overflow nor underflow occurs.</p>
<div>
<table class="grid">
<caption>FSCALE Results</caption>
<tr><td>-</td><td>ST(1): -inf</td><td>ST(1): -F</td><td>ST(1): -0</td><td>ST(1): +0</td><td>ST(1): +F</td><td>ST(1): +inf</td><td>ST(1): NaN</td></tr>
<tr><td>ST(0): -inf</td><td>NaN</td><td>-inf</td><td>-inf</td><td>-inf</td><td>-inf</td><td>-inf</td><td>NaN</td></tr>
<tr><td>ST(0): -F</td><td>-0</td><td>-F</td><td>-F</td><td>-F</td><td>-F</td><td>-inf</td><td>NaN</td></tr>
<tr><td>ST(0): -0</td><td>-0</td><td>-0</td><td>-0</td><td>-0</td><td>-0</td><td>NaN</td><td>NaN</td></tr>
<tr><td>ST(0): +0</td><td>+0</td><td>+0</td><td>+0</td><td>+0</td><td>+0</td><td>NaN</td><td>NaN</td></tr>
<tr><td>ST(0): +F</td><td>+0</td><td>+F</td><td>+F</td><td>+F</td><td>+F</td><td>+inf</td><td>NaN</td></tr>
<tr><td>ST(0): +inf</td><td>NaN</td><td>+inf</td><td>+inf</td><td>+inf</td><td>+inf</td><td>+inf</td><td>NaN</td></tr>
<tr><td>ST(0): NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="8">F Means finite floating-point value.</td></tr>
</tfoot>
</table>
</div>
<p>In most cases, only the exponent is changed and the mantissa remains unchanged.</p>
<p>However, when the value being scaled in ST(0) is a denormal value, the mantissa is also changed and the result may turn out to be a normalized number. Similarly, if overflow or underflow results from a scale operation, the resulting mantissa will differ from the source's mantissa.</p>
<p>The FSCALE instruction can also be used to reverse the action of the FXTRACT instruction, as shown in the following example: FXTRACT; FSCALE; FSTP ST(1); In this example, the FXTRACT instruction extracts the mantissa and exponent from the value in ST(0) and stores them in ST(0) and ST(1) respectively. The FSCALE then scales the mantissa in ST(0) by the exponent in ST(1), recreating the original value before the FXTRACT operation was performed. The FSTP ST(1) instruction overwrites the exponent (extracted by the FXTRACT instruction) with the recreated value, which returns the stack to its original state with only one register [ST(0)] occupied.</p>
<br />ST(0): -inf</td><td>
<pre>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">*</span> <span class="number">2</span>RoundTowardZero<span class="operator">(</span>ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FSIN</strong><br />Sine<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 FE</code></td>
<td class="grid"><code>FSIN</code></td>
<td class="grid">Replace ST(0) with its sine.</td>
</tr>
</table></td><td>
<p>Computes the sine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range -2^63 to +2^63. The following table shows the results obtained when taking the sine of various classes of numbers, assuming that underflow does not occur.</p>
<div>
<table class="grid">
<caption>FSIN Results</caption>
<tr><th>Source (ST(0))</th><th>Destination (ST(0))</th></tr>
<tr><td>-inf</td><td>*</td></tr>
<tr><td>-F</td><td>-1 to +1</td></tr>
<tr><td>-0</td><td>-0</td></tr>
<tr><td>+0</td><td>+0</td></tr>
<tr><td>+F</td><td>-1 to +1</td></tr>
<tr><td>+inf</td><td>*</td></tr>
<tr><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="2">F Means finite floating-point value.</td></tr>
<tr><td colspan="2">* Indicates floating-point invalid-arithmetic-operand (#IA) exception.</td></tr>
</tfoot>
</table>
</div>
<p>If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-ofrange conditions. Source values outside the range -2^63 to +2^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2Pi or by using the FPREM instruction with a divisor of 2Pi. See the section titled &quot;Pi&quot; in Chapter 8 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for a discussion of the proper value to use for pi in performing such reductions.</p>
<br />-inf</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="operator">(</span><span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">63</span><span class="operator">)</span><span class="operator">)</span> {
	C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> Sine<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
}
<span class="keyword">else</span> C2 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//source operand out of range</span>
</pre>
</td></tr><tr><td><strong>FSINCOS</strong><br />Sine and Cosine<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 FB</code></td>
<td class="grid"><code>FSINCOS</code></td>
<td class="grid">Compute the sine and cosine of ST(0); replace ST(0) with the sine, and push the cosine onto the register stack.</td>
</tr>
</table></td><td>
<p>Computes both the sine and the cosine of the source operand in register ST(0), stores the sine in ST(0), and pushes the cosine onto the top of the FPU register stack. (This instruction is faster than executing the FSIN and FCOS instructions in succession.) The source operand must be given in radians and must be within the range -2^63 to +2^63. The following table shows the results obtained when taking the sine and cosine of various classes of numbers, assuming that underflow does not occur.</p>
<div>
<table class="grid">
<caption>FSINCOS results</caption>
<tr><th>Source: ST(0)</th><th>Destination: ST(1) Cosine</th><th>Destination: ST(0) Sine</th></tr>
<tr><td>-inf</td><td>*</td><td>*</td></tr>
<tr><td>-F</td><td>-1 to +1</td><td>-1 to +1</td></tr>
<tr><td>-0</td><td>+1</td><td>-0</td></tr>
<tr><td>+0</td><td>+1</td><td>+0</td></tr>
<tr><td>+F</td><td>-1 to +1</td><td>-1 to +1</td></tr>
<tr><td>+inf</td><td>*</td><td>*</td></tr>
<tr><td>NaN</td><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="3">F Means finite floating-point value.</td></tr>
<tr><td colspan="3">* Indicates floating-point invalid-arithmetic-operand (#IA) exception.</td></tr>
</tfoot>
</table>
</div>
<p>If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-ofrange conditions. Source values outside the range -2^63 to +2^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2Pi or by using the FPREM instruction with a divisor of 2Pi. See the section titled &quot;Pi&quot; in Chapter 8 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for a discussion of the proper value to use for pi in performing such reductions.</p>
<br />-inf</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="operator">(</span><span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">63</span><span class="operator">)</span><span class="operator">)</span> {
	C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	Temporary <span class="operator">=</span> Cosine<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> Sine<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	Top <span class="operator">=</span> Top <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
	ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> Temporary<span class="operator">;</span>
}
<span class="keyword">else</span> C2 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//source operand out of range</span>
</pre>
</td></tr><tr><td><strong>FSQRT</strong><br />Square Root<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 FA</code></td>
<td class="grid"><code>FSQRT</code></td>
<td class="grid">Computes square root of ST(0) and stores the result in ST(0).</td>
</tr>
</table></td><td>
<p>Computes the square root of the source value in the ST(0) register and stores the result in ST(0).</p>
<p>The following table shows the results obtained when taking the square root of various classes of numbers, assuming that neither overflow nor underflow occurs.</p>
<div>
<table class="grid">
<caption>FSQRT Results</caption>
<tr><th>Source (ST(0))</th><th>Destination (ST(0))</th></tr>
<tr><td>-inf</td><td>*</td></tr>
<tr><td>-F</td><td>*</td></tr>
<tr><td>-0</td><td>-0</td></tr>
<tr><td>+0</td><td>+0</td></tr>
<tr><td>+F</td><td>+F</td></tr>
<tr><td>+inf</td><td>+inf</td></tr>
<tr><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="2">F Means finite floating-point value.</td></tr>
<tr><td colspan="2">* Indicates floating-point invalid-arithmetic-operand (#IA) exception.</td></tr>
</tfoot>
</table>
</div>
<br />-inf</td><td>
<pre>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> SquareRoot<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FST/FSTP</strong><br />Store Floating Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 /2</code></td>
<td class="grid"><code>FST m32fp</code></td>
<td class="grid">Copy ST(0) to m32fp.</td>
</tr>
<tr>
<td class="grid"><code>DD /2</code></td>
<td class="grid"><code>FST m64fp</code></td>
<td class="grid">Copy ST(0) to m64fp.</td>
</tr>
<tr>
<td class="grid"><code>DD D0+i</code></td>
<td class="grid"><code>FST ST(i)</code></td>
<td class="grid">Copy ST(0) to ST(i).</td>
</tr>
<tr>
<td class="grid"><code>D9 /3</code></td>
<td class="grid"><code>FSTP m32fp</code></td>
<td class="grid">Copy ST(0) to m32fp and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>DD /3</code></td>
<td class="grid"><code>FSTP m64fp</code></td>
<td class="grid">Copy ST(0) to m64fp and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>DB /7</code></td>
<td class="grid"><code>FSTP m80fp</code></td>
<td class="grid">Copy ST(0) to m80fp and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>DD D8+i</code></td>
<td class="grid"><code>FSTP ST(i)</code></td>
<td class="grid">Copy ST(0) to ST(i) and pop register stack.</td>
</tr>
</table></td><td>
<p>The FST instruction copies the value in the ST(0) register to the destination operand, which can be a memory location or another register in the FPU register stack. When storing the value in memory, the value is converted to single-precision or double-precision floating-point format.</p>
<p>The FSTP instruction performs the same operation as the FST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FSTP instruction can also store values in memory in double extended-precision floating-point format.</p>
<p>If the destination operand is a memory location, the operand specifies the address where the first byte of the destination value is to be stored. If the destination operand is a register, the operand specifies a register in the register stack relative to the top of the stack.</p>
<p>If the destination size is single-precision or double-precision, the mantissa of the value being stored is rounded to the width of the destination (according to the rounding mode specified by the RC field of the FPU control word), and the exponent is converted to the width and bias of the destination format. If the value being stored is too large for the destination format, a numeric overflow exception (#O) is generated and, if the exception is unmasked, no value is stored in the destination operand. If the value being stored is a denormal value, the denormal exception (#D) is not generated. This condition is simply signaled as a numeric underflow exception (#U) condition.</p>
<p>If the value being stored is +-0, +-infinite, or a NaN, the least-significant bits of the mantissa and the exponent are truncated to fit the destination format. This operation preserves the value's identity as a 0, infinite, or NaN.</p>
<p>If the destination operand is a non-empty register, the invalid-operation exception is not generated.</p>
<br />
<pre>Destination <span class="operator">=</span> ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FSTP<span class="operator">)</span> PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>C1 Set to 0 if stack underflow occurred.
Indicates rounding direction of if the floating-point inexact exception (#P)
is generated: 0 = not roundup; 1 = roundup.
C0, C2, C3 Undefined.
</p>
</td></tr><tr><td><strong>FSTCW/FNSTCW</strong><br />Store x87 FPU Control Word<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>9B D9 /7</code></td>
<td class="grid"><code>FSTCW m2byte</code></td>
<td class="grid">Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions.</td>
</tr>
<tr>
<td class="grid"><code>D9 /7</code></td>
<td class="grid"><code>FNSTCW m2byte</code></td>
<td class="grid">Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions. See IA-32 Architecture Compatibility section below.</td>
</tr>
</table></td><td>
<p>Stores the current value of the FPU control word at the specified destination in memory. The FSTCW instruction checks for and handles pending unmasked floating-point exceptions before storing the control word; the FNSTCW instruction does not.</p>
<p>The assembler issues two instructions for the FSTCW instruction (an FWAIT instruction followed by an FNSTCW instruction), and the processor executes each of these instructions in separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.</p>
<br />
<pre>Destination <span class="operator">=</span> FPUControlWord<span class="operator">;</span>
</pre>
</td><td>
<p>The C0, C1, C2, and C3 flags are undefined.
</p>
</td></tr><tr><td><strong>FSTENV/FNSTENV</strong><br />Store x87 FPU Environment<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>9B D9 /6</code></td>
<td class="grid"><code>FSTENV m14/28byte</code></td>
<td class="grid">Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions.</td>
</tr>
<tr>
<td class="grid"><code>D9 /6</code></td>
<td class="grid"><code>FNSTENV* m14/28byte</code></td>
<td class="grid">Store FPU environment to m14byte or m28byte without checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions. See the IA-32 Architecture Compatibility section below.</td>
</tr>
</table></td><td>
<p>Saves the current FPU operating environment at the memory location specified with the destination operand, and then masks all floating-point exceptions. The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16- bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.</p>
<p>The FSTENV instruction checks for and handles any pending unmasked floating-point exceptions before storing the FPU environment; the FNSTENV instruction does not. The saved image reflects the state of the FPU after all floating-point instructions preceding the FSTENV/FNSTENV instruction in the instruction stream have been executed.</p>
<p>These instructions are often used by exception handlers because they provide access to the FPU instruction and data pointers. The environment is typically saved in the stack. Masking all exceptions after saving the environment prevents floating-point exceptions from interrupting the exception handler.</p>
<p>The assembler issues two instructions for the FSTENV instruction (an FWAIT instruction followed by an FNSTENV instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.</p>
<br />
<pre>Destination<span class="operator">.</span>FPUControlWord <span class="operator">=</span> FPUControlWord<span class="operator">;</span>
Destination<span class="operator">.</span>FPUStatusWord <span class="operator">=</span> FPUStatusWord<span class="operator">;</span>
Destination<span class="operator">.</span>FPUTagWord <span class="operator">=</span> FPUTagWord<span class="operator">;</span>
Destination<span class="operator">.</span>FPUDataPointer <span class="operator">=</span> FPUDataPointer<span class="operator">;</span>
Destination<span class="operator">.</span>FPUInstructionPointer <span class="operator">=</span> FPUInstructionPointer<span class="operator">;</span>
Destination<span class="operator">.</span>FPULastInstructionOpcode <span class="operator">=</span> FPULastInstructionOpcode<span class="operator">;</span>
</pre>
</td><td>
<p>The C0, C1, C2, and C3 are undefined.
</p>
</td></tr><tr><td><strong>FSTSW/FNSTSW</strong><br />Store x87 FPU Status Word<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>9B DD /7</code></td>
<td class="grid"><code>FSTSW m2byte</code></td>
<td class="grid">Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions.</td>
</tr>
<tr>
<td class="grid"><code>9B DF E0</code></td>
<td class="grid"><code>FSTSW AX</code></td>
<td class="grid">Store FPU status word in AX register after checking for pending unmasked floating-point exceptions.</td>
</tr>
<tr>
<td class="grid"><code>DD /7</code></td>
<td class="grid"><code>FNSTSW* m2byte</code></td>
<td class="grid">Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions.</td>
</tr>
<tr>
<td class="grid"><code>DF E0</code></td>
<td class="grid"><code>FNSTSW* AX</code></td>
<td class="grid">Store FPU status word in AX register without checking for pending unmasked floating-point exceptions.</td>
</tr>
</table></td><td>
<p>NOTE: * See IA-32 Architecture Compatibility section below.</p>
<p>Stores the current value of the x87 FPU status word in the destination location. The destination operand can be either a two-byte memory location or the AX register. The FSTSW instruction checks for and handles pending unmasked floating-point exceptions before storing the status word; the FNSTSW instruction does not.</p>
<p>The FNSTSW AX form of the instruction is used primarily in conditional branching (for instance, after an FPU comparison instruction or an FPREM, FPREM1, or FXAM instruction), where the direction of the branch depends on the state of the FPU condition code flags. (See the section titled &quot;Branching and Conditional Moves on FPU Condition Codes&quot; in Chapter 8 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1.) This instruction can also be used to invoke exception handlers (by examining the exception flags) in environments that do not use interrupts. When the FNSTSW AX instruction is executed, the AX register is updated before the processor executes any further instructions. The status stored in the AX register is thus guaranteed to be from the completion of the prior FPU instruction.</p>
<p>The assembler issues two instructions for the FSTSW instruction (an FWAIT instruction followed by an FNSTSW instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.</p>
<br />
<pre>Destination <span class="operator">=</span> FPUStatusWord<span class="operator">;</span>
</pre>
</td><td>
<p>The C0, C1, C2, and C3 are undefined.
</p>
</td></tr><tr><td><strong>FSUB/FSUBP/FISUB</strong><br />Subtract<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D8 /4</code></td>
<td class="grid"><code>FSUB m32fp</code></td>
<td class="grid">Subtract m32fp from ST(0) and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>DC /4</code></td>
<td class="grid"><code>FSUB m64fp</code></td>
<td class="grid">Subtract m64fp from ST(0) and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>D8 E0+i</code></td>
<td class="grid"><code>FSUB ST(0), ST(i)</code></td>
<td class="grid">Subtract ST(i) from ST(0) and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>DC E8+i</code></td>
<td class="grid"><code>FSUB ST(i), ST(0)</code></td>
<td class="grid">Subtract ST(0) from ST(i) and store result in ST(i).</td>
</tr>
<tr>
<td class="grid"><code>DE E8+i</code></td>
<td class="grid"><code>FSUBP ST(i), ST(0)</code></td>
<td class="grid">Subtract ST(0) from ST(i), store result in ST(i), and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>DE E9</code></td>
<td class="grid"><code>FSUBP</code></td>
<td class="grid">Subtract ST(0) from ST(1), store result in ST(1), and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>DA /4</code></td>
<td class="grid"><code>FISUB m32int</code></td>
<td class="grid">Subtract m32int from ST(0) and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>DE /4</code></td>
<td class="grid"><code>FISUB m16int</code></td>
<td class="grid">Subtract m16int from ST(0) and store result in ST(0).</td>
</tr>
</table></td><td>
<p>Subtracts the source operand from the destination operand and stores the difference in the destination location. The destination operand is always an FPU data register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.</p>
<p>The no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floating-point or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.</p>
<p>The FSUBP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUB rather than FSUBP.</p>
<p>The FISUB instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.</p>
<p>The following table shows the results obtained when subtracting various classes of numbers from one another, assuming that neither overflow nor underflow occurs. Here, the Source value is subtracted from the Destination value (Destination - Source = result).</p>
<p>When the difference between two operands of like sign is 0, the result is +0, except for the round toward -infinite mode, in which case the result is -0. This instruction also guarantees that +0 - (-0) = +0, and that -0 - (+0) = -0. When the source operand is an integer 0, it is treated as a +0.</p>
<p>When one operand is infinite, the result is infinite of the expected sign. If both operands are infinite of the same sign, an invalid-operation exception is generated.</p>
<div>
<table class="grid">
<caption>FSUB/FSUBP/FISUB Results</caption>
<tr><td>- Source: -inf</td><td>Source: -F or -I</td><td>Source: -0</td><td>Source: +0</td><td>Source: +F or +I</td><td>Source: +inf</td><td>Source: NaN</td></tr>
<tr><td>Destination: -inf</td><td>*</td><td>-inf</td><td>-inf</td><td>-inf</td><td>-inf</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Destination: -F</td><td>+inf</td><td>&Atilde;&Acirc;&plusmn;F</td><td>or</td><td>&Atilde;&Acirc;&plusmn;0</td><td>Destination</td><td>Destination</td><td>-F</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Destination: -0</td><td>+inf</td><td>-Source</td><td>&Atilde;&Acirc;&plusmn;0</td><td>-0</td><td>-Source</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Destination: +0</td><td>+inf</td><td>-Source</td><td>+0</td><td>&Atilde;&Acirc;&plusmn;0</td><td>-Source</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Destination: +F</td><td>+inf</td><td>+F</td><td>Destination</td><td>Destination</td><td>&Atilde;&Acirc;&plusmn;F</td><td>or</td><td>&Atilde;&Acirc;&plusmn;0</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Destination: +inf</td><td>+inf</td><td>+inf</td><td>+inf</td><td>+inf</td><td>+8</td><td>*</td><td>NaN</td></tr>
<tr><td>Destination: NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="8">F Means finite floating-point value.</td></tr>
<tr><td colspan="8">I Means integer.</td></tr>
<tr><td colspan="8">* Indicates floating-point invalid-arithmetic-operand (#IA) exception.</td></tr>
</tfoot>
</table>
</div>
<br />Destination: -inf</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FISUB<span class="operator">)</span> Destination <span class="operator">=</span> Destination <span class="operator">-</span> ConvertToExtendedDouble<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">else</span> Destination <span class="operator">=</span> Destination <span class="operator">-</span> Source<span class="operator">;</span> <span class="comment">//source operand is floating-point value</span>

<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FSUBP<span class="operator">)</span> PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FSUBR/FSUBRP/FISUBR</strong><br />Reverse Subtract<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D8 /5</code></td>
<td class="grid"><code>FSUBR m32fp</code></td>
<td class="grid">Subtract ST(0) from m32fp and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>DC /5</code></td>
<td class="grid"><code>FSUBR m64fp</code></td>
<td class="grid">Subtract ST(0) from m64fp and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>D8 E8+i</code></td>
<td class="grid"><code>FSUBR ST(0), ST(i)</code></td>
<td class="grid">Subtract ST(0) from ST(i) and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>DC E0+i</code></td>
<td class="grid"><code>FSUBR ST(i), ST(0)</code></td>
<td class="grid">Subtract ST(i) from ST(0) and store result in ST(i).</td>
</tr>
<tr>
<td class="grid"><code>DE E0+i</code></td>
<td class="grid"><code>FSUBRP ST(i), ST(0)</code></td>
<td class="grid">Subtract ST(i) from ST(0), store result in ST(i), and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>DE E1</code></td>
<td class="grid"><code>FSUBRP</code></td>
<td class="grid">Subtract ST(1) from ST(0), store result in ST(1), and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>DA /5</code></td>
<td class="grid"><code>FISUBR m32int</code></td>
<td class="grid">Subtract ST(0) from m32int and store result in ST(0).</td>
</tr>
<tr>
<td class="grid"><code>DE /5</code></td>
<td class="grid"><code>FISUBR m16int</code></td>
<td class="grid">Subtract ST(0) from m16int and store result in ST(0).</td>
</tr>
</table></td><td>
<p>Subtracts the destination operand from the source operand and stores the difference in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or doubleprecision floating-point format or in word or doubleword integer format.</p>
<p>These instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions.</p>
<p>They are provided to support more efficient coding.</p>
<p>The no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.</p>
<p>The FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point reverse subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUBR rather than FSUBRP.</p>
<p>The FISUBR instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.</p>
<p>The following table shows the results obtained when subtracting various classes of numbers from one another, assuming that neither overflow nor underflow occurs. Here, the Destination value is subtracted from the Source value (Source - Destination = result).</p>
<p>When the difference between two operands of like sign is 0, the result is +0, except for the round toward -infinite mode, in which case the result is -0. This instruction also guarantees that +0 - (-0) = +0, and that -0 - (+0) = -0. When the source operand is an integer 0, it is treated as a +0.</p>
<p>When one operand is infinite, the result is infinite of the expected sign. If both operands are infinite of the same sign, an invalid-operation exception is generated.</p>
<div>
<table class="grid">
<caption>FSUBR/FSUBRP/FISUBR Results</caption>
<tr><td>- Source: -inf</td><td>Source: -F or -I</td><td>Source: -0</td><td>Source: +0</td><td>Source: +F or +I</td><td>Source: +inf</td><td>Source: NaN</td></tr>
<tr><td>Destination: -inf</td><td>*</td><td>-inf</td><td>-inf</td><td>-inf</td><td>-inf</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Destination: -F</td><td>+inf</td><td>&Atilde;&Acirc;&plusmn;F</td><td>or</td><td>&Atilde;&Acirc;&plusmn;0</td><td>Destination</td><td>Destination</td><td>-F</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Destination: -0</td><td>+inf</td><td>-Source</td><td>&Atilde;&Acirc;&plusmn;0</td><td>-0</td><td>-Source</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Destination: +0</td><td>+inf</td><td>-Source</td><td>+0</td><td>&Atilde;&Acirc;&plusmn;0</td><td>-Source</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Destination: +F</td><td>+inf</td><td>+F</td><td>Destination</td><td>Destination</td><td>&Atilde;&Acirc;&plusmn;F</td><td>or</td><td>&Atilde;&Acirc;&plusmn;0</td><td>-inf</td><td>NaN</td></tr>
<tr><td>Destination: +inf</td><td>+inf</td><td>+inf</td><td>+inf</td><td>+inf</td><td>+8</td><td>*</td><td>NaN</td></tr>
<tr><td>Destination: NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="8">F Means finite floating-point value.</td></tr>
<tr><td colspan="8">I Means integer.</td></tr>
<tr><td colspan="8">* Indicates floating-point invalid-arithmetic-operand (#IA) exception.</td></tr>
</tfoot>
</table>
</div>
<br />Destination: -inf</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">=</span> FISUBR<span class="operator">)</span> Destination <span class="operator">=</span> ConvertToExtendedDouble<span class="operator">(</span>Source<span class="operator">)</span> <span class="operator">-</span> Destination<span class="operator">;</span>
<span class="keyword">else</span> Destination <span class="operator">=</span> Source <span class="operator">-</span> Destination<span class="operator">;</span> <span class="comment">//source operand is floating-point value</span>

<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FSUBRP<span class="operator">)</span> PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FTST</strong><br />Test Floating Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 E4</code></td>
<td class="grid"><code>FTST</code></td>
<td class="grid">Compare ST(0) with 0.0.</td>
</tr>
</table></td><td>
<p>Compares the value in the ST(0) register with 0.0 and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results (see table below).</p>
<div>
<table class="grid">
<caption>FTST Results</caption>
<tr><th>Condition</th><th>C3</th><th>C2</th><th>C0</th></tr>
<tr><td>ST(0) &gt; 0.0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>ST(0) &lt; 0.0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>ST(0) = 0.0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>Unordered</td><td>1</td><td>1</td><td>1</td></tr>
</table>
</div>
<p>This instruction performs an &quot;unordered comparison.&quot; An unordered comparison also checks the class of the numbers being compared (see &quot;FXAM-Examine&quot; in this chapter). If the value in register ST(0) is a NaN or is in an undefined format, the condition flags are set to &quot;unordered&quot; and the invalid operation exception is generated.</p>
<p>The sign of zero is ignored, so that -0.0 = +0.0.</p>
<br />ST(0) &gt; 0.0</td><td>
<pre>OperandRelation <span class="operator">=</span> Compare<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">,</span> <span class="number">0.0</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">switch</span><span class="operator">(</span>OperandRelation<span class="operator">)</span> {
	RelationGreaterThan<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	RelationLessThan<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	RelationEqual<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	RelationUnordered
		C3 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td></tr><tr><td><strong>FUCOM/FUCOMP/FUCOMPP</strong><br />Unordered Compare Floating Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>DD E0+i</code></td>
<td class="grid"><code>FUCOM ST(i)</code></td>
<td class="grid">Compare ST(0) with ST(i).</td>
</tr>
<tr>
<td class="grid"><code>DD E1</code></td>
<td class="grid"><code>FUCOM</code></td>
<td class="grid">Compare ST(0) with ST(1).</td>
</tr>
<tr>
<td class="grid"><code>DD E8+i</code></td>
<td class="grid"><code>FUCOMP ST(i)</code></td>
<td class="grid">Compare ST(0) with ST(i) and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>DD E9</code></td>
<td class="grid"><code>FUCOMP</code></td>
<td class="grid">Compare ST(0) with ST(1) and pop register stack.</td>
</tr>
<tr>
<td class="grid"><code>DA E9</code></td>
<td class="grid"><code>FUCOMPP</code></td>
<td class="grid">Compare ST(0) with ST(1) and pop register stack twice.</td>
</tr>
</table></td><td>
<p>Performs an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below).</p>
<p>If no operand is specified, the contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that -0.0 is equal to +0.0.</p>
<div>
<table class="grid">
<caption>FUCOM/FUCOMP/FUCOMPP Results</caption>
<tr><th>Comparison Results</th><th>C3</th><th>C2</th><th>C0</th></tr>
<tr><td>ST(0) &gt; ST(i)</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>ST(0) &lt; ST(i)</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>ST(0) = ST(i)</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>Unordered</td><td>1</td><td>1</td><td>1</td></tr>
<tfoot>
<tr><td colspan="4">* Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</td></tr>
</tfoot>
</table>
</div>
<p>An unordered comparison checks the class of the numbers being compared (see &quot;FXAM-Examine&quot; in this chapter). The FUCOM/FUCOMP/FUCOMPP instructions perform the same operations as the FCOM/FCOMP/FCOMPP instructions. The only difference is that the FUCOM/FUCOMP/FUCOMPP instructions raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format; QNaNs cause the condition code flags to be set to unordered, but do not cause an exception to be generated.</p>
<p>The FCOM/FCOMP/FCOMPP instructions raise an invalid-operation exception when either or both of the operands are a NaN value of any kind or are in an unsupported format.</p>
<p>As with the FCOM/FCOMP/FCOMPP instructions, if the operation results in an invalid-arithmetic- operand exception being raised, the condition code flags are set only if the exception is masked.</p>
<p>The FUCOMP instruction pops the register stack following the comparison operation and the FUCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.</p>
<br />ST(0) &gt; ST(i)</td><td>
<pre>OperandRelation <span class="operator">=</span> Compare<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">,</span> Source<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">switch</span><span class="operator">(</span>OperandRelation<span class="operator">)</span> {
	RelationGreaterThan<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	RelationLessThan<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	RelationEqual<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}

<span class="keyword">if</span><span class="operator">(</span>IsQNaN<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span> <span class="operator">||</span> IsQNaN<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">)</span> {
	C3 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
	C2 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
	C0 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	Exception<span class="operator">(</span>IA<span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>FPUControlWord<span class="operator">.</span>IM <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> {
		C3 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
	}
}

<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FUCOMP<span class="operator">)</span> PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> FUCOMPP<span class="operator">)</span> {
	PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
}
</pre>
</td></tr><tr><td><strong>FXAM</strong><br />Examine Floating Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 E5</code></td>
<td class="grid"><code>FXAM</code></td>
<td class="grid">Classify value or number in ST(0).</td>
</tr>
</table></td><td>
<p>Examines the contents of the ST(0) register and sets the condition code flags C0, C2, and C3 in the FPU status word to indicate the class of value or number in the register (see the table below).</p>
<div>
<table class="grid">
<caption>FXAM Results</caption>
<tr><th>Class</th><th>C3</th><th>C2</th><th>C0</th></tr>
<tr><td>Unsupported</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>NaN</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>Normal finite number</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>Infinity</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>Zero</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>Empty</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>Denormal number</td><td>1</td><td>1</td><td>0</td></tr>
</table>
</div>
<p>The C1 flag is set to the sign of the value in ST(0), regardless of whether the register is empty or full.</p>
<br />Unsupported</td><td>
<pre>C1 <span class="operator">=</span> GetSignBit<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">switch</span><span class="operator">(</span>GetClass<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">case</span> ClassUnsupported<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ClassNormal<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ClassInfinity<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ClassZero<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ClassEmpty<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ClassDenormal<span class="operator">:</span>
		C3 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C2 <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		C0 <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td></tr><tr><td><strong>FXCH</strong><br />Exchange Register Contents<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 C8+i</code></td>
<td class="grid"><code>FXCH ST(i)</code></td>
<td class="grid">Exchange the contents of ST(0) and ST(i).</td>
</tr>
<tr>
<td class="grid"><code>D9 C9</code></td>
<td class="grid"><code>FXCH</code></td>
<td class="grid">Exchange the contents of ST(0) and ST(1).</td>
</tr>
</table></td><td>
<p>Exchanges the contents of registers ST(0) and ST(i). If no source operand is specified, the contents of ST(0) and ST(1) are exchanged.</p>
<p>This instruction provides a simple means of moving values in the FPU register stack to the top of the stack [ST(0)], so that they can be operated on by those floating-point instructions that can only operate on values in ST(0). For example, the following instruction sequence takes the square root of the third register from the top of the register stack:</p>
<p>FXCH ST(3);</p>
<p>FSQRT;</p>
<p>FXCH ST(3);</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>NumberOfOperands <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> {
	Temporary <span class="operator">=</span> ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">;</span>
	ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> Source<span class="operator">;</span>
	Source <span class="operator">=</span> Temporary<span class="operator">;</span>
}
<span class="keyword">else</span> {
	Temporary <span class="operator">=</span> ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">;</span>
	ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span><span class="operator">;</span>
	ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">=</span> Temporary<span class="operator">;</span>
}
</pre>
</td><td>
<p>C1 Set to 0 if stack underflow occurred; otherwise, set to 0.
C0, C2, C3 Undefined.
</p>
</td></tr><tr><td><strong>FXRSTOR</strong><br />Restore x87 FPU, MMX Technology, SSE, and SSE2 State<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F AE /1</code></td>
<td class="grid"><code>FXRSTOR m512byte Restore the x87 FPU, MMX technology, XMM, and MXCSR register state from m512byte.</code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Reloads the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte memory image specified in the source operand. This data should have been written to memory previously using the FXSAVE instruction, and the first byte of the data should be located on a 16-byte boundary. The FXSAVE table shows the layout of the state information in memory and describes the fields in the memory image for the FXRSTOR and FXSAVE instructions.</p>
<p>The state image referenced with an FXRSTOR instruction must have been saved using an FXSAVE instruction or be in the same format as that shown in Table 3-47. Referencing a state image saved with an FSAVE or FNSAVE instruction will result in an incorrect state restoration.</p>
<p>The FXRSTOR instruction does not flush pending x87 FPU exceptions. To check and raise exceptions when loading x87 FPU state information with the FXRSTOR instruction, use an FWAIT instruction after the FXRSTOR instruction.</p>
<p>If the OSFXSR bit in control register CR4 is not set, the FXRSTOR instruction may not restore the states of the XMM and MXCSR registers. This behavior is implementation dependent.</p>
<p>If the MXCSR state contains an unmasked exception with a corresponding status flag also set, loading the register with the FXRSTOR instruction will not result in an SIMD floating-point error condition being generated. Only the next occurrence of this unmasked exception will result in the exception being generated.</p>
<p>Bit 6 and bits 16 through 32 of the MXCSR register are defined as reserved and should be set to 0. Attempting to write a 1 in any of these bits from the saved state image will result in a general protection exception (#GP) being generated.</p>
<br />
<pre><span class="operator">(</span>x87 FPU<span class="operator">,</span> MMX<span class="operator">,</span> XMM7<span class="operator">-</span>XMM0<span class="operator">,</span> MXCSR<span class="operator">)</span> <span class="operator">=</span> Load<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>FXSAVE</strong><br />Save x87 FPU, MMX Technology, SSE, and SSE2 State<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F AE /0</code></td>
<td class="grid"><code>FXSAVE m512byte</code></td>
<td class="grid">Save the x87 FPU, MMX technology, XMM, and MXCSR register state to m512byte.</td>
</tr>
</table></td><td>
<p>Saves the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory location specified in the destination operand. The following table shows the layout of the state information in memory.</p>
<div>
<table class="grid">
<caption>Layout of FXSAVE and FXRSTOR Memory Region</caption>
<tr><th>Bit #</th><th>Description</th></tr>
<tr><td>0-1</td><td>FCW</td></tr>
<tr><td>2-3</td><td>FSW</td></tr>
<tr><td>4</td><td>FTW</td></tr>
<tr><td>5</td><td>Reserved</td></tr>
<tr><td>6-7</td><td>FOP</td></tr>
<tr><td>8-11</td><td>FPU IP</td></tr>
<tr><td>12-13</td><td>CS</td></tr>
<tr><td>14-15</td><td>Reserved</td></tr>
<tr><td>16-19</td><td>FPU DP</td></tr>
<tr><td>20-21</td><td>DS</td></tr>
<tr><td>22-23</td><td>Reserved</td></tr>
<tr><td>24-27</td><td>MXCSR</td></tr>
<tr><td>28-31</td><td>MXCSR_MASK</td></tr>
<tr><td>32-41</td><td>ST0/MM0</td></tr>
<tr><td>42-47</td><td>Reserved</td></tr>
<tr><td>48-57</td><td>ST1/MM1</td></tr>
<tr><td>58-63</td><td>Reserved</td></tr>
<tr><td>64-73</td><td>ST2/MM2</td></tr>
<tr><td>74-79</td><td>Reserved</td></tr>
<tr><td>80-89</td><td>ST3/MM3</td></tr>
<tr><td>90-95</td><td>Reserved</td></tr>
<tr><td>96-105</td><td>ST4/MM4</td></tr>
<tr><td>106-111</td><td>Reserved</td></tr>
<tr><td>112-121</td><td>ST5/MM5</td></tr>
<tr><td>122-127</td><td>Reserved</td></tr>
<tr><td>128-137</td><td>ST6/MM6</td></tr>
<tr><td>138-143</td><td>Reserved</td></tr>
<tr><td>144-153</td><td>ST7/MM7</td></tr>
<tr><td>154-159</td><td>Reserved</td></tr>
<tr><td>160-175</td><td>XMM0</td></tr>
<tr><td>176-191</td><td>XMM1</td></tr>
<tr><td>192-207</td><td>XMM2</td></tr>
<tr><td>208-223</td><td>XMM3</td></tr>
<tr><td>224-239</td><td>XMM4</td></tr>
<tr><td>240-255</td><td>XMM5</td></tr>
<tr><td>256-271</td><td>XMM6</td></tr>
<tr><td>272-287</td><td>XMM7</td></tr>
<tr><td>288-512</td><td>Reserved</td></tr>
</table>
</div>
<p>The destination operand contains the first byte of the memory image, and it must be aligned on a 16-byte boundary. A misaligned destination operand will result in a general-protection (#GP) exception being generated (or in some cases, an alignment check exception [#AC]).</p>
<p>The FXSAVE instruction is used when an operating system needs to perform a context switch or when an exception handler needs to save and examine the current state of the x87 FPU, MMX technology, and/or XMM and MXCSR registers.</p>
<p>The fields in the table above are as follows:</p>
<dl>
<dt>FCW</dt>
<dd>x87 FPU Control Word (16 bits). See Figure 8-6 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for the layout of the x87 FPU control word.</dd>
<dt>FSW</dt>
<dd>x87 FPU Status Word (16 bits). See Figure 8-4 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for the layout of the x87 FPU status word.</dd>
<dt>FTW</dt>
<dd>x87 FPU Tag Word (8 bits). The tag information saved here is abridged, as described in the following paragraphs. See Figure 8-7 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for the layout of the x87 FPU tag word.</dd>
<dt>FOP</dt>
<dd>x87 FPU Opcode (16 bits). The lower 11 bits of this field contain the opcode, upper 5 bits are reserved. See Figure 8-8 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for the layout of the x87 FPU opcode field.</dd>
<dt>FPU</dt>
<dd>IP x87 FPU Instruction Pointer Offset (32 bits). The contents of this field differ depending on the current addressing mode (32-bit or 16-bit) of the processor when the FXSAVE instruction was executed: 32-bit mode -&gt; 32-bit IP offset, 16-bit mode -&gt; low 16 bits are IP offset with the high 16 bits being reserved. See &quot;x87 FPU Instruction and Operand (Data) Pointers&quot; in Chapter 8 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for a description of the x87 FPU instruction pointer.</dd>
<dt>CS</dt>
<dd>x87 FPU Instruction Pointer Selector (16 bits).</dd>
<dt>FPU</dt>
<dd>DP x87 FPU Instruction Operand (Data) Pointer Offset (32 bits). The contents of this field differ depending on the current addressing mode (32-bit or 16- bit) of the processor when the FXSAVE instruction was executed: 32-bit mode -&gt; 32-bit IP offset, 16-bit mode -&gt; low 16 bits are IP offset with the high 16 bits being reserved. See &quot;x87 FPU Instruction and Operand (Data) Pointers&quot; in Chapter 8 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for a description of the x87 FPU operand pointer.</dd>
<dt>DS</dt>
<dd>x87 FPU Instruction Operand (Data) Pointer Selector (16 bits).</dd>
<dt>MXCSR</dt>
<dd>MXCSR Register State (32 bits). See Figure 10-3 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for the layout of the MXCSR register. If the OSFXSR bit in control register CR4 is not set, the FXSAVE instruction may not save this register. This behavior is implementation dependent.</dd>
<dt>MXCSR_MASK</dt>
<dd>MXCSR_MASK (32 bits). This mask can be used to adjust values written to the MXCSR register, ensuring that reserved bits are set to 0. Set the mask bits and flags in MXCSR to the mode of operation desired for SSE and SSE2 SIMD floating-point instructions. See &quot;Guidelines for Writing to the MXCSR Register&quot; in Chapter 11 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for instructions for how to determine and use the MXCSR_MASK value.</dd>
<dt>ST0/MM0 through ST7/MM7</dt>
<dd>x87 FPU or MMX technology registers. These 80-bit fields contain the x87 FPU data registers or the MMX technology registers, depending on the state of the processor prior to the execution of the FXSAVE instruction. If the processor had been executing x87 FPU instruction prior to the FXSAVE instruction, the x87 FPU data registers are saved; if it had been executing MMX instructions (or SSE or SSE2 instructions that operated on the MMX technology registers), the MMX technology registers are saved. When the MMX technology registers are saved, the high 16 bits of the field are reserved.</dd>
<dt>XMM0 through XMM7</dt>
<dd>XMM registers (128 bits per field). If the OSFXSR bit in control register CR4 is not set, the FXSAVE instruction may not save these registers. This behavior is implementation dependent.</dd>
</dl>
<p>The FXSAVE instruction saves an abridged version of the x87 FPU tag word in the FTW field (unlike the FSAVE instruction, which saves the complete tag word). The tag information is saved in physical register order (R0 through R7), rather than in top-of-stack (TOS) order. With the FXSAVE instruction, however, only a single bit (1 for valid or 0 for empty) is saved for each tag. For example, assume that the tag word is currently set as follows:</p>
<div>
<table class="grid">
<tr><th>R7</th><th>R6</th><th>R5</th><th>R4</th><th>R3</th><th>R2</th><th>R1</th><th>R0</th></tr>
<tr><td>[body]11</td><td>xx</td><td>xx</td><td>xx</td><td>11</td><td>11</td><td>11</td><td>11[/body]</td></tr>
<tfoot>
<tr><td colspan="8">Here, 11B indicates empty stack elements and &quot;xx&quot; indicates valid (00B), zero (01B), or special (10B).</td></tr>
</tfoot>
</table>
</div>
<p>For this example, the FXSAVE instruction saves only the following 8 bits of information:</p>
<div>
<table class="grid">
<tr><th>R7</th><th>R6</th><th>R5</th><th>R4</th><th>R3</th><th>R2</th><th>R1</th><th>R0</th></tr>
<tr><td>[body]0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0[/body]</td></tr>
<tfoot>
<tr><td colspan="8">Here, a 1 is saved for any valid, zero, or special tag, and a 0 is saved for any empty tag.</td></tr>
</tfoot>
</table>
</div>
<p>The operation of the FXSAVE instruction differs from that of the FSAVE instruction, the as follows:</p>
<ul>
<li>FXSAVE instruction does not check for pending unmasked floating-point exceptions. (The FXSAVE operation in this regard is similar to the operation of the FNSAVE instruction).</li>
<li>After the FXSAVE instruction has saved the state of the x87 FPU, MMX technology, XMM, and MXCSR registers, the processor retains the contents of the registers. Because of this behavior, the FXSAVE instruction cannot be used by an application program to pass a &quot;clean&quot; x87 FPU state to a procedure, since it retains the current state. To clean the x87 FPU state, an application must explicitly execute an FINIT instruction after an FXSAVE instruction to reinitialize the x87 FPU state.</li>
<li>The format of the memory image saved with the FXSAVE instruction is the same regardless of the current addressing mode (32-bit or 16-bit) and operating mode (protected, real address, or system management). This behavior differs from the FSAVE instructions, where the memory image format is different depending on the addressing mode and operating mode. Because of the different image formats, the memory image saved with the FXSAVE instruction cannot be restored correctly with the FRSTOR instruction, and likewise the state saved with the FSAVE instruction cannot be restored correctly with the FXRSTOR instruction.</li>
</ul>
<p>Note that The FSAVE format for FTW can be recreated from the FTW valid bits and the stored 80-bit FP data (assuming the stored data was not the contents of MMX technology registers) using the following table:</p>
<div>
<table class="grid">
<caption>Recreating FSAVE Format</caption>
<tr><th>Exponent all 1's</th><th>Exponent all 0's</th><th>Fraction all 0's</th><th>J and M bits</th><th>FTW valid bit</th><th>x87 FTW</th></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0x</td><td>1</td><td>Special 10</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>1x</td><td>1</td><td>Valid 00</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>00</td><td>1</td><td>Special 10</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>10</td><td>1</td><td>Valid 00</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>0x</td><td>1</td><td>Special 10</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>1x</td><td>1</td><td>Special 10</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>00</td><td>1</td><td>Zero 01</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>10</td><td>1</td><td>Special 10</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1x</td><td>1</td><td>Special 10</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1x</td><td>1</td><td>Special 10</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>00</td><td>1</td><td>Special 10</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>10</td><td>1</td><td>Special 10</td></tr>
<tr><td>Any legal</td><td>Any legal</td><td>Any legal</td><td>Any legal</td><td>0</td><td>Empty 11</td></tr>
</table>
</div>
<p>The J-bit is defined to be the 1-bit binary integer to the left of the decimal place in the mantissa.</p>
<p>The M-bit is defined to be the most significant bit of the fractional portion of the mantissa (i.e., the bit immediately to the right of the decimal place).</p>
<p>When the M-bit is the most significant bit of the fractional portion of the mantissa, it must be 0 if the fraction is all 0's.</p>
<br />0-1</td><td>[body]11</td></tr><tr><td><strong>FXTRACT</strong><br />Extract Exponent and Mantissa<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 F4</code></td>
<td class="grid"><code>FXTRACT</code></td>
<td class="grid">Separate value in ST(0) into exponent and mantissa, store exponent in ST(0), and push the mantissa onto the register stack.</td>
</tr>
</table></td><td>
<p>Separates the source value in the ST(0) register into its exponent and mantissa, stores the exponent in ST(0), and pushes the mantissa onto the register stack. Following this operation, the new top-of-stack register ST(0) contains the value of the original mantissa expressed as a floating-point value. The sign and mantissa of this value are the same as those found in the source operand, and the exponent is 3FFFH (biased value for a true exponent of zero). The ST(1) register contains the value of the original operand's true (unbiased) exponent expressed as a floating-point value. (The operation performed by this instruction is a superset of the IEEErecommended logb(x) function.) This instruction and the F2XM1 instruction are useful for performing power and range scaling operations. The FXTRACT instruction is also useful for converting numbers in double extended-precision floating-point format to decimal representations (e.g., for printing or displaying).</p>
<p>If the floating-point zero-divide exception (#Z) is masked and the source operand is zero, an exponent value of -infinite is stored in register ST(1) and 0 with the sign of the source operand is stored in register ST(0).</p>
<br />
<pre>Temporary <span class="operator">=</span> GetMantissa<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> GetExponent<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
Top <span class="operator">=</span> Top <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> Temporary<span class="operator">;</span>
</pre>
</td><td>
<p>C1 Set to 0 if stack underflow occurred; set to 1 if stack overflow occurred.
C0, C2, C3 Undefined.
</p>
</td></tr><tr><td><strong>FYL2X</strong><br />Compute y * log_2(x)<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 F1</code></td>
<td class="grid"><code>FYL2X</code></td>
<td class="grid">Replace ST(1) with (ST(1) * log_2(ST(0))) and pop the register stack.</td>
</tr>
</table></td><td>
<p>Computes (ST(1) * log_2 (ST(0))), stores the result in resister ST(1), and pops the FPU register stack. The source operand in ST(0) must be a non-zero positive number.</p>
<p>The following table shows the results obtained when taking the log of various classes of numbers, assuming that neither overflow nor underflow occurs.</p>
<div>
<table class="grid">
<caption>FYL2X Results</caption>
<tr><td>-</td><td>ST(0): -inf</td><td>ST(0): -F</td><td>ST(0): +-0</td><td>ST(0): +0 &lt;</td><td>+F &lt; +1</td><td>+1</td><td>ST(0): +F &gt; +1</td><td>+inf</td><td>NaN</td></tr>
<tr><td>ST(1): -inf</td><td>*</td><td>*</td><td>+inf</td><td>+inf</td><td>*</td><td>-inf</td><td>-inf</td><td>NaN</td></tr>
<tr><td>ST(1): -F</td><td>*</td><td>*</td><td>**</td><td>+F</td><td>-0</td><td>-F</td><td>-inf</td><td>NaN</td></tr>
<tr><td>ST(1): -0</td><td>*</td><td>*</td><td>*</td><td>+0</td><td>-0</td><td>-0</td><td>*</td><td>NaN</td></tr>
<tr><td>ST(1): +0</td><td>*</td><td>*</td><td>*</td><td>-0</td><td>+0</td><td>+0</td><td>*</td><td>NaN</td></tr>
<tr><td>ST(1): +F</td><td>*</td><td>*</td><td>**</td><td>-F</td><td>+0</td><td>+F</td><td>+inf</td><td>NaN</td></tr>
<tr><td>ST(1): +inf</td><td>*</td><td>*</td><td>-inf</td><td>-inf</td><td>*</td><td>+inf</td><td>+inf</td><td>NaN</td></tr>
<tr><td>ST(1): NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="9">F Means finite floating-point value.</td></tr>
<tr><td colspan="9">* Indicates floating-point invalid-operation (#IA) exception.</td></tr>
<tr><td colspan="9">** Indicates floating-point zero-divide (#Z) exception.</td></tr>
</tfoot>
<tr><td>If the divide-by-zero exception is masked and register ST(0) contains +-0, the instruction returns infinite with a sign that is the opposite of the sign of the source operand in register ST(1).</td></tr>
<tr><td>The FYL2X instruction is designed with a built-in multiplication to optimize the calculation of logarithms with an arbitrary positive base (b):</td></tr>
<tr><td>[code]</td></tr>
<tr><td>log_b(x) = log_2(x) / log_2(b)</td></tr>
<tr><td>[/code]</td></tr>
</table></div><br />ST(1): -inf</td><td>
<pre>ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">*</span> log_2<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>FYL2XP1</strong><br />Compute y * log_2(x + 1)<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D9 F9</code></td>
<td class="grid"><code>FYL2XP1</code></td>
<td class="grid">Replace ST(1) with ST(1) * log_2(ST(0) + 1.0) and pop the register stack.</td>
</tr>
</table></td><td>
<p>Computes (ST(1) * log_2(ST(0) + 1.0)), stores the result in register ST(1), and pops the FPU register stack. The source operand in ST(0) must be in the range:</p>
<pre>sqrt(2) / 2 - 1 to 1 + sqrt(2) / 2
</pre>
<p>The source operand in ST(1) can range from -infinite to +infinite. If the ST(0) operand is outside of its acceptable range, the result is undefined and software should not rely on an exception being generated. Under some circumstances exceptions may be generated when ST(0) is out of range, but this behavior is implementation specific and not guaranteed.</p>
<p>The following table shows the results obtained when taking the log epsilon of various classes of numbers, assuming that underflow does not occur.</p>
<div>
<table class="grid">
<caption>FYL2XP1 Results</caption>
<tr><td>-</td><td>ST(0): -(1 - sqrt(2) / 2) to -0</td><td>-0</td><td>ST(0): +0</td><td>ST(0): +0 to +(1 - sqrt(2) / 2)</td><td>ST(0): Nan</td></tr>
<tr><td>ST(1): -inf</td><td>+inf</td><td>*</td><td>*</td><td>-inf</td><td>NaN</td></tr>
<tr><td>ST(1): -F</td><td>+F</td><td>+0</td><td>-0</td><td>-F</td><td>NaN</td></tr>
<tr><td>ST(1): -0</td><td>+0</td><td>+0</td><td>-0</td><td>-0</td><td>NaN</td></tr>
<tr><td>ST(1): +0</td><td>-0</td><td>-0</td><td>+0</td><td>+0</td><td>NaN</td></tr>
<tr><td>ST(1): +F</td><td>-F</td><td>-0</td><td>+0</td><td>+F</td><td>NaN</td></tr>
<tr><td>ST(1): +inf</td><td>-inf</td><td>*</td><td>*</td><td>+inf</td><td>NaN</td></tr>
<tr><td>ST(1): NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr>
<tfoot>
<tr><td colspan="6">F Means finite floating-point value.</td></tr>
<tr><td colspan="6">* Indicates floating-point invalid-operation (#IA) exception.</td></tr>
</tfoot>
</table>
</div>
<p>This instruction provides optimal accuracy for values of epsilon [the value in register ST(0)] that are close to 0. For small epsilon (?) values, more significant digits can be retained by using the FYL2XP1 instruction than by using (?+1) as an argument to the FYL2X instruction. The (?+1) expression is commonly found in compound interest and annuity calculations. The result can be simply converted into a value in another logarithm base by including a scale factor in the ST(1) source operand. The following equation is used to calculate the scale factor for a particular logarithm base, where n is the logarithm base desired for the result of the FYL2XP1 instruction:</p>
<pre>scale factor = log_n(2)

</pre>
<br />ST(1): -inf</td><td>
<pre>ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">=</span> ST<span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">*</span> log_2<span class="operator">(</span>ST<span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">+</span> <span class="number">1.0</span><span class="operator">)</span><span class="operator">;</span>
PopRegisterStack<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
<span class="operator">[</span>/code<span class="operator">]</span>
</pre>
</td></tr><tr><td><strong>HADDPD</strong><br />Packed Double-FP Horizontal Add<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 7C /r</code></td>
<td class="grid"><code>HADDPD xmm1, xmm2/m128</code></td>
<td class="grid">Add horizontally packed DP FP numbers from xmm2/m128 to xmm1.</td>
</tr>
</table></td><td>
<p>Adds the double-precision floating-point values in the high and low quadwords of the destination operand and stores the result in the low quadword of the destination operand.</p>
<p>Adds the double-precision floating-point values in the high and low quadwords of the source operand and stores the result in the high quadword of the destination operand.</p>
<br />
<pre>xmm1<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> xmm1<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">+</span> xmm1<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
xmm1<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> xmm2/m128<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">+</span> xmm2/m128<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
When the source operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.
</td></tr><tr><td><strong>HADDPS</strong><br />Packed Single-FP Horizontal Add<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 7C /r</code></td>
<td class="grid"><code>HADDPS xmm1, xmm2/m128</code></td>
<td class="grid">Add horizontally packed SP FP numbers from xmm2/m128 to xmm1.</td>
</tr>
</table></td><td>
<p>Adds the single-precision floating-point values in the first and second dwords of the destination operand and stores the result in the first dword of the destination operand.</p>
<p>Adds single-precision floating-point values in the third and fourth dword of the destination operand and stores the result in the second dword of the destination operand.</p>
<p>Adds single-precision floating-point values in the first and second dword of the source operand and stores the result in the third dword of the destination operand.</p>
<p>Adds single-precision floating-point values in the third and fourth dword of the source operand and stores the result in the fourth dword of the destination operand.</p>
<br />
<pre>xmm1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> xmm1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">+</span> xmm1<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
xmm1<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> xmm1<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">+</span> xmm1<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
xmm1<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> xmm2/m128<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">+</span> xmm2/m128<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
xmm1<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> xmm2/m128<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">+</span> xmm2/m128<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
When the source operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.
</td></tr><tr><td><strong>HLT</strong><br />Halt<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F4</code></td>
<td class="grid"><code>HLT</code></td>
<td class="grid">Halt.</td>
</tr>
</table></td><td>
<p>Stops instruction execution and places the processor in a HALT state. An enabled interrupt (including NMI and SMI), a debug exception, the BINIT# signal, the INIT# signal, or the RESET# signal will resume execution. If an interrupt (including NMI) is used to resume execution after a HLT instruction, the saved instruction pointer (CS:EIP) points to the instruction following the HLT instruction.</p>
<p>When a HLT instruction is executed on an IA-32 processor supporting Hyper-Threading Technology, only the logical processor that executes the instruction is halted. The other logical processors in the physical processor remain active, unless they are each individually halted by executing a HLT instruction.</p>
<p>The HLT instruction is a privileged instruction. When the processor is running in protected or virtual-8086 mode, the privilege level of a program or procedure must be 0 to execute the HLT instruction.</p>
<br />
<pre>EnterHaltstate<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>HSUBPD</strong><br />Packed Double-FP Horizontal Subtract<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 7D /r</code></td>
<td class="grid"><code>HSUBPD xmm1, xmm2/m128</code></td>
<td class="grid">Subtract horizontally packed DP FP numbers in xmm2/m128 from xmm1.</td>
</tr>
</table></td><td>
<p>The HSUBPD instruction subtracts horizontally the packed DP FP numbers of both operands.</p>
<p>Subtracts the double-precision floating-point value in the high quadword of the destination operand from the low quadword of the destination operand and stores the result in the low quadword of the destination operand.</p>
<p>Subtracts the double-precision floating-point value in the high quadword of the source operand from the low quadword of the source operand and stores the result in the high quadword of the destination operand.</p>
<br />
<pre>xmm1<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> xmm1<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">-</span> xmm1<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
xmm1<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> xmm2/m128<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">-</span> xmm2/m128<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
When the source operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.
</td></tr><tr><td><strong>HSUBPS</strong><br />Packed Single-FP Horizontal Subtract<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 7D /r</code></td>
<td class="grid"><code>HSUBPS xmm1, xmm2/m128</code></td>
<td class="grid">Subtract horizontally packed SP FP numbers in xmm2/m128 from xmm1.</td>
</tr>
</table></td><td>
<p>Subtracts the single-precision floating-point value in the second dword of the destination operand from the first dword of the destination operand and stores the result in the first dword of the destination operand.</p>
<p>Subtracts the single-precision floating-point value in the fourth dword of the destination operand from the third dword of the destination operand and stores the result in the second dword of the destination operand.</p>
<p>Subtracts the single-precision floating-point value in the second dword of the source operand from the first dword of the source operand and stores the result in the third dword of the destination operand.</p>
<p>Subtracts the single-precision floating-point value in the fourth dword of the source operand from the third dword of the source operand and stores the result in the fourth dword of the destination operand.</p>
<br />
<pre>xmm1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> xmm1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">-</span> xmm1<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
xmm1<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> xmm1<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">-</span> xmm1<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
xmm1<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> xmm2/m128<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">-</span> xmm2/m128<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
xmm1<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> xmm2/m128<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">-</span> xmm2/m128<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
When the source operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.
</td></tr><tr><td><strong>IDIV</strong><br />Signed Divide<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F6 /7</code></td>
<td class="grid"><code>IDIV r/m8</code></td>
<td class="grid">Signed divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder.</td>
</tr>
<tr>
<td class="grid"><code>F7 /7</code></td>
<td class="grid"><code>IDIV r/m16</code></td>
<td class="grid">Signed divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.</td>
</tr>
<tr>
<td class="grid"><code>F7 /7</code></td>
<td class="grid"><code>IDIV r/m32</code></td>
<td class="grid">Signed divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.</td>
</tr>
</table></td><td>
<p>Divides (signed) the value in the AX, DX:AX, or EDX:EAX registers (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, or EDX:EAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor), as shown in the following table:</p>
<div>
<table class="grid">
<caption>IDIV Results</caption>
<tr><td>[header]Operand Size</td><td>Dividend</td><td>Divisor</td><td>Quotient</td><td>Remainder</td><td>Quotient Range[/header]</td></tr>
<tr><td>Word/byte</td><td>AX</td><td>r/m8</td><td>AL</td><td>AH</td><td>-2^8 to +2^8 - 1</td></tr>
<tr><td>Doubleword/word</td><td>DX:AX</td><td>r/m16</td><td>AX</td><td>DX</td><td>-2^16 to +2^16 - 1</td></tr>
<tr><td>Quadword/doubleword</td><td>EDX:EAX</td><td>r/m32</td><td>EAX</td><td>EDX</td><td>-2^31 to +2^32 - 1</td></tr>
</table>
</div>
<p>Non-integral results are truncated (chopped) towards 0. The sign of the remainder is always the same as the sign of the dividend. The absolute value of the remainder is always less than the absolute value of the divisor. Overflow is indicated with the #DE (divide error) exception rather than with the OF (overflow) flag.</p>
<br />Word/byte</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>Source <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>DE<span class="operator">)</span><span class="operator">;</span> <span class="comment">//divide error</span>

<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">8</span><span class="operator">)</span> { <span class="comment">//word/byte operation</span>
	Temporary <span class="operator">=</span> AX / Source<span class="operator">;</span> <span class="comment">//signed division</span>
	<span class="keyword">if</span><span class="operator">(</span>Temporary <span class="operator">&gt;</span> <span class="number">0x7F</span> <span class="operator">||</span> Temporary <span class="operator">&lt;</span> <span class="number">0x80</span><span class="operator">)</span> Exception<span class="operator">(</span>DE<span class="operator">)</span><span class="operator">;</span> <span class="comment">//f a positive result is greater than 7FH or a negative result is less than 80H</span>
	<span class="keyword">else</span> {
		AL <span class="operator">=</span> Temporary<span class="operator">;</span>
		AH <span class="operator">=</span> AX <span class="operator">%</span> Source<span class="operator">;</span> <span class="comment">//signed modulus</span>
	}
}
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> { <span class="comment">//doubleword/word operation</span>
	Temporary <span class="operator">=</span> DX<span class="operator">:</span>AX / Source<span class="operator">;</span> <span class="comment">//signed division</span>
	<span class="keyword">if</span><span class="operator">(</span>Temporary <span class="operator">&gt;</span> <span class="number">0x7FFF</span> <span class="operator">||</span> Temporary <span class="operator">&lt;</span> <span class="number">0x8000</span><span class="operator">)</span> Exception<span class="operator">(</span>DE<span class="operator">)</span><span class="operator">;</span> <span class="comment">//f a positive result is greater than 7FFFH or a negative result is less than 8000H</span>
	<span class="keyword">else</span> {
		AX <span class="operator">=</span> Temporary<span class="operator">;</span>
		DX <span class="operator">=</span> DX<span class="operator">:</span>AX <span class="operator">%</span> Source<span class="operator">;</span> <span class="comment">//signed modulus</span>
	}
}
<span class="keyword">else</span> { <span class="comment">//quadword/doubleword operation</span>
	Temporary <span class="operator">=</span> EDX<span class="operator">:</span>EAX / Source<span class="operator">;</span> <span class="comment">//signed division</span>
	<span class="keyword">if</span><span class="operator">(</span>Temporary <span class="operator">&gt;</span> <span class="number">0x7FFFFFFF</span> <span class="operator">||</span> Temporary <span class="operator">&lt;</span> <span class="number">0x80000000</span><span class="operator">)</span> Exception<span class="operator">(</span>DE<span class="operator">)</span><span class="operator">;</span> <span class="comment">//f a positive result is greater than 7FFFFFFFH or a negative result is less than 80000000H</span>
	<span class="keyword">else</span> {
		EAX <span class="operator">=</span> Temporary<span class="operator">;</span>
		EDX <span class="operator">=</span> EDX<span class="operator">:</span>EAX <span class="operator">%</span> Source<span class="operator">;</span> <span class="comment">//signed modulus</span>
	}
}
</pre>
</td></tr><tr><td><strong>IMUL</strong><br />Signed Multiply<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F6 /5</code></td>
<td class="grid"><code>IMUL r/m8</code></td>
<td class="grid">AX = AL * r/m byte.</td>
</tr>
<tr>
<td class="grid"><code>F7 /5</code></td>
<td class="grid"><code>IMUL r/m16</code></td>
<td class="grid">DX:AX = AX * r/m word.</td>
</tr>
<tr>
<td class="grid"><code>F7 /5</code></td>
<td class="grid"><code>IMUL r/m32</code></td>
<td class="grid">EDX:EAX = EAX * r/m doubleword.</td>
</tr>
<tr>
<td class="grid"><code>0F AF /r</code></td>
<td class="grid"><code>IMUL r16,r/m16</code></td>
<td class="grid">word register = word register * r/m word.</td>
</tr>
<tr>
<td class="grid"><code>0F AF /r</code></td>
<td class="grid"><code>IMUL r32,r/m32</code></td>
<td class="grid">doubleword register = doubleword register * r/m doubleword.</td>
</tr>
<tr>
<td class="grid"><code>6B /r ib</code></td>
<td class="grid"><code>IMUL r16,r/m16,imm8</code></td>
<td class="grid">word register = r/m16 * sign-extended immediate byte.</td>
</tr>
<tr>
<td class="grid"><code>6B /r ib</code></td>
<td class="grid"><code>IMUL r32,r/m32,imm8</code></td>
<td class="grid">doubleword register = r/m32 * sign-extended immediate byte.</td>
</tr>
<tr>
<td class="grid"><code>6B /r ib</code></td>
<td class="grid"><code>IMUL r16,imm8</code></td>
<td class="grid">word register = word register * sign-extended immediate byte.</td>
</tr>
<tr>
<td class="grid"><code>6B /r ib</code></td>
<td class="grid"><code>IMUL r32,imm8</code></td>
<td class="grid">doubleword register = doubleword register * signextended immediate byte.</td>
</tr>
<tr>
<td class="grid"><code>69 /r iw</code></td>
<td class="grid"><code>IMUL r16,r/m16,imm16</code></td>
<td class="grid">word register = r/m16 * immediate word.</td>
</tr>
<tr>
<td class="grid"><code>69 /r id</code></td>
<td class="grid"><code>IMUL r32,r/m32,imm32</code></td>
<td class="grid">doubleword register = r/m32 * immediate doubleword.</td>
</tr>
<tr>
<td class="grid"><code>69 /r iw</code></td>
<td class="grid"><code>IMUL r16,imm16</code></td>
<td class="grid">word register = r/m16 * immediate word.</td>
</tr>
<tr>
<td class="grid"><code>69 /r id</code></td>
<td class="grid"><code>IMUL r32,imm32</code></td>
<td class="grid">doubleword register = r/m32 * immediate doubleword.</td>
</tr>
</table></td><td>
<p>Performs a signed multiplication of two operands. This instruction has three forms, depending on the number of operands.</p>
<p>- One-operand form. This form is identical to that used by the MUL instruction. Here, the source operand (in a general-purpose register or memory location) is multiplied by the value in the AL, AX, or EAX register (depending on the operand size) and the product is stored in the AX, DX:AX, or EDX:EAX registers, respectively.</p>
<p>- Two-operand form. With this form the destination operand (the first operand) is multiplied by the source operand (second operand). The destination operand is a generalpurpose register and the source operand is an immediate value, a general-purpose register, or a memory location. The product is then stored in the destination operand location.</p>
<p>- Three-operand form. This form requires a destination operand (the first operand) and two source operands (the second and the third operands). Here, the first source operand (which can be a general-purpose register or a memory location) is multiplied by the second source operand (an immediate value). The product is then stored in the destination operand (a general-purpose register).</p>
<p>When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</p>
<p>The CF and OF flags are set when significant bit (including the sign bit) are carried into the upper half of the result. The CF and OF flags are cleared when the result (including the sign bit) fits exactly in the lower half of the result.</p>
<p>The three forms of the IMUL instruction are similar in that the length of the product is calculated to twice the length of the operands. With the one-operand form, the product is stored exactly in the destination. With the two- and three- operand forms, however, the result is truncated to the length of the destination before it is stored in the destination register. Because of this truncation, the CF or OF flag should be tested to ensure that no significant bits are lost.</p>
<p>The two- and three-operand forms may also be used with unsigned operands because the lower half of the product is the same regardless if the operands are signed or unsigned. The CF and OF flags, however, cannot be used to determine if the upper half of the result is non-zero.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>NumberOfOperands<span class="operator">)</span> {
	<span class="keyword">case</span> <span class="number">1</span><span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">8</span><span class="operator">)</span> {
			AX <span class="operator">=</span> AL <span class="operator">*</span> Source<span class="operator">;</span> <span class="comment">//signed multiplication</span>
			<span class="keyword">if</span><span class="operator">(</span>AL <span class="operator">==</span> AX<span class="operator">)</span> {
				CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
				OF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			}
			<span class="keyword">else</span> {
				CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
				OF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
			}
		}
		<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> {
			DX<span class="operator">:</span>AX <span class="operator">=</span> AX <span class="operator">*</span> Source<span class="operator">;</span> <span class="comment">//signed multiplication</span>
			<span class="keyword">if</span><span class="operator">(</span>SignExtendTo32<span class="operator">(</span>AX<span class="operator">)</span> <span class="operator">==</span> DX<span class="operator">:</span>AX<span class="operator">)</span> {
				CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
				OF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			}
			<span class="keyword">else</span> {
				CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
				OF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
			}
		}
		<span class="keyword">else</span> { <span class="comment">//OperandSize == 32</span>
			EDX<span class="operator">:</span>EAX <span class="operator">=</span> EAX <span class="operator">*</span> Source<span class="operator">;</span> <span class="comment">//signed multiplication</span>
			<span class="keyword">if</span><span class="operator">(</span>EAX <span class="operator">==</span> EDX<span class="operator">:</span>EAX<span class="operator">)</span> {
				CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
				OF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			}
			<span class="keyword">else</span> {
				CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
				OF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
			}
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">2</span><span class="operator">:</span>
		Temporary <span class="operator">=</span> Destination <span class="operator">*</span> Source<span class="operator">;</span> <span class="comment">//signed multiplication; Temporary is twice twice the Destination size</span>
		Destination <span class="operator">=</span> Destination <span class="operator">*</span> Source<span class="operator">;</span> <span class="comment">//signed multiplication</span>
		<span class="keyword">if</span><span class="operator">(</span>Temporary <span class="operator">==</span> Destination<span class="operator">)</span> {
			CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			OF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
			OF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">3</span><span class="operator">:</span>
		Destination <span class="operator">=</span> Source1 <span class="operator">*</span> Source2<span class="operator">;</span> <span class="comment">//signed multiplication</span>
		Temporary <span class="operator">=</span> Source1 <span class="operator">*</span> Source2<span class="operator">;</span> <span class="comment">///signed multiplication; Temporary is twice twice the Source1 size</span>
		<span class="keyword">if</span><span class="operator">(</span>Temporary <span class="operator">==</span> Destination<span class="operator">)</span> {
			CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			OF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
			OF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>For the one operand form of the instruction, the CF and OF flags are set when significant bits are carried into the upper half of the result and cleared when the result fits exactly in the lower half of the result. For the two- and three-operand forms of the instruction, the CF and OF flags are set when the result must be truncated to fit in the destination operand size and cleared when the result fits exactly in the destination operand size. The SF, ZF, AF, and PF flags are undefined.
</p>
</td></tr><tr><td><strong>IN</strong><br />Input from Port<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>E4 ib</code></td>
<td class="grid"><code>IN AL,imm8</code></td>
<td class="grid">Input byte from imm8 I/O port address into AL.</td>
</tr>
<tr>
<td class="grid"><code>E5 ib</code></td>
<td class="grid"><code>IN AX,imm8</code></td>
<td class="grid">Input byte from imm8 I/O port address into AX.</td>
</tr>
<tr>
<td class="grid"><code>E5 ib</code></td>
<td class="grid"><code>IN EAX,imm8</code></td>
<td class="grid">Input byte from imm8 I/O port address into EAX.</td>
</tr>
<tr>
<td class="grid"><code>EC</code></td>
<td class="grid"><code>IN AL,DX</code></td>
<td class="grid">Input byte from I/O port in DX into AL.</td>
</tr>
<tr>
<td class="grid"><code>ED</code></td>
<td class="grid"><code>IN AX,DX</code></td>
<td class="grid">Input word from I/O port in DX into AX.</td>
</tr>
<tr>
<td class="grid"><code>ED</code></td>
<td class="grid"><code>IN EAX,DX</code></td>
<td class="grid">Input doubleword from I/O port in DX into EAX.</td>
</tr>
</table></td><td>
<p>Copies the value from the I/O port specified with the second operand (source operand) to the destination operand (first operand). The source operand can be a byte-immediate or the DX register; the destination operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively). Using the DX register as a source operand allows I/O port addresses from 0 to 65,535 to be accessed; using a byte immediate allows I/O port addresses 0 to 255 to be accessed.</p>
<p>When accessing an 8-bit I/O port, the opcode determines the port size; when accessing a 16- and 32-bit I/O port, the operand-size attribute determines the port size.</p>
<p>At the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0.</p>
<p>This instruction is only useful for accessing I/O ports located in the processor's I/O address space. See Chapter 13, Input/Output, in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>PE <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> CPL <span class="operator">&gt;</span> IOPL <span class="operator">||</span> VM <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> { <span class="comment">//Protected mode with CPL > IOPL or virtual-8086 mode</span>
	<span class="keyword">if</span><span class="operator">(</span>AnyPermissionBitSet<span class="operator">(</span>CurrentIOPort<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//If any I/O Permission Bit for I/O port being accessed == 1 the I/O operation is not allowed</span>
	<span class="keyword">else</span> Destination <span class="operator">=</span> Source<span class="operator">;</span> <span class="comment">//I/O operation is allowed; Reads from selected I/O port</span>
}
<span class="keyword">else</span> Destination <span class="operator">=</span> Source<span class="operator">;</span> <span class="comment">//Real Mode or Protected Mode with CPL <= IOPL; Reads from selected I/O port</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>#GP(0)</code></td><td>If the CPL is greater than (has less privilege) the I/O privilege level (IOPL) and any of the corresponding I/O permission bits in TSS for the I/O port being accessed is 1.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>INC</strong><br />Increment by 1<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>FE /0</code></td>
<td class="grid"><code>INC r/m8</code></td>
<td class="grid">Increment r/m byte by 1.</td>
</tr>
<tr>
<td class="grid"><code>FF /0</code></td>
<td class="grid"><code>INC r/m16</code></td>
<td class="grid">Increment r/m word by 1.</td>
</tr>
<tr>
<td class="grid"><code>FF /0</code></td>
<td class="grid"><code>INC r/m32</code></td>
<td class="grid">Increment r/m doubleword by 1.</td>
</tr>
<tr>
<td class="grid"><code>40+ rw</code></td>
<td class="grid"><code>INC r16</code></td>
<td class="grid">Increment word register by 1.</td>
</tr>
<tr>
<td class="grid"><code>40+ rd</code></td>
<td class="grid"><code>INC r32</code></td>
<td class="grid">Increment doubleword register by 1.</td>
</tr>
</table></td><td>
<p>Adds 1 to the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (Use a ADD instruction with an immediate operand of 1 to perform an increment operation that does updates the CF flag.) This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<br />
<pre>Destination <span class="operator">=</span> Destination <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
</pre>
</td><td>
<p>The CF flag is not affected. The OF, SF, ZF, AF, and PF flags are set according to the result.
</p>
</td></tr><tr><td><strong>INS/INSB/INSW/INSD</strong><br />Input from Port to String<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>6C INS m8, DX</code></td>
<td class="grid"><code>Input byte from I/O port specified in DX into memory location specified in ES:(E)DI.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>6D INS m16, DX</code></td>
<td class="grid"><code>Input word from I/O port specified in DX into memory location specified in ES:(E)DI.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>6D INS m32, DX</code></td>
<td class="grid"><code>Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>6C INSB</code></td>
<td class="grid"><code>Input byte from I/O port specified in DX into memory location specified with ES:(E)DI.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>6D INSW</code></td>
<td class="grid"><code>Input word from I/O port specified in DX into memory location specified in ES:(E)DI.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>6D INSD</code></td>
<td class="grid"><code>Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI.</code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Copies the data from the I/O port specified with the source operand (second operand) to the destination operand (first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The destination operand is a memory location, the address of which is read from either the ES:EDI or the ES:DI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). (The ES segment cannot be overridden with a segment override prefix.) The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operandsize attribute of the instruction for a 16- or 32-bit I/O port.</p>
<p>At the assembly-code level, two forms of this instruction are allowed: the &quot;explicit-operands&quot; form and the &quot;no-operands&quot; form. The explicit-operands form (specified with the INS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand must be &quot;DX,&quot; and the destination operand should be a symbol that indicates the size of the I/O port and the destination address. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading.</p>
<p>That is, the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers, which must be loaded correctly before the INS instruction is executed.</p>
<p>The no-operands form provides &quot;short forms&quot; of the byte, word, and doubleword versions of the INS instructions. Here also DX is assumed by the processor to be the source operand and ES:(E)DI is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic: INSB (byte), INSW (word), or INSD (doubleword).</p>
<p>After the byte, word, or doubleword is transfer from the I/O port to the memory location, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.</p>
<p>The INS, INSB, INSW, and INSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See &quot;REP/REPE/REPZ/REPNE /REPNZ-Repeat String Operation Prefix&quot; in this chapter for a description of the REP prefix.</p>
<p>These instructions are only useful for accessing I/O ports located in the processor's I/O address space. See Chapter 13, Input/Output, in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>PE <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> CPL <span class="operator">&gt;</span> IOPL <span class="operator">||</span> VM <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> { <span class="comment">//Protected mode with CPL > IOPL or virtual-8086 mode</span>
	<span class="keyword">if</span><span class="operator">(</span>AnyPermissionBitSet<span class="operator">(</span>CurrentIOPort<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//If any I/O Permission Bit for I/O port being accessed == 1 the I/O operation is not allowed</span>
	<span class="keyword">else</span> Destination <span class="operator">=</span> Source<span class="operator">;</span> <span class="comment">//I/O operation is allowed; Reads from selected I/O port</span>
}
<span class="keyword">else</span> Destination <span class="operator">=</span> Source<span class="operator">;</span> <span class="comment">//Real Mode or Protected Mode with CPL <= IOPL; Reads from selected I/O port</span>

<span class="keyword">if</span><span class="operator">(</span>IsByteTransfer<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
	<span class="keyword">else</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
}
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>IsWordTransfer<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
	<span class="keyword">else</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
}
<span class="keyword">else</span> { <span class="comment">//doubleword transfer</span>
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
	<span class="keyword">else</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>INT n/INTO/INT 3</strong><br />Call to Interrupt Procedure<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>CC</code></td>
<td class="grid"><code>INT 3</code></td>
<td class="grid">Interrupt 3 - trap to debugger.</td>
</tr>
<tr>
<td class="grid"><code>CD ib</code></td>
<td class="grid"><code>INT imm8</code></td>
<td class="grid">Interrupt vector number specified by immediate byte.</td>
</tr>
<tr>
<td class="grid"><code>CE</code></td>
<td class="grid"><code>INTO</code></td>
<td class="grid">Interrupt 4 - if overflow flag is 1.</td>
</tr>
</table></td><td>
<p>The INT n instruction generates a call to the interrupt or exception handler specified with the destination operand (see the section titled &quot;Interrupts and {exceptions}&quot; in Chapter 6 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1). The destination operand specifies an interrupt vector number from 0 to 255, encoded as an 8-bit unsigned intermediate value. Each interrupt vector number provides an index to a gate descriptor in the IDT. The first 32 interrupt vector numbers are reserved by Intel for system use. Some of these interrupts are used for internally generated exceptions.</p>
<p>The INT n instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The INTO instruction is a special mnemonic for calling overflow exception (#OF), interrupt vector number 4. The overflow interrupt checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1.</p>
<p>The INT 3 instruction generates a special one byte opcode (CC) that is intended for calling the debug exception handler. (This one byte form is valuable because it can be used to replace the first byte of any instruction with a breakpoint, including other one byte instructions, without over-writing other code). To further support its function as a debug breakpoint, the interrupt generated with the CC opcode also differs from the regular software interrupts as follows: - Interrupt redirection does not happen when in VME mode; the interrupt is handled by a protected-mode handler.</p>
<p>The virtual-8086 mode IOPL checks do not occur. The interrupt is taken without faulting at any IOPL level.</p>
<p>Note that the &quot;normal&quot; 2-byte opcode for INT 3 (CD03) does not have these special features.</p>
<p>Intel and Microsoft assemblers will not generate the CD03 opcode from any mnemonic, but this opcode can be created by direct numeric code definition or by self-modifying code.</p>
<p>The action of the INT n instruction (including the INTO and INT 3 instructions) is similar to that of a far call made with the CALL instruction. The primary difference is that with the INT n instruction, the EFLAGS register is pushed onto the stack before the return address. (The return address is a far address consisting of the current values of the CS and EIP registers.) Returns from interrupt procedures are handled with the IRET instruction, which pops the EFLAGS information and return address from the stack.</p>
<p>The interrupt vector number specifies an interrupt descriptor in the interrupt descriptor table (IDT); that is, it provides index into the IDT. The selected interrupt descriptor in turn contains a pointer to an interrupt or exception handler procedure. In protected mode, the IDT contains an array of 8-byte descriptors, each of which is an interrupt gate, trap gate, or task gate. In realaddress mode, the IDT is an array of 4-byte far pointers (2-byte code segment selector and a 2-byte instruction pointer), each of which point directly to a procedure in the selected segment.</p>
<p>(Note that in real-address mode, the IDT is called the interrupt vector table, and its pointers are called interrupt vectors.)</p>
<p>The following decision table indicates which action in the lower portion of the table is taken given the conditions in the upper portion of the table. Each Y in the lower section of the decision table represents a procedure defined in the &quot;Operation&quot; section for this instruction (except #GP).</p>
<div>
<table class="grid">
<caption>Decision Table</caption>
<tr><td>PE</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>VM</td><td>Don't care</td><td>Don't care</td><td>Don't care</td><td>Don't care</td><td>Don't care</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>IOPL</td><td>Don't care</td><td>Don't care</td><td>Don't care</td><td>Don't care</td><td>Don't care</td><td>Don't care</td><td>&lt;3</td><td>=3</td></tr>
<tr><td>DPL/CPL RELATIONSHIP</td><td>Don't care</td><td>DPL &lt; CPL</td><td>Don't care</td><td>DPL &gt; CPL</td><td>DPL = CPL or C</td><td>DPL &lt; CPL &amp; NC</td><td>Don't care</td><td>Don't care</td></tr>
<tr><td>INTERRUPT TYPE</td><td>Don't care</td><td>S/W</td><td>Don't care</td><td>Don't care</td><td>Don't care</td><td>Don't care</td><td>Don't care</td><td>Don't care</td></tr>
<tr><td>GATE TYPE</td><td>Don't care</td><td>Don't care</td><td>Task Trap or Interrupt</td><td>Trap or Interrupt</td><td>Trap or Interrupt</td><td>Trap or Interrupt</td><td>Trap or Interrupt</td></tr>
<tr><td>REAL-ADDRESS-MODE</td><td>Action taken</td><td>No action</td><td>No action</td><td>No action</td><td>No action</td><td>No action</td><td>No action</td><td>No action</td></tr>
<tr><td>PROTECTED-MODE</td><td>No action</td><td>Action taken</td><td>Action taken</td><td>Action taken</td><td>Action taken</td><td>Action taken</td><td>Action taken</td><td>Action taken</td></tr>
<tr><td>TRAP-OR-INTERRUPT-GATE</td><td>No action</td><td>No action</td><td>No action</td><td>Action taken</td><td>Action taken</td><td>Action taken</td><td>Action taken</td><td>Action taken</td></tr>
<tr><td>INTER-PRIVILEGE-LEVEL-INTERRUPT</td><td>No action</td><td>No action</td><td>No action</td><td>No action</td><td>No action</td><td>Action taken</td><td>No action</td><td>No action</td></tr>
<tr><td>INTRA-PRIVILEGE-LEVEL-INTERRUPT</td><td>No action</td><td>No action</td><td>No action</td><td>No action</td><td>Action taken</td><td>No action</td><td>No action</td><td>No action</td></tr>
<tr><td>INTERRUPT-FROM-VIRTUAL-8086-MODE</td><td>No action</td><td>No action</td><td>No action</td><td>No action</td><td>No action</td><td>No action</td><td>No action</td><td>Action taken</td></tr>
<tr><td>TASK-GATE</td><td>No action</td><td>No action</td><td>Action taken</td><td>No action</td><td>No action</td><td>No action</td><td>No action</td><td>No action</td></tr>
<tr><td>#GP</td><td>No action</td><td>Action taken</td><td>No action</td><td>Action taken</td><td>No action</td><td>No action</td><td>Action taken</td><td>No action</td></tr>
</table>
</div>
<p>When the processor is executing in virtual-8086 mode, the IOPL determines the action of the INT n instruction. If the IOPL is less than 3, the processor generates a general protection exception (#GP); if the IOPL is 3, the processor executes a protected mode interrupt to privilege level 0. The interrupt gate's DPL must be set to 3 and the target CPL of the interrupt handler procedure must be 0 to execute the protected mode interrupt to privilege level 0.</p>
<p>The interrupt descriptor table register (IDTR) specifies the base linear address and limit of the IDT. The initial base address value of the IDTR after the processor is powered up or reset is 0.</p>
<br />VM</td><td>
<pre><span class="comment">//The following operational description applies not only to the INT n and INTO instructions, but also to external interrupts and exceptions.</span>
<span class="keyword">if</span><span class="operator">(</span>pe <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinIDTLimit<span class="operator">(</span>Destination <span class="operator">*</span> <span class="number">4</span> <span class="operator">+</span> <span class="number">3</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">6</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>EFLAGS<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	IF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	TF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	AC <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	Push<span class="operator">(</span>CS<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>IP<span class="operator">)</span><span class="operator">;</span>
	CS <span class="operator">=</span> IDT<span class="operator">(</span>Descriptor<span class="operator">(</span>VectorNumber <span class="operator">*</span> <span class="number">4</span><span class="operator">)</span><span class="operator">,</span> Selector<span class="operator">)</span><span class="operator">;</span>
	EIP <span class="operator">=</span> IDT<span class="operator">(</span>Descriptor<span class="operator">(</span>VectorNumber <span class="operator">*</span> <span class="number">4</span><span class="operator">)</span><span class="operator">,</span> Offset<span class="operator">)</span><span class="operator">;</span> <span class="comment">//16 bit offset & 0xFFFF</span>
}
<span class="keyword">else</span> {
	<span class="keyword">if</span><span class="operator">(</span>VM <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> IOPL <span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&amp;&amp;</span> INT<span class="operator">(</span>n<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">else</span> { <span class="comment">//protected mode or virtual-8086 mode interrupt</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinIDTLimits<span class="operator">(</span>Destination <span class="operator">*</span> <span class="number">8</span> <span class="operator">+</span> <span class="number">7</span><span class="operator">)</span> <span class="operator">||</span> <span class="operator">!</span><span class="operator">(</span>GetCurrentIDTDescriptorType<span class="operator">(</span><span class="operator">)</span> <span class="operator">&amp;</span> <span class="operator">(</span>TYPE_INTERRUPT <span class="operator">|</span> TYPE_TRAP <span class="operator">|</span> TYPE_TASK_GATE<span class="operator">)</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Destination <span class="operator">*</span> <span class="number">8</span> <span class="operator">+</span> <span class="number">2</span> <span class="operator">+</span> EXT<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//Selected IDT descriptor is not an iterrupt-, trap-, or task-gate type; EXT is bit 0 in error code</span>
		<span class="keyword">if</span><span class="operator">(</span>IsSoftwareInterrupt<span class="operator">(</span><span class="operator">)</span> <span class="comment">/*generated by INT n, INT 3, or INTO*/</span> <span class="operator">&amp;&amp;</span> GateDescriptor<span class="operator">.</span>DPL <span class="operator">&lt;</span> CPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>VectorNumber <span class="operator">*</span> <span class="number">8</span> <span class="operator">+</span> <span class="number">2</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//PE = 1, DPL < CPL, software interrupt</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>Gate<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>VectorNumber <span class="operator">*</span> <span class="number">8</span> <span class="operator">+</span> <span class="number">2</span> <span class="operator">+</span> EXT<span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span>IsTaskGate<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
			<span class="comment">//Task-gate</span>
			<span class="comment">//PE = 1, task gate</span>
			IDTDescriptor <span class="operator">=</span> ReadSegmentSelector<span class="operator">(</span>TaskGate<span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsGlobal<span class="operator">(</span><span class="operator">)</span> <span class="operator">||</span> <span class="operator">!</span>IsWithinGDTLimits<span class="operator">(</span>Index<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>TSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			TSSDescriptor <span class="operator">=</span> AccessTSSDescriptor<span class="operator">(</span>GDT<span class="operator">.</span>TSSDescriptor<span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>TSSIsBusy<span class="operator">(</span>TSSDescriptor<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>TSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//TSS descriptor specifies that the TSS is busy (low-order 5 bits set to 00001)</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>TSSDescriptor<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>TSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			SwitchTasks<span class="operator">(</span>TSSDescriptor<span class="operator">,</span> WithNesting<span class="operator">)</span><span class="operator">;</span> <span class="comment">//Switch tasks (with nesting) to TSS</span>
			<span class="keyword">if</span><span class="operator">(</span>InterruptOccured<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> { <span class="comment">//interrupt caused by fault with error code</span>
				<span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> ErrorCodeSize<span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//stack limit does not allow push of error code</span>
				Push<span class="operator">(</span>ErrorCode<span class="operator">)</span><span class="operator">;</span>
			}
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCSLimit<span class="operator">(</span>EIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> { <span class="comment">//PE = 1, trap/interrupt gate</span>
			<span class="comment">//Trap interrupt gate</span>
			IDTDescriptor <span class="operator">=</span> ReadSegmentSelector<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>CodeSegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span> <span class="operator">+</span> EXT<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//null selector with EXT flag set</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>SegmentSelector <span class="operator">+</span> EXT<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			Descriptor <span class="operator">=</span> ReadDescriptor<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//Read trap or interrupt handler descriptor</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IndicatesCodeSegment<span class="operator">(</span>Descriptor<span class="operator">)</span> <span class="operator">||</span> CodeSegmentDescriptor<span class="operator">.</span>DPL <span class="operator">&gt;</span> CPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector <span class="operator">+</span> EXT<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>GateSegment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>Selector <span class="operator">+</span> EXT<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsConforming<span class="operator">(</span>CodeSegment<span class="operator">)</span> <span class="operator">&amp;&amp;</span> DPL <span class="operator">&lt;</span> CPL<span class="operator">)</span> {
				<span class="keyword">if</span><span class="operator">(</span>VM <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
					<span class="comment">//Inter-Privilege-Level interrupt</span>
					<span class="comment">//PE == 1, interrupt or trap gate, nonconforming</span>
					<span class="comment">//code segment, DPL < CPL, VM == 0</span>
					<span class="comment">//Check segment selector and descriptor for stack of new privilege level in current TSS</span>
					<span class="keyword">if</span><span class="operator">(</span>Is32BitTSS<span class="operator">(</span>CurrentTSS<span class="operator">)</span><span class="operator">)</span> {
						TSSStackAddress <span class="operator">=</span> NewCodSegment<span class="operator">.</span>DPL <span class="operator">*</span> <span class="number">8</span> <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
						<span class="keyword">if</span><span class="operator">(</span>TSSStackAddress <span class="operator">+</span> <span class="number">7</span> <span class="operator">&gt;</span> TSSLim9t<span class="operator">)</span> Exception<span class="operator">(</span>TS<span class="operator">(</span>CurrentTSSSelector<span class="operator">)</span><span class="operator">;</span>
						NewSS <span class="operator">=</span> TSSStackAddress <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
						NewESP <span class="operator">=</span> StackAddress<span class="operator">;</span>
					}
					<span class="keyword">else</span> { <span class="comment">//TSS is 16-bit</span>
						TSSStackAddress <span class="operator">=</span> NewCodSegment<span class="operator">.</span>DPL <span class="operator">*</span> <span class="number">4</span> <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
						<span class="keyword">if</span><span class="operator">(</span>TSSStackAddress <span class="operator">+</span> <span class="number">4</span> <span class="operator">&gt;</span> TSSLim9t<span class="operator">)</span> Exception<span class="operator">(</span>TS<span class="operator">(</span>CurrentTSSSelector<span class="operator">)</span><span class="operator">;</span>
						NewSS <span class="operator">=</span> TSSStackAddress <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
						NewESP <span class="operator">=</span> StackAddress<span class="operator">;</span>
					}
					<span class="keyword">if</span><span class="operator">(</span>SegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>TS<span class="operator">(</span>EXT<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>SegmentSelector<span class="operator">.</span>Index<span class="operator">)</span> <span class="operator">||</span> SegmentSelector<span class="operator">.</span>RPL <span class="operator">!=</span> CodeSegment<span class="operator">.</span>DPL<span class="operator">)</span> Exception<span class="operator">(</span>TS<span class="operator">(</span>SSSelector <span class="operator">+</span> EXT<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					StackSegmentDescriptor <span class="operator">=</span> ReadStackSegmentDescriptor<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>  <span class="comment">//Read segment descriptor for stack segment in GDT or LDT</span>
					<span class="keyword">if</span><span class="operator">(</span>StackSegment<span class="operator">.</span>DPL <span class="operator">!=</span> CodeSegment<span class="operator">.</span>DPL <span class="operator">||</span> <span class="operator">!</span>IndicatesWritableDataSegment<span class="operator">(</span>StackSegment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>TS<span class="operator">(</span>SSSelector <span class="operator">+</span> EXT<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>StackSegment<span class="operator">)</span><span class="operator">)</span> Excpetion<span class="operator">(</span><span class="preprocessor">#SS(SSSelector + EXT));</span>
					<span class="keyword">if</span><span class="operator">(</span>Is32BitGate<span class="operator">(</span><span class="operator">)</span> <span class="operator">&amp;&amp;</span> GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">24</span> <span class="comment">/*error code pushed*/</span> <span class="operator">||</span> GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">20</span> <span class="comment">/*no error code pushed*/</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span>SegmentSelector <span class="operator">+</span> EXT<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">else</span> <span class="comment">/*16-bit gate*/</span> <span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">12</span> <span class="comment">/*error code pushed*/</span> <span class="operator">||</span> GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">10</span> <span class="comment">/*no error code pushed*/</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span>SegmentSelector <span class="operator">+</span> EXT<span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCSLimits<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					SS<span class="operator">:</span>ESP <span class="operator">=</span> TSS<span class="operator">(</span>NewSS<span class="operator">:</span>NewESP<span class="operator">)</span> <span class="comment">//segment descriptor information also loaded</span>
					<span class="keyword">if</span><span class="operator">(</span>Is32BitGate<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
						Push<span class="operator">(</span>FarPointer<span class="operator">(</span>OldStack<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//push a far pointer to the old stack, old SS and ESP, 3 words padded to 4</span>
						Push<span class="operator">(</span>EFLAGS<span class="operator">)</span><span class="operator">;</span>
						Push<span class="operator">(</span>FarPointer<span class="operator">(</span>ReturnInstruction<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//old CS and EIP, 3 words padded to 4</span>
						Push<span class="operator">(</span>ErrorCode<span class="operator">)</span><span class="operator">;</span> <span class="comment">//if needed, 2 bytes</span>
					}
					<span class="keyword">else</span> { <span class="comment">//16-bit gate</span>
						Push<span class="operator">(</span>FarPointer<span class="operator">(</span>OldStack<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//old SS and SP, 2 words</span>
						Push<span class="operator">(</span>EFLAGS<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
						Push<span class="operator">(</span>FarPointer<span class="operator">(</span>ReturnInstruction<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//old CS and IP, 2 words</span>
						Push<span class="operator">(</span>ErrorCode<span class="operator">)</span><span class="operator">;</span> <span class="comment">//if needed, 2 bytes</span>
					}
					CPL <span class="operator">=</span> CodeSegmentDescriptor<span class="operator">.</span>DPL<span class="operator">;</span>
					CS<span class="operator">.</span>RPL <span class="operator">=</span> CPL<span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span>IsInterruptGate<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> IF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//interrupt flag set to 0: disabled</span>
					TF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
					VM <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
					RF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
					NT <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
				}
				<span class="keyword">else</span> { <span class="comment">//VM == 1</span>
					<span class="keyword">if</span><span class="operator">(</span>CodeSegment<span class="operator">.</span>DPL <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>NewCodeSegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					<span class="comment">//Interrupt from Virtual 8086 mode</span>
					<span class="comment">//PE = 1, interrupt or trap gate, DPL<CPL, VM = 1</span>
					<span class="comment">//Check segment selector and descriptor for privilege level 0 stack in current TSS</span>
					<span class="keyword">if</span><span class="operator">(</span>Is32BitTSS<span class="operator">(</span>CurrentTSS<span class="operator">)</span><span class="operator">)</span> {
						TSSStackAddress <span class="operator">=</span> NewCodeSegment<span class="operator">.</span>DPL <span class="operator">*</span> <span class="number">8</span> <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
						<span class="keyword">if</span><span class="operator">(</span>TSSStackAddress <span class="operator">+</span> <span class="number">7</span> <span class="operator">&gt;</span> TSSLimit<span class="operator">)</span> Exception<span class="operator">(</span>TS<span class="operator">(</span>CurrentTSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
						NewSS <span class="operator">=</span> TSSStackAddress <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
						NewESP <span class="operator">=</span> StackAddress<span class="operator">;</span>
					}
					<span class="keyword">else</span> { <span class="comment">//TSS is 16-bit</span>
						TSSStackAddress <span class="operator">=</span> NewCodeSegment<span class="operator">.</span>DPL <span class="operator">*</span> <span class="number">4</span> <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
						<span class="keyword">if</span><span class="operator">(</span>TSSStackAddress <span class="operator">+</span> <span class="number">4</span> <span class="operator">&gt;</span> TSSLimit<span class="operator">)</span> Excpetion<span class="operator">(</span><span class="preprocessor">#TS(CurrentTSSSelector));</span>
						NewESP <span class="operator">=</span> TSSStackAddress<span class="operator">;</span>
						NewSS <span class="operator">=</span> TSSStackAddress <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
					}
					<span class="keyword">if</span><span class="operator">(</span>SegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>TS<span class="operator">(</span>EXT<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>SegmentSelector<span class="operator">.</span>Index<span class="operator">)</span> <span class="operator">||</span> SegmentSelector<span class="operator">.</span>RPL <span class="operator">!=</span> CodeSegment<span class="operator">.</span>DPL<span class="operator">)</span> Exception<span class="operator">(</span>TS<span class="operator">(</span>SSSelector <span class="operator">+</span> EXT<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>StackSegment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span>SSSelector <span class="operator">+</span> EXT<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span>Is32BitGate<span class="operator">(</span><span class="operator">)</span> <span class="operator">&amp;&amp;</span> GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">40</span> <span class="comment">/*error code pushed*/</span> <span class="operator">||</span> GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">36</span> <span class="comment">/*no error code pushed*/</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span>SegmentSelector <span class="operator">+</span> EXT<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">else</span> <span class="comment">/*16-bit gate*/</span> <span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">20</span> <span class="comment">/*error code pushed*/</span> <span class="operator">||</span> GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">18</span> <span class="comment">/*no error code pushed*/</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span>SegmentSelector <span class="operator">+</span> EXT<span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					TemporaryEFLAGS <span class="operator">=</span> EFLAGS<span class="operator">;</span>
					VM <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
					TF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
					RF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
					NT <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span>IsInterruptGateService<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> IF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//service through interrupt gate</span>
					TemporarySS <span class="operator">=</span> SS<span class="operator">;</span>
					TemporaryESP <span class="operator">=</span> ESP<span class="operator">;</span>
					SS<span class="operator">:</span>ESP <span class="operator">=</span> TSS<span class="operator">(</span>SS0<span class="operator">:</span>ESP0<span class="operator">)</span><span class="operator">;</span> <span class="comment">//Change to level 0 stack segment</span>
					<span class="comment">//Folowing pushes are 16 bits for 16-bit gate and 32 bits for 32-bit gates</span>
					<span class="comment">//Segment selector pushes in 32-bit mode are padded to two words</span>
					Push<span class="operator">(</span>GS<span class="operator">)</span><span class="operator">;</span>
					Push<span class="operator">(</span>FS<span class="operator">)</span><span class="operator">;</span>
					Push<span class="operator">(</span>DS<span class="operator">)</span><span class="operator">;</span>
					Push<span class="operator">(</span>ES<span class="operator">)</span><span class="operator">;</span>
					Push<span class="operator">(</span>TemporarySS<span class="operator">)</span><span class="operator">;</span>
					Push<span class="operator">(</span>TemporaryESP<span class="operator">)</span><span class="operator">;</span>
					Push<span class="operator">(</span>TemporaryEFLAGS<span class="operator">)</span><span class="operator">;</span>
					Push<span class="operator">(</span>CS<span class="operator">)</span><span class="operator">;</span>
					Push<span class="operator">(</span>EIP<span class="operator">)</span><span class="operator">;</span>
					GS <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//segment registers nullified, invalid in protection mode</span>
					FS <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
					DS <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
					ES <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
					CS <span class="operator">=</span> Gate<span class="operator">(</span>CS<span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> EIP <span class="operator">=</span> Gate<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">else</span> EIP <span class="operator">=</span> Gate<span class="operator">(</span>InstructionPointer<span class="operator">)</span> <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span> <span class="comment">//OperandSize is 16</span>
					<span class="comment">//Starts execution of new routine in Protected Mode</span>
				}
			}
			<span class="keyword">else</span> { <span class="comment">//PE = 1, interrupt or trap gate, DPL >= CPL</span>
				<span class="keyword">if</span><span class="operator">(</span>VM <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>NewCodeSegmentSelector<span class="operator">)</span><span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span>IsConforming<span class="operator">(</span>CodeSegment<span class="operator">)</span> <span class="operator">||</span> CodeSegment<span class="operator">.</span>DPL <span class="operator">==</span> CPL<span class="operator">)</span> {
					<span class="comment">//Intra-privilege level interrupt</span>
					<span class="comment">//PE == 1, DPL == CPL or conforming segment</span>
					<span class="keyword">if</span><span class="operator">(</span>Is32BitGate<span class="operator">(</span><span class="operator">)</span> <span class="operator">&amp;&amp;</span> GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">16</span> <span class="comment">/*error code pushed*/</span> <span class="operator">||</span> GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">12</span> <span class="comment">/*no error code pushed*/</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">else</span> <span class="comment">/*16-bit gate*/</span> <span class="keyword">if</span><span class="operator">(</span>GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">8</span> <span class="comment">/*error code pushed*/</span> <span class="operator">||</span> GetStackSpace<span class="operator">(</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">6</span> <span class="comment">/*no error code pushed*/</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimit<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span>Is32BitGate<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
						Push<span class="operator">(</span>EFLAGS<span class="operator">)</span><span class="operator">;</span>
						Push<span class="operator">(</span>FarPointer<span class="operator">(</span>ReturnInstruction<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//3 words padded to 4</span>
						CS<span class="operator">:</span>EIP <span class="operator">=</span> Gate<span class="operator">(</span>CS<span class="operator">:</span>EIP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//segment descriptor information also loaded</span>
						Push<span class="operator">(</span>ErrorCode<span class="operator">)</span><span class="operator">;</span> <span class="comment">//if any</span>
					}
					<span class="keyword">else</span> { <span class="comment">//16-bit gate</span>
						Push<span class="operator">(</span>FLAGS<span class="operator">)</span><span class="operator">;</span>
						Push<span class="operator">(</span>FarPointer<span class="operator">(</span>ReturnLocation<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//2 words</span>
						CS<span class="operator">:</span>IP <span class="operator">=</span> Gate<span class="operator">(</span>CS<span class="operator">:</span>IP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//segment descriptor information also loaded</span>
						Push<span class="operator">(</span>ErrorCode<span class="operator">)</span><span class="operator">;</span> <span class="comment">//if any</span>
					}
					CS<span class="operator">.</span>RPL <span class="operator">=</span> CPL<span class="operator">;</span>
					<span class="keyword">if</span><span class="operator">(</span>IsInterruptGate<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> IF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//interrupt flag is set to 0: disabled</span>
					TF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
					NT <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
					VM <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
					RF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
				}
				<span class="keyword">else</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>CodeSegmentSelector <span class="operator">+</span> EXT<span class="operator">)</span><span class="operator">;</span>
			}
		}
	}
}
</pre>
</td></tr><tr><td><strong>INVD</strong><br />Invalidate Internal Caches<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 08</code></td>
<td class="grid"><code>INVD</code></td>
<td class="grid">Flush internal caches; initiate flushing of external caches.</td>
</tr>
</table></td><td>
<p>Invalidates (flushes) the processor's internal caches and issues a special-function bus cycle that directs external caches to also flush themselves. Data held in internal caches is not written back to main memory.</p>
<p>After executing this instruction, the processor does not wait for the external caches to complete their flushing operation before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache flush signal.</p>
<p>The INVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction.</p>
<p>Use this instruction with care. Data cached internally and not written back to main memory will be lost. Unless there is a specific requirement or benefit to flushing caches without writing back modified cache lines (for example, testing or fault recovery where cache coherency with main memory is not a concern), software should use the WBINVD instruction.</p>
<br />
<pre>Flush<span class="operator">(</span>InternalCaches<span class="operator">)</span><span class="operator">;</span>
SignalFlush<span class="operator">(</span>ExternalCaches<span class="operator">)</span><span class="operator">;</span>
ContinueExecution<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>INVLPG</strong><br />Invalidate TLB Entry<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 01/7</code></td>
<td class="grid"><code>INVLPG m</code></td>
<td class="grid">Invalidate TLB Entry for page that contains m.</td>
</tr>
</table></td><td>
<p>Invalidates (flushes) the translation lookaside buffer (TLB) entry specified with the source operand. The source operand is a memory address. The processor determines the page that contains that address and flushes the TLB entry for that page.</p>
<p>The INVLPG instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction.</p>
<p>The INVLPG instruction normally flushes the TLB entry only for the specified page; however, in some cases, it flushes the entire TLB. See &quot;MOV-Move to/from Control Registers&quot; in this chapter for further information on operations that flush the TLB.</p>
<br />
<pre>Flush<span class="operator">(</span>RelevantTLBEntries<span class="operator">)</span><span class="operator">;</span>
ContinueExecution<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>IRET/IRETD</strong><br />Interrupt Return<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>CF</code></td>
<td class="grid"><code>IRET</code></td>
<td class="grid">Interrupt return (16-bit operand size).</td>
</tr>
<tr>
<td class="grid"><code>CF</code></td>
<td class="grid"><code>IRETD</code></td>
<td class="grid">Interrupt return (32-bit operand size).</td>
</tr>
</table></td><td>
<p>Returns program control from an exception or interrupt handler to a program or procedure that was interrupted by an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform a return from a nested task. (A nested task is created when a CALL instruction is used to initiate a task switch or when an interrupt or exception causes a task switch to an interrupt or exception handler.) See the section titled &quot;Task Linking&quot; in Chapter 6 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3.</p>
<p>IRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt return double) is intended for use when returning from an interrupt when using the 32-bit operand size; however, most assemblers use the IRET mnemonic interchangeably for both operand sizes.</p>
<p>In Real-Address Mode, the IRET instruction preforms a far return to the interrupted program or procedure. During this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.</p>
<p>In Protected Mode, the action of the IRET instruction depends on the settings of the NT (nested task) and VM flags in the EFLAGS register and the VM flag in the EFLAGS image stored on the current stack. Depending on the setting of these flags, the processor performs the following types of interrupt returns:</p>
<ul>
<li>Return from virtual-8086 mode.</li>
<li>Return to virtual-8086 mode.</li>
<li>Intra-privilege level return.</li>
<li>Inter-privilege level return.</li>
<li>Return from nested task (task switch).</li>
</ul>
<p>If the NT flag (EFLAGS register) is cleared, the IRET instruction performs a far return from the interrupt procedure, without a task switch. The code segment being returned to must be equally or less privileged than the interrupt handler routine (as indicated by the RPL field of the code segment selector popped from the stack). As with a real-address mode interrupt return, the IRET instruction pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure. If the return is to another privilege level, the IRET instruction also pops the stack pointer and SS from the stack, before resuming program execution. If the return is to virtual-8086 mode, the processor also pops the data segment registers from the stack.</p>
<p>If the NT flag is set, the IRET instruction performs a task switch (return) from a nested task (a task called with a CALL instruction, an interrupt, or an exception) back to the calling or inter- rupted task. The updated state of the task executing the IRET instruction is saved in its TSS. If the task is re-entered later, the code that follows the IRET instruction is executed.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>PE <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
	<span class="comment">//Real-Address-Mode</span>
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>TopStackBytes<span class="operator">(</span><span class="number">12</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">)</span><span class="operator">;</span> <span class="comment">//top 12 bytes of stack not within stack limits</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		EIP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		CS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//32-bit pop, high-order 16 bits discarded</span>
		TemporaryEFLAGS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		EFLAGS <span class="operator">=</span> <span class="operator">(</span>TemporaryEFLAGS <span class="operator">&amp;</span> <span class="number">0x257FD5</span><span class="operator">)</span> <span class="operator">|</span> <span class="operator">(</span>EFLAGS <span class="operator">&amp;</span> <span class="number">0x1A0000</span><span class="operator">)</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> { <span class="comment">//OperandSize is 16</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>TopStackBytes<span class="operator">(</span><span class="number">6</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">)</span><span class="operator">;</span> <span class="comment">//top 6 bytes of stack not within stack limits</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		EIP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		EIP <span class="operator">=</span> EIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span>
		CS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//16-bit pop</span>
		EFLAGS<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	}
	<span class="comment">//END</span>
}
<span class="keyword">else</span> {
	<span class="comment">//Protected Mode</span>
	<span class="keyword">if</span><span class="operator">(</span>VM <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> {
		<span class="comment">//Virtual-8086 mode: PE == 1, VM == 1</span>
		<span class="comment">//Processor is in virtual-8086 mode when IRET is executed and stays in virtual-8086 mode</span>
		<span class="keyword">if</span><span class="operator">(</span>IOPL <span class="operator">==</span> <span class="number">3</span><span class="operator">)</span> { <span class="comment">//Virtual mode: PE=1, VM=1, IOPL=3</span>
			<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>TopStackBytes<span class="operator">(</span><span class="number">12</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//top 12 bytes of stack not within stack limits</span>
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				EIP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
				CS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//32-bit pop, high-order 16 bits discarded</span>
				EFLAGS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
				<span class="comment">//VM, IOPL, VIP and VIF EFLAGS bits are not modified by pop</span>
			}
			<span class="keyword">else</span> { <span class="comment">//OperandSize is 16</span>
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>TopStackBytes<span class="operator">(</span><span class="number">6</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//top 6 bytes of stack not within stack limits</span>
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				EIP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
				EIP <span class="operator">=</span> EIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span>
				CS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//16-bit pop</span>
				EFLAGS<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
				<span class="comment">//VM, IOPL, VIP and VIF EFLAGS bits are not modified by pop</span>
			}
		}
		<span class="keyword">else</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//trap to virtual-8086 monitor: PE == 1, VM == 1, IOPL < 3</span>
		<span class="comment">//END</span>
	}
	<span class="keyword">if</span><span class="operator">(</span>NT <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> {
		<span class="comment">//Task return</span>
		<span class="comment">//PE == 1, VM == 0, NT == 1</span>
		SegmentSelector <span class="operator">=</span> ReadSegmentSelector<span class="operator">(</span>CurrentTSS<span class="operator">.</span>LinkField<span class="operator">)</span><span class="operator">;</span> <span class="comment">//Read segment selector in link field of current TSS</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsGlobal<span class="operator">(</span><span class="operator">)</span> <span class="comment">/*local/global bit is set to local*/</span> <span class="operator">||</span> <span class="operator">!</span>IsWithinGDTLimits<span class="operator">(</span>Index<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>TS<span class="operator">(</span>TSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		TSSDescriptor <span class="operator">=</span> AccessTSS<span class="operator">(</span>CurrentTSS<span class="operator">.</span>LinkField<span class="operator">.</span>Task<span class="operator">)</span><span class="operator">;</span> <span class="comment">//Access TSS for task specified in link field of current TSS</span>
		<span class="keyword">if</span><span class="operator">(</span>TSSDescriptor<span class="operator">.</span>Type <span class="operator">!=</span> TSS <span class="operator">||</span> <span class="operator">!</span>IsBusy<span class="operator">(</span>TSS<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>TS<span class="operator">(</span>TSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>TSS<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>TSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		SwitchTasks<span class="operator">(</span>CurrenTSS<span class="operator">.</span>LinkField<span class="operator">.</span>TSS<span class="operator">,</span> WithoutNesting<span class="operator">)</span><span class="operator">;</span> <span class="comment">//Switch tasks (without nesting) to TSS specified in link field of current TSS</span>
		SetBusyState<span class="operator">(</span>AbandonedTask<span class="operator">,</span> NotBusy<span class="operator">)</span><span class="operator">;</span> <span class="comment">//Mark the task just abandoned as NOT BUSY</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimit<span class="operator">(</span>EIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		<span class="comment">//END</span>
	}
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>TopStackBytes<span class="operator">(</span><span class="number">12</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">)</span><span class="operator">;</span> <span class="comment">//top 12 bytes of stack not within stack limits</span>
		TemporaryEIP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		TemporaryCS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		TemporaryEFLAGS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> { <span class="comment">//OperandSize == 16</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>TopStackBytes<span class="operator">(</span><span class="number">6</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">)</span><span class="operator">;</span> <span class="comment">//top 6 bytes of stack not within stack limits</span>
		TemporaryEIP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		TemporaryCS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		TemporaryEFLAGS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		TemporaryEIP <span class="operator">=</span> TemporaryEIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span>
		TemporaryEFLAGS <span class="operator">=</span> TemporaryEFLAGS <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span>
	}
	<span class="keyword">if</span><span class="operator">(</span>TemporaryEFLAGS<span class="operator">.</span>VM <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> CPL <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="comment">//Interrupted procedure was in virtual-8086 mode: PE == 1, VM == 1 in flags image</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>TopStackBytes<span class="operator">(</span><span class="number">24</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//top 24 bytes of stack not within stack limits</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		CS <span class="operator">=</span> TemporaryCS<span class="operator">;</span>
		EIP <span class="operator">=</span> TemporaryEIP<span class="operator">;</span>
		EFLAGS <span class="operator">=</span> TemporaryEFLAGS<span class="operator">;</span>
		TemporaryESP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		TemporarySS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		ES <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//pop 2 words; throw away high-order word</span>
		DS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//pop 2 words; throw away high-order word</span>
		FS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//pop 2 words; throw away high-order word</span>
		GS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//pop 2 words; throw away high-order word</span>
		SS<span class="operator">:</span>ESP <span class="operator">=</span> TemporarySS<span class="operator">:</span>TemporaryESP<span class="operator">;</span>
		CPL <span class="operator">=</span> <span class="number">3</span><span class="operator">;</span>
		ResumeExecution<span class="operator">(</span><span class="operator">)</span> <span class="comment">//Resume execution in Virtual-8086 mode</span>
	}
	<span class="keyword">else</span> {
		<span class="comment">//Protected mode return</span>
		<span class="comment">//PE == 1, VM == 0 in flags image</span>
		<span class="keyword">if</span><span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentSelector<span class="operator">.</span>AddressesDescriptor<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		ReturnCode<span class="operator">.</span>SegmentDescriptor <span class="operator">=</span> ReadSegmentDescriptor<span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentSelector<span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsCodeSegment<span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentDescriptor<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL <span class="operator">&lt;</span> CPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span>IsConforming<span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentDescriptor<span class="operator">)</span> <span class="operator">&amp;&amp;</span> ReturnCode<span class="operator">.</span>Segment<span class="operator">.</span>DPL <span class="operator">&gt;</span> ReturnCode<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL <span class="operator">&gt;</span> CPL<span class="operator">)</span> {
			<span class="comment">//Return to outer privilege level</span>
			<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span> <span class="operator">&amp;&amp;</span> <span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>TopStackBytes<span class="operator">(</span><span class="number">8</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//top 8 bytes of stack not within stack limits</span>
			<span class="keyword">else</span> <span class="comment">/*OperandSize == 16*/</span> <span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>TopStackBytes<span class="operator">(</span><span class="number">4</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//top 4 bytes of stack not within stack limits</span>
			StackSegmentSelector <span class="operator">=</span> ReadReturnSegmentSelector<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>StackSegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>ReturnStackSegmentSelector<span class="operator">.</span>Index<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>SSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			SegmentDescriptor <span class="operator">=</span> ReadSegmenDescriptor<span class="operator">(</span>ReturnSegmentSelector<span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>StackSegmentSelector<span class="operator">.</span>RPL <span class="operator">!=</span> ReturnCode<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL<span class="operator">)</span> {
				<span class="keyword">if</span><span class="operator">(</span>StackSegmentSelector<span class="operator">.</span>RPL <span class="operator">!=</span> ReturnCode<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL <span class="operator">||</span> <span class="operator">!</span>IndicatesWritableDataSegment<span class="operator">(</span>StackSegmentDescriptor<span class="operator">)</span> <span class="operator">||</span> StackSegment<span class="operator">.</span>DPL <span class="operator">!=</span> ReturnCode<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>SSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>StackSegment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span>SSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			}
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimit<span class="operator">(</span>TemporaryEIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			EIP <span class="operator">=</span> TemporaryIP<span class="operator">;</span>
			CS <span class="operator">=</span> TemporaryCS<span class="operator">;</span>
			EFLAGS<span class="operator">.</span>CF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>CF<span class="operator">;</span>
			EFLAGS<span class="operator">.</span>PF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>PF<span class="operator">;</span>
			EFLAGS<span class="operator">.</span>AF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>ZF<span class="operator">;</span>
			EFLAGS<span class="operator">.</span>SF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>SF<span class="operator">;</span>
			EFLAGS<span class="operator">.</span>TF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>DF<span class="operator">;</span>
			EFLAGS<span class="operator">.</span>OF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>OF<span class="operator">;</span>
			EFLAGS<span class="operator">.</span>NT <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>NT<span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
				EFLAGS<span class="operator">.</span>RF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>RF<span class="operator">;</span>
				EFLAGS<span class="operator">.</span>AC <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>AC<span class="operator">;</span>
				EFLAGS<span class="operator">.</span>ID <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>ID<span class="operator">;</span>
			}
			<span class="keyword">if</span><span class="operator">(</span>CPL <span class="operator">&lt;=</span> IOPL<span class="operator">)</span> EFLAGS<span class="operator">.</span>IF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>IF<span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>CPL <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
				EFLAGS<span class="operator">.</span>IOPL <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>IOPL<span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
					EFLAGS<span class="operator">.</span>VM <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>VM<span class="operator">;</span>
					EFLAGS<span class="operator">.</span>VIF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>VIF<span class="operator">;</span>
					EFLAGS<span class="operator">.</span>VIP <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>VIP<span class="operator">;</span>
				}
			}
			<span class="comment">//perform operation for each of the segment registers</span>
			SegmentRegisters<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {ES<span class="operator">,</span> FS<span class="operator">,</span> GS<span class="operator">,</span> DS}<span class="operator">;</span>
			<span class="keyword">while</span><span class="operator">(</span>SegmentRegister <span class="operator">=</span> SegmentRegisters<span class="operator">.</span>Next<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> <span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>PointsToDate<span class="operator">(</span>SegmentRegister<span class="operator">)</span> <span class="operator">||</span> <span class="operator">!</span>IsConformingCodeSegment<span class="operator">(</span>SegmentRegister<span class="operator">)</span><span class="operator">)</span> <span class="operator">&amp;&amp;</span> CPL <span class="operator">&gt;</span> SegmentDescriptor<span class="operator">.</span>DPL <span class="comment">/*stored in hidden part of segment register*/</span><span class="operator">)</span> SegmentSelector <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//segment register invalid; null segment selector</span>
			<span class="comment">//END</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//Same privilege level</span>
			<span class="comment">//PE=1, VM=0 in flags image, RPL=CPL</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>EIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			EIP <span class="operator">=</span> TemporaryEIP<span class="operator">;</span>
			CS <span class="operator">=</span> TemporaryCS<span class="operator">;</span> <span class="comment">//segment descriptor information also loaded</span>
			EFLAGS<span class="operator">.</span>CF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>CF<span class="operator">;</span>
			EFLAGS<span class="operator">.</span>PF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>PF<span class="operator">;</span>
			EFLAGS<span class="operator">.</span>AF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>ZF<span class="operator">;</span>
			EFLAGS<span class="operator">.</span>SF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>SF<span class="operator">;</span>
			EFLAGS<span class="operator">.</span>TF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>DF<span class="operator">;</span>
			EFLAGS<span class="operator">.</span>OF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>OF<span class="operator">;</span>
			EFLAGS<span class="operator">.</span>NT <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>NT<span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
				EFLAGS<span class="operator">.</span>RF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>RF<span class="operator">;</span>
				EFLAGS<span class="operator">.</span>AC <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>AC<span class="operator">;</span>
				EFLAGS<span class="operator">.</span>ID <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>ID<span class="operator">;</span>
			}
			<span class="keyword">if</span><span class="operator">(</span>CPL <span class="operator">&lt;=</span> IOPL<span class="operator">)</span> EFLAGS<span class="operator">.</span>IF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>IF<span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>CPL <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
				EFLAGS<span class="operator">.</span>IOPL <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>IOPL<span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
					EFLAGS<span class="operator">.</span>VM <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>VM<span class="operator">;</span>
					EFLAGS<span class="operator">.</span>VIF <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>VIF<span class="operator">;</span>
					EFLAGS<span class="operator">.</span>VIP <span class="operator">=</span> TemporaryEFLAGS<span class="operator">.</span>VIP<span class="operator">;</span>
				}
			}
			<span class="comment">//END</span>
		}
	}
}
</pre>
</td><td>
<p>All the flags and fields in the EFLAGS register are potentially modified, depending on the mode of operation of the processor. If performing a return from a nested task to a previous task, the EFLAGS register will be modified according to the EFLAGS image stored in the previous task's TSS.
</p>
</td></tr><tr><td><strong>Jcc</strong><br />Jump if Condition Is Met<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>77 cb</code></td>
<td class="grid"><code>JA rel8</code></td>
<td class="grid">Jump short if above (CF=0 and ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>73 cb</code></td>
<td class="grid"><code>JAE rel8</code></td>
<td class="grid">Jump short if above or equal (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>72 cb</code></td>
<td class="grid"><code>JB rel8</code></td>
<td class="grid">Jump short if below (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>76 cb</code></td>
<td class="grid"><code>JBE rel8</code></td>
<td class="grid">Jump short if below or equal (CF=1 or ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>72 cb</code></td>
<td class="grid"><code>JC rel8</code></td>
<td class="grid">Jump short if carry (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>E3 cb</code></td>
<td class="grid"><code>JCXZ rel8</code></td>
<td class="grid">Jump short if CX register is 0.</td>
</tr>
<tr>
<td class="grid"><code>E3 cb</code></td>
<td class="grid"><code>JECXZ rel8</code></td>
<td class="grid">Jump short if ECX register is 0.</td>
</tr>
<tr>
<td class="grid"><code>74 cb</code></td>
<td class="grid"><code>JE rel8</code></td>
<td class="grid">Jump short if equal (ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>7F cb</code></td>
<td class="grid"><code>JG rel8</code></td>
<td class="grid">Jump short if greater (ZF=0 and SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>7D cb</code></td>
<td class="grid"><code>JGE rel8</code></td>
<td class="grid">Jump short if greater or equal (SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>7C cb</code></td>
<td class="grid"><code>JL rel8</code></td>
<td class="grid">Jump short if less (SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>7E cb</code></td>
<td class="grid"><code>JLE rel8</code></td>
<td class="grid">Jump short if less or equal (ZF=1 or SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>76 cb</code></td>
<td class="grid"><code>JNA rel8</code></td>
<td class="grid">Jump short if not above (CF=1 or ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>72 cb</code></td>
<td class="grid"><code>JNAE rel8</code></td>
<td class="grid">Jump short if not above or equal (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>73 cb</code></td>
<td class="grid"><code>JNB rel8</code></td>
<td class="grid">Jump short if not below (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>77 cb</code></td>
<td class="grid"><code>JNBE rel8</code></td>
<td class="grid">Jump short if not below or equal (CF=0 and ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>73 cb</code></td>
<td class="grid"><code>JNC rel8</code></td>
<td class="grid">Jump short if not carry (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>75 cb</code></td>
<td class="grid"><code>JNE rel8</code></td>
<td class="grid">Jump short if not equal (ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>7E cb</code></td>
<td class="grid"><code>JNG rel8</code></td>
<td class="grid">Jump short if not greater (ZF=1 or SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>7C cb</code></td>
<td class="grid"><code>JNGE rel8</code></td>
<td class="grid">Jump short if not greater or equal (SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>7D cb</code></td>
<td class="grid"><code>JNL rel8</code></td>
<td class="grid">Jump short if not less (SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>7F cb</code></td>
<td class="grid"><code>JNLE rel8</code></td>
<td class="grid">Jump short if not less or equal (ZF=0 and SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>71 cb</code></td>
<td class="grid"><code>JNO rel8</code></td>
<td class="grid">Jump short if not overflow (OF=0).</td>
</tr>
<tr>
<td class="grid"><code>7B cb</code></td>
<td class="grid"><code>JNP rel8</code></td>
<td class="grid">Jump short if not parity (PF=0).</td>
</tr>
<tr>
<td class="grid"><code>79 cb</code></td>
<td class="grid"><code>JNS rel8</code></td>
<td class="grid">Jump short if not sign (SF=0).</td>
</tr>
<tr>
<td class="grid"><code>75 cb</code></td>
<td class="grid"><code>JNZ rel8</code></td>
<td class="grid">Jump short if not zero (ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>70 cb</code></td>
<td class="grid"><code>JO rel8</code></td>
<td class="grid">Jump short if overflow (OF=1).</td>
</tr>
<tr>
<td class="grid"><code>7A cb</code></td>
<td class="grid"><code>JP rel8</code></td>
<td class="grid">Jump short if parity (PF=1).</td>
</tr>
<tr>
<td class="grid"><code>7A cb</code></td>
<td class="grid"><code>JPE rel8</code></td>
<td class="grid">Jump short if parity even (PF=1).</td>
</tr>
<tr>
<td class="grid"><code>7B cb</code></td>
<td class="grid"><code>JPO rel8</code></td>
<td class="grid">Jump short if parity odd (PF=0).</td>
</tr>
<tr>
<td class="grid"><code>78 cb</code></td>
<td class="grid"><code>JS rel8</code></td>
<td class="grid">Jump short if sign (SF=1).</td>
</tr>
<tr>
<td class="grid"><code>74 cb</code></td>
<td class="grid"><code>JZ rel8</code></td>
<td class="grid">Jump short if zero (ZF = 1).</td>
</tr>
<tr>
<td class="grid"><code>0F 87 cw/cd</code></td>
<td class="grid"><code>JA rel16/32</code></td>
<td class="grid">Jump near if above (CF=0 and ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 83 cw/cd</code></td>
<td class="grid"><code>JAE rel16/32</code></td>
<td class="grid">Jump near if above or equal (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 82 cw/cd</code></td>
<td class="grid"><code>JB rel16/32</code></td>
<td class="grid">Jump near if below (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 86 cw/cd</code></td>
<td class="grid"><code>JBE rel16/32</code></td>
<td class="grid">Jump near if below or equal (CF=1 or ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 82 cw/cd</code></td>
<td class="grid"><code>JC rel16/32</code></td>
<td class="grid">Jump near if carry (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 84 cw/cd</code></td>
<td class="grid"><code>JE rel16/32</code></td>
<td class="grid">Jump near if equal (ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 84 cw/cd</code></td>
<td class="grid"><code>JZ rel16/32</code></td>
<td class="grid">Jump near if 0 (ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 8F cw/cd</code></td>
<td class="grid"><code>JG rel16/32</code></td>
<td class="grid">Jump near if greater (ZF=0 and SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 8D cw/cd</code></td>
<td class="grid"><code>JGE rel16/32</code></td>
<td class="grid">Jump near if greater or equal (SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 8C cw/cd</code></td>
<td class="grid"><code>JL rel16/32</code></td>
<td class="grid">Jump near if less (SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 8E cw/cd</code></td>
<td class="grid"><code>JLE rel16/32</code></td>
<td class="grid">Jump near if less or equal (ZF=1 or SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 86 cw/cd</code></td>
<td class="grid"><code>JNA rel16/32</code></td>
<td class="grid">Jump near if not above (CF=1 or ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 82 cw/cd</code></td>
<td class="grid"><code>JNAE rel16/32</code></td>
<td class="grid">Jump near if not above or equal (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 83 cw/cd</code></td>
<td class="grid"><code>JNB rel16/32</code></td>
<td class="grid">Jump near if not below (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 87 cw/cd</code></td>
<td class="grid"><code>JNBE rel16/32</code></td>
<td class="grid">Jump near if not below or equal (CF=0 and ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 83 cw/cd</code></td>
<td class="grid"><code>JNC rel16/32</code></td>
<td class="grid">Jump near if not carry (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 85 cw/cd</code></td>
<td class="grid"><code>JNE rel16/32</code></td>
<td class="grid">Jump near if not equal (ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 8E cw/cd</code></td>
<td class="grid"><code>JNG rel16/32</code></td>
<td class="grid">Jump near if not greater (ZF=1 or SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 8C cw/cd</code></td>
<td class="grid"><code>JNGE rel16/32</code></td>
<td class="grid">Jump near if not greater or equal (SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 8D cw/cd</code></td>
<td class="grid"><code>JNL rel16/32</code></td>
<td class="grid">Jump near if not less (SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 8F cw/cd</code></td>
<td class="grid"><code>JNLE rel16/32</code></td>
<td class="grid">Jump near if not less or equal (ZF=0 and SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 81 cw/cd</code></td>
<td class="grid"><code>JNO rel16/32</code></td>
<td class="grid">Jump near if not overflow (OF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 8B cw/cd</code></td>
<td class="grid"><code>JNP rel16/32</code></td>
<td class="grid">Jump near if not parity (PF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 89 cw/cd</code></td>
<td class="grid"><code>JNS rel16/32</code></td>
<td class="grid">Jump near if not sign (SF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 85 cw/cd</code></td>
<td class="grid"><code>JNZ rel16/32</code></td>
<td class="grid">Jump near if not zero (ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 80 cw/cd</code></td>
<td class="grid"><code>JO rel16/32</code></td>
<td class="grid">Jump near if overflow (OF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 8A cw/cd</code></td>
<td class="grid"><code>JP rel16/32</code></td>
<td class="grid">Jump near if parity (PF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 8A cw/cd</code></td>
<td class="grid"><code>JPE rel16/32</code></td>
<td class="grid">Jump near if parity even (PF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 8B cw/cd</code></td>
<td class="grid"><code>JPO rel16/32</code></td>
<td class="grid">Jump near if parity odd (PF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 88 cw/cd</code></td>
<td class="grid"><code>JS rel16/32</code></td>
<td class="grid">Jump near if sign (SF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 84 cw/cd</code></td>
<td class="grid"><code>JZ rel16/32</code></td>
<td class="grid">Jump near if 0 (ZF=1).</td>
</tr>
</table></td><td>
<p>Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.</p>
<p>The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.</p>
<p>The conditions for each Jcc mnemonic are given in the &quot;{description}&quot; column of the table on the preceding page. The terms &quot;less&quot; and &quot;greater&quot; are used for comparisons of signed integers and the terms &quot;above&quot; and &quot;below&quot; are used for unsigned integers.</p>
<p>Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.</p>
<p>The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal: JZ FARLABEL; To accomplish this far jump, use the following two instructions: JNZ BEYOND; JMP FARLABEL; BEYOND: The JECXZ and JCXZ instructions differ from the other Jcc instructions because they do not check the status flags. Instead they check the contents of the ECX and CX registers, respectively, for 0. Either the CX or ECX register is chosen according to the address-size attribute.</p>
<p>These instructions are useful at the beginning of a conditional loop that terminates with a conditional loop instruction (such as LOOPNE). They prevent entering the loop when the ECX or CX register is equal to 0, which would cause the loop to execute 232 or 64K times, respectively, instead of zero times.</p>
<p>All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cacheability.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Condition <span class="operator">==</span> <span class="keyword">true</span><span class="operator">)</span> {
	EIP <span class="operator">=</span> EIP <span class="operator">+</span> SignExtend<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> EIP <span class="operator">=</span> EIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span>
	<span class="keyword">else</span> <span class="comment">/*OperandSize == 32*/</span> <span class="keyword">if</span><span class="operator">(</span>EIP <span class="operator">&lt;</span> CS<span class="operator">.</span>Base <span class="operator">||</span> EIP <span class="operator">&gt;</span> CS<span class="operator">.</span>Limit<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">)</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>JMP</strong><br />Jump<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>EB cb</code></td>
<td class="grid"><code>JMP rel8</code></td>
<td class="grid">Jump short, relative, displacement relative to next instruction.</td>
</tr>
<tr>
<td class="grid"><code>E9 cw</code></td>
<td class="grid"><code>JMP rel16</code></td>
<td class="grid">Jump near, relative, displacement relative to next instruction.</td>
</tr>
<tr>
<td class="grid"><code>E9 cd</code></td>
<td class="grid"><code>JMP rel32</code></td>
<td class="grid">Jump near, relative, displacement relative to next instruction.</td>
</tr>
<tr>
<td class="grid"><code>FF /4</code></td>
<td class="grid"><code>JMP r/m16</code></td>
<td class="grid">Jump near, absolute indirect, address given in r/m16.</td>
</tr>
<tr>
<td class="grid"><code>FF /4</code></td>
<td class="grid"><code>JMP r/m32</code></td>
<td class="grid">Jump near, absolute indirect, address given in r/m32.</td>
</tr>
<tr>
<td class="grid"><code>EA cd</code></td>
<td class="grid"><code>JMP ptr16:16</code></td>
<td class="grid">Jump far, absolute, address given in operand.</td>
</tr>
<tr>
<td class="grid"><code>EA cp</code></td>
<td class="grid"><code>JMP ptr16:32</code></td>
<td class="grid">Jump far, absolute, address given in operand.</td>
</tr>
<tr>
<td class="grid"><code>FF /5</code></td>
<td class="grid"><code>JMP m16:16</code></td>
<td class="grid">Jump far, absolute indirect, address given in m16:16.</td>
</tr>
<tr>
<td class="grid"><code>FF /5</code></td>
<td class="grid"><code>JMP m16:32</code></td>
<td class="grid">Jump far, absolute indirect, address given in m16:32.</td>
</tr>
</table></td><td>
<p>Transfers program control to a different point in the instruction stream without recording return information. The destination (target) operand specifies the address of the instruction being jumped to. This operand can be an immediate value, a general-purpose register, or a memory location.</p>
<p>This instruction can be used to execute four different types of jumps: - Near jump-A jump to an instruction within the current code segment (the segment currently pointed to by the CS register), sometimes referred to as an intrasegment jump.</p>
<dl>
<dt>Short jump</dt>
<dd>A near jump where the jump range is limited to -128 to +127 from the current EIP value.</dd>
<dt>Far jump</dt>
<dd>A jump to an instruction located in a different segment than the current code segment but at the same privilege level, sometimes referred to as an intersegment jump.</dd>
<dt>Task switch</dt>
<dd>A jump to an instruction located in a different task.</dd>
</dl>
<p>A task switch can only be executed in protected mode (see Chapter 6, Task Management, in the IA-32 Intel Architecture Software Developer's Manual, Volume 3, for information on performing task switches with the JMP instruction).</p>
<p>Near and Short Jumps. When executing a near jump, the processor jumps to the address (within the current code segment) that is specified with the target operand. The target operand specifies either an absolute offset (that is an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current value of the instruction pointer in the EIP register). A near jump to a relative offset of 8-bits (rel8) is referred to as a short jump. The CS register is not changed on near and short jumps.</p>
<p>An absolute offset is specified indirectly in a general-purpose register or a memory location (r/m16 or r/m32). The operand-size attribute determines the size of the target operand (16 or 32 bits). Absolute offsets are loaded directly into the EIP register. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.</p>
<p>A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed 8-, 16-, or 32-bit immediate value. This value is added to the value in the EIP register. (Here, the EIP register contains the address of the instruction following the JMP instruction). When using relative offsets, the opcode (for short vs.</p>
<p>near jumps) and the operand-size attribute (for near relative jumps) determines the size of the target operand (8, 16, or 32 bits).</p>
<p>Far Jumps in Real-Address or Virtual-8086 Mode. When executing a far jump in realaddress or virtual-8086 mode, the processor jumps to the code segment and offset specified with the target operand. Here the target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). With the pointer method, the segment and address of the called procedure is encoded in the instruction, using a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address immediate.</p>
<p>With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address. The far address is loaded directly into the CS and EIP registers. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared.</p>
<p>Far Jumps in Protected Mode. When the processor is operating in protected mode, the JMP instruction can be used to perform the following three types of far jumps:</p>
<ul>
<li>A far jump to a conforming or non-conforming code segment.</li>
<li>A far jump through a call gate.</li>
<li>A task switch.</li>
</ul>
<p>(The JMP instruction cannot be used to perform inter-privilege-level far jumps.) In protected mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate, task gate, or TSS) and access rights determine the type of jump to be performed.</p>
<p>If the selected descriptor is for a code segment, a far jump to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far jump to the same privilege level in protected mode is very similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The operandsize attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into CS register, and the offset from the instruction is loaded into the EIP register. Note that a call gate (described in the next paragraph) can also be used to perform far call to a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making jumps between 16-bit and 32-bit code segments.</p>
<p>When executing a far jump through a call gate, the segment selector specified by the target operand identifies the call gate. (The offset part of the target operand is ignored.) The processor then jumps to the code segment specified in the call gate descriptor and begins executing the instruction at the offset specified in the call gate. No stack switch occurs. Here again, the target operand can specify the far address of the call gate either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32).</p>
<p>Executing a task switch with the JMP instruction is somewhat similar to executing a jump through a call gate. Here the target operand specifies the segment selector of the task gate for the task being switched to (and the offset part of the target operand is ignored). The task gate in turn points to the TSS for the task, which contains the segment selectors for the task's code and stack segments. The TSS also contains the EIP value for the next instruction that was to be executed before the task was suspended. This instruction pointer value is loaded into the EIP register so that the task begins executing again at this next instruction.</p>
<p>The JMP instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of the task gate. See Chapter 6, Task Management, in IA-32 Intel Architecture Software Developer's Manual, Volume 3, for detailed information on the mechanics of a task switch.</p>
<p>Note that when you execute at task switch with a JMP instruction, the nested task flag (NT) is not set in the EFLAGS register and the new TSS's previous task link field is not loaded with the old task's TSS selector. A return to the previous task can thus not be carried out by executing the IRET instruction. Switching tasks with the JMP instruction differs in this regard from the CALL instruction which does set the NT flag and save the previous task link information, allowing a return to the calling task with an IRET instruction.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>IsNearJump<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>IsRelativeJump<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> TemporaryEIP <span class="operator">=</span> EIP <span class="operator">+</span> Destination<span class="operator">;</span> <span class="comment">//EIP is instruction following JMP instruction;</span>
	<span class="keyword">else</span> TemporaryEIP <span class="operator">==</span> Destination<span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>TemporaryEIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> EIP <span class="operator">=</span> TemporaryEIP<span class="operator">;</span>
	<span class="keyword">else</span> EIP <span class="operator">=</span> TemporaryEIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span> <span class="comment">//OperandSize == 16</span>
	<span class="comment">//END</span>
}

<span class="keyword">if</span><span class="operator">(</span>IsFarJump<span class="operator">(</span><span class="operator">)</span> <span class="operator">&amp;&amp;</span> <span class="operator">(</span>PE <span class="operator">==</span> <span class="number">0</span> <span class="operator">||</span> <span class="operator">(</span>PE <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> VM <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span><span class="operator">)</span> { <span class="comment">//real-address or virtual-8086 mode</span>
	TemporaryEIP <span class="operator">=</span> Destination<span class="operator">.</span>Offset<span class="operator">;</span> <span class="comment">//Destination is ptr16:32 or [m16:32]</span>
	<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>TemporaryEIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	CS <span class="operator">=</span> Destination<span class="operator">.</span>SegmentSelector<span class="operator">;</span> <span class="comment">//Destination ptr16:32 [m16:32]</span>
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> EIP <span class="operator">=</span> TemporaryEIP<span class="operator">;</span> <span class="comment">//Destination ptr16:32 [m16:32]</span>
	<span class="keyword">else</span> <span class="comment">/*OperandSize == 16*/</span> EIP <span class="operator">=</span> TemporaryEIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span> <span class="comment">//clear upper 16 bits;</span>
	<span class="comment">//END</span>
}

<span class="keyword">if</span><span class="operator">(</span>IsFarJump<span class="operator">(</span><span class="operator">)</span> <span class="operator">&amp;&amp;</span> PE <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> VM <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> { <span class="comment">//Protected mode, not virtual-8086 mode</span>
	SegmentsToCheck<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {CS<span class="operator">,</span> DS<span class="operator">,</span> ES<span class="operator">,</span> FS<span class="operator">,</span> GS<span class="operator">,</span> SS}<span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>CheckEffectiveAddresses<span class="operator">(</span>SegmentsToCheck<span class="operator">)</span> <span class="operator">||</span> TargetOperand<span class="operator">.</span>SegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//effective address in the CS, DS, ES, FS, GS, or SS segment is illegal</span>
	<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>SegmentSelector<span class="operator">.</span>Index<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>NewSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	SegmentDescriptorData <span class="operator">=</span> ReadSegmentDescriptorData<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//Read type and access rights of segment descriptor</span>
	<span class="keyword">switch</span><span class="operator">(</span>SegmentDescriptorData<span class="operator">.</span>Type<span class="operator">)</span> {
		<span class="keyword">case</span> TypeConformingCodeSegment<span class="operator">:</span>
			<span class="keyword">if</span><span class="operator">(</span>DPL <span class="operator">&gt;</span> CPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>Segment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			TemporaryEIP <span class="operator">=</span> Destination<span class="operator">.</span>Offset<span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> TemporaryEIP <span class="operator">=</span> TemporaryEIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>isWithinCodeSegmentLimits<span class="operator">(</span>TemporaryEIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			CS <span class="operator">=</span> Destination<span class="operator">.</span>SegmentSelector<span class="operator">;</span> <span class="comment">//segment descriptor information also loaded</span>
			CS<span class="operator">.</span>RPL <span class="operator">=</span> CPL<span class="operator">;</span>
			EIP <span class="operator">=</span> TemporaryEIP<span class="operator">;</span>
			<span class="keyword">break</span><span class="operator">;</span>
		<span class="keyword">case</span> TypeNonConformingCodeSegment<span class="operator">:</span>
			<span class="keyword">if</span><span class="operator">(</span>RPL <span class="operator">&gt;</span> CPL <span class="operator">||</span> DPL <span class="operator">!=</span> CPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>CodeSegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>Segment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			TemporaryEIP <span class="operator">=</span> Destination<span class="operator">.</span>Offset<span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> TemporaryEIP <span class="operator">=</span> TemporaryEIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>TemporaryEIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			CS <span class="operator">=</span> Destination<span class="operator">.</span>SegmentSelector<span class="operator">;</span> <span class="comment">//segment descriptor information also loaded</span>
			CS<span class="operator">.</span>RPL <span class="operator">=</span> CPL<span class="operator">;</span>
			EIP <span class="operator">=</span> TemporaryEIP<span class="operator">;</span>
			<span class="keyword">break</span><span class="operator">;</span>
		<span class="keyword">case</span> TypeCallGate<span class="operator">:</span>
			<span class="keyword">if</span><span class="operator">(</span>CallGate<span class="operator">.</span>DPL <span class="operator">&lt;</span> CPL <span class="operator">||</span> CallGate<span class="operator">.</span>DPL <span class="operator">&lt;</span> CallGate<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>CallGate<span class="operator">.</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>CallGate<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>CallGate<span class="operator">.</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>CallGate<span class="operator">.</span>CodeSegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			CodeSegmentDescriptor <span class="operator">=</span> ReadCodeSegmentDescriptor<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IndicatesCodeSegment<span class="operator">(</span>CodeSegmentDescriptor<span class="operator">)</span> <span class="operator">||</span> <span class="operator">(</span>IsConforming<span class="operator">(</span>CodeSegmentDescriptor<span class="operator">)</span> <span class="operator">&amp;&amp;</span> DPL <span class="operator">&gt;</span> CPL<span class="operator">)</span> <span class="operator">||</span> <span class="operator">(</span><span class="operator">!</span>IsConforming<span class="operator">(</span>CodeSegmentDescriptor<span class="operator">)</span> <span class="operator">&amp;&amp;</span> DPL <span class="operator">!=</span> CPL<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>CodeSegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>CodeSegment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>CodeSegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>InstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			TemporaryEIP <span class="operator">=</span> Destination<span class="operator">.</span>Offset<span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>GateSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> TemporaryEIP <span class="operator">=</span> TemporaryEIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>TemporaryEIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			CS <span class="operator">=</span> Destination<span class="operator">.</span>SegmentSelector<span class="operator">;</span> <span class="comment">//segment descriptor information also loaded</span>
			CS<span class="operator">.</span>RPL <span class="operator">=</span> CPL<span class="operator">;</span>
			EIP <span class="operator">=</span> TemporaryEIP<span class="operator">;</span>
			<span class="keyword">break</span><span class="operator">;</span>
		<span class="keyword">case</span> TypeTaskGate<span class="operator">:</span>
			<span class="keyword">if</span><span class="operator">(</span>TaskGate<span class="operator">.</span>DPL <span class="operator">&lt;</span> CPL <span class="operator">||</span> TaskGate<span class="operator">.</span>DPL <span class="operator">&lt;</span> TaskGate<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>TaskGate<span class="operator">.</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>TaskGate<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>TaskGate<span class="operator">.</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			TSSSegmentSelector <span class="operator">=</span> ReadTSSSegmentSelector<span class="operator">(</span>TaskGateDescriptor<span class="operator">)</span><span class="operator">;</span> <span class="comment">//Read the TSS segment selector in the task-gate descriptor;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsGlobal<span class="operator">(</span>TSSSegmentSelector<span class="operator">)</span> <span class="comment">/*TSS segment selector local/global bit is set to local*/</span> <span class="operator">||</span> <span class="operator">!</span>IsWithinGDTLimits<span class="operator">(</span>Index<span class="operator">)</span> <span class="operator">||</span> TSSIsBusy<span class="operator">(</span>TSSDescriptor<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>TSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>TSS<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>TSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			SwitchTasks<span class="operator">(</span>TSS<span class="operator">)</span><span class="operator">;</span> <span class="comment">//Switch tasks to TSS</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimit<span class="operator">(</span>EIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">break</span><span class="operator">;</span>
		<span class="keyword">case</span> TypeTaskStateSegment<span class="operator">:</span>
			<span class="keyword">if</span><span class="operator">(</span>TSS<span class="operator">.</span>DPL <span class="operator">&lt;</span> CPL <span class="operator">||</span> TSS<span class="operator">.</span>DPL <span class="operator">&lt;</span> TSS<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL <span class="operator">||</span> <span class="operator">!</span>TSSIsAvailable<span class="operator">(</span>TSSDescriptor<span class="operator">)</span> <span class="comment">/*TSS descriptor indicates that TSS is not available*/</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>TSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>TSS<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>TSSSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			SwitchTasks<span class="operator">(</span>TSS<span class="operator">)</span><span class="operator">;</span> <span class="comment">//Switch tasks to TSS</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimit<span class="operator">(</span>EIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">break</span><span class="operator">;</span>
		<span class="keyword">default</span><span class="operator">:</span>
			Exception<span class="operator">(</span>GP<span class="operator">(</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	}
}
<span class="keyword">else</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>All flags are affected if a task switch occurs; no flags are affected if a task switch does not occur.
</p>
</td></tr><tr><td><strong>LAHF</strong><br />Load Status Flags into AH Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>9F</code></td>
<td class="grid"><code>LAHF</code></td>
<td class="grid">Load: AH = EFLAGS(SF:ZF:0:AF:0:PF:1:CF).</td>
</tr>
</table></td><td>
<p>Moves the low byte of the EFLAGS register (which includes status flags SF, ZF, AF, PF, and CF) to the AH register. Reserved bits 1, 3, and 5 of the EFLAGS register are set in the AH register as shown in the &quot;Operation&quot; section below.</p>
<br />
<pre>AH <span class="operator">=</span> EFLAGS<span class="operator">(</span>SF<span class="operator">:</span>ZF<span class="operator">:</span><span class="number">0</span><span class="operator">:</span>AF<span class="operator">:</span><span class="number">0</span><span class="operator">:</span>PF<span class="operator">:</span><span class="number">1</span><span class="operator">:</span>CF<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>None (that is, the state of the flags in the EFLAGS register is not affected).
</p>
</td></tr><tr><td><strong>LAR</strong><br />Load Access Rights Byte<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 02 /r</code></td>
<td class="grid"><code>LAR r16,r/m16</code></td>
<td class="grid">r16 = r/m16 masked by FF00H.</td>
</tr>
<tr>
<td class="grid"><code>0F 02 /r</code></td>
<td class="grid"><code>LAR r32,r/m32</code></td>
<td class="grid">r32 = r/m32 masked by 00FxFF00H.</td>
</tr>
</table></td><td>
<p>Loads the access rights from the segment descriptor specified by the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the EFLAGS register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. The destination operand is a general-purpose register.</p>
<p>The processor performs access checks as part of the loading process. Once loaded in the destination register, software can perform additional checks on the access rights information.</p>
<p>When the operand size is 32 bits, the access rights for a segment descriptor include the type and DPL fields and the S, P, AVL, D/B, and G flags, all of which are located in the second doubleword (bytes 4 through 7) of the segment descriptor. The doubleword is masked by 00FXFF00H before it is loaded into the destination operand. When the operand size is 16 bits, the access rights include the type and DPL fields. Here, the two lower-order bytes of the doubleword are masked by FF00H before being loaded into the destination operand.</p>
<p>This instruction performs the following checks before it loads the access rights in the destination register:</p>
<ul>
<li>Checks that the segment selector is not null.</li>
<li>Checks that the segment selector points to a descriptor that is within the limits of the GDT or LDT being accessed - Checks that the descriptor type is valid for this instruction. All code and data segment descriptors are valid for (can be accessed with) the LAR instruction. The valid system segment and gate descriptor types are given in Table 3-53.</li>
<li>If the segment is not a conforming code segment, it checks that the specified segment descriptor is visible at the CPL (that is, if the CPL and the RPL of the segment selector are less than or equal to the DPL of the segment selector).</li>
</ul>
<p>If the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no access rights are loaded in the destination operand.</p>
<p>The LAR instruction can only be executed in protected mode.</p>
<div>
<table class="grid">
<caption>Segment and Gate Types</caption>
<tr><th>Type</th><th>Name</th><th>Valid</th></tr>
<tr><td>0</td><td>Reserved</td><td>No</td></tr>
<tr><td>1</td><td>Available 16-bit TSS</td><td>Yes</td></tr>
<tr><td>2</td><td>LDT</td><td>Yes</td></tr>
<tr><td>3</td><td>Busy 16-bit TSS</td><td>Yes</td></tr>
<tr><td>4</td><td>16-bit call gate</td><td>Yes</td></tr>
<tr><td>5</td><td>16-bit/32-bit task gate</td><td>Yes</td></tr>
<tr><td>6</td><td>16-bit interrupt gate</td><td>No</td></tr>
<tr><td>7</td><td>16-bit trap gate</td><td>No</td></tr>
<tr><td>8</td><td>Reserved</td><td>No</td></tr>
<tr><td>9</td><td>Available 32-bit TSS</td><td>Yes</td></tr>
<tr><td>A</td><td>Reserved</td><td>No</td></tr>
<tr><td>B</td><td>Busy 32-bit TSS</td><td>Yes</td></tr>
<tr><td>C</td><td>32-bit call gate</td><td>Yes</td></tr>
<tr><td>D</td><td>Reserved</td><td>No</td></tr>
<tr><td>E</td><td>32-bit interrupt gate</td><td>No</td></tr>
<tr><td>F</td><td>32-bit trap gate</td><td>No</td></tr>
</table>
</div>
<br />0</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>Source<span class="operator">.</span>Offset <span class="operator">&gt;</span> DescriptorTableLimit<span class="operator">)</span> ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
SegmentDescriptor <span class="operator">=</span> ReadSegmentDescriptor<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>SegmentDescriptor<span class="operator">.</span>Type <span class="operator">!=</span> TypeConformingCodeSegment <span class="operator">&amp;&amp;</span> CPL <span class="operator">&gt;</span> DPL <span class="operator">||</span> RPL <span class="operator">&gt;</span> DPL <span class="operator">||</span> <span class="operator">!</span>CheckInstructionValidity<span class="operator">(</span>SegmentDescriptor<span class="operator">.</span>Type<span class="operator">)</span> <span class="comment">/*Segment type is not valid for instruction*/</span><span class="operator">)</span> ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
<span class="keyword">else</span> {
	<span class="comment">//Source: segment relative offset</span>
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> Destination <span class="operator">=</span> Source <span class="operator">&amp;</span> <span class="number">0xF</span>XFF00<span class="operator">;</span> <span class="comment">//X: undefined?</span>
	<span class="keyword">else</span> Destination <span class="operator">=</span> Source <span class="operator">&amp;</span> <span class="number">0xFF00</span><span class="operator">;</span> <span class="comment">//OperandSize == 16</span>
}
</pre>
</td></tr><tr><td><strong>LDDQU</strong><br />Load Unaligned Integer 128 Bits<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F F0 /r</code></td>
<td class="grid"><code>LDDQU xmm, mem</code></td>
<td class="grid">Load data from mem and return 128 bits in an xmm register.</td>
</tr>
</table></td><td>
<p>The instruction is functionally similar to MOVDQU xmm, m128 for loading from memory. That is: 16 bytes of data starting at an address specified by the source memory operand (second operand) are fetched from memory and placed in a destination register (first operand). The source operand need not be aligned on a 16-byte boundary. Up to 32 bytes may be loaded from memory; this is implementation dependent.</p>
<p>This instruction may improve performance relative to MOVDQU if the source operand crosses a cache line boundary. In situations that require the data loaded by LDDQU be modified and stored to the same location, use MOVDQU or MOVDQA instead of LDDQU. To move a double quadword to or from memory locations that are known to be aligned on 16-byte boundaries, use the MOVDQA instruction.</p>
<p>Implementation Notes - If the source is aligned to a 16-byte boundary, based on the implementation, the 16 bytes may be loaded more than once. For that reason, the usage of LDDQU should be avoided when using uncached or write-combining (WC) memory regions. For uncached or WC memory regions, keep using MOVDQU.</p>
<p>- This instruction is a replacement for MOVDQU (load) in situations where cache line splits significantly affect performance. It should not be used in situations where store-load forwarding is performance critical. If performance of store-load forwarding is critical to the application, use MOVDQA store-load pairs when data is 128-bit aligned or MOVDQU store-load pairs when data is 128-bit unaligned.</p>
<p>- If the memory address is not aligned on 16-byte boundary, some implementations may load up to 32 bytes and return 16 bytes in the destination. Some processor implementations may issue multiple loads to access the appropriate 16 bytes. Developers of multi-threaded or multi-processor software should be aware that on these processors the loads will be performed in a non-atomic way.</p>
<br />
<pre>xmm<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">=</span> m128<span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>LDMXCSR</strong><br />Load MXCSR Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F AE /2</code></td>
<td class="grid"><code>LDMXCSR m32</code></td>
<td class="grid">Load MXCSR register from m32.</td>
</tr>
</table></td><td>
<p>Loads the source operand into the MXCSR control/status register. The source operand is a 32- bit memory location. See &quot;MXCSR Control and Status Register&quot; in Chapter 10, of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for a description of the MXCSR register and its contents.</p>
<p>The LDMXCSR instruction is typically used in conjunction with the STMXCSR instruction, which stores the contents of the MXCSR register in memory.</p>
<p>The default MXCSR value at reset is 1F80H.</p>
<p>If a LDMXCSR instruction clears an SIMD floating-point exception mask bit and sets the corresponding exception flag bit, an SIMD floating-point exception will not be immediately generated.</p>
<p>The exception will be generated only upon the execution of the next SSE or SSE2 instruction that causes that particular SIMD floating-point exception to be reported.</p>
<br />
<pre>MXCSR <span class="operator">=</span> m32<span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>LDS/LES/LFS/LGS/LSS</strong><br />Load Far Pointer<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>C5 /r</code></td>
<td class="grid"><code>LDS r16,m16:16</code></td>
<td class="grid">Load DS:r16 with far pointer from memory.</td>
</tr>
<tr>
<td class="grid"><code>C5 /r</code></td>
<td class="grid"><code>LDS r32,m16:32</code></td>
<td class="grid">Load DS:r32 with far pointer from memory.</td>
</tr>
<tr>
<td class="grid"><code>0F B2 /r</code></td>
<td class="grid"><code>LSS r16,m16:16</code></td>
<td class="grid">Load SS:r16 with far pointer from memory.</td>
</tr>
<tr>
<td class="grid"><code>0F B2 /r</code></td>
<td class="grid"><code>LSS r32,m16:32</code></td>
<td class="grid">Load SS:r32 with far pointer from memory.</td>
</tr>
<tr>
<td class="grid"><code>C4 /r</code></td>
<td class="grid"><code>LES r16,m16:16</code></td>
<td class="grid">Load ES:r16 with far pointer from memory.</td>
</tr>
<tr>
<td class="grid"><code>C4 /r</code></td>
<td class="grid"><code>LES r32,m16:32</code></td>
<td class="grid">Load ES:r32 with far pointer from memory.</td>
</tr>
<tr>
<td class="grid"><code>0F B4 /r</code></td>
<td class="grid"><code>LFS r16,m16:16</code></td>
<td class="grid">Load FS:r16 with far pointer from memory.</td>
</tr>
<tr>
<td class="grid"><code>0F B4 /r</code></td>
<td class="grid"><code>LFS r32,m16:32</code></td>
<td class="grid">Load FS:r32 with far pointer from memory.</td>
</tr>
<tr>
<td class="grid"><code>0F B5 /r</code></td>
<td class="grid"><code>LGS r16,m16:16</code></td>
<td class="grid">Load GS:r16 with far pointer from memory.</td>
</tr>
<tr>
<td class="grid"><code>0F B5 /r</code></td>
<td class="grid"><code>LGS r32,m16:32</code></td>
<td class="grid">Load GS:r32 with far pointer from memory.</td>
</tr>
</table></td><td>
<p>Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16-bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS, SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand.</p>
<p>If one of these instructions is executed in protected mode, additional information from the segment descriptor pointed to by the segment selector in the source operand is loaded in the hidden part of the selected segment register.</p>
<p>Also in protected mode, a null selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers without causing a protection exception. (Any subsequent reference to a segment whose corresponding segment register is loaded with a null selector, causes a generalprotection exception (#GP) and no memory reference to the segment occurs.)</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>IsProtectedMode<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>IsLoaded<span class="operator">(</span>SS<span class="operator">)</span><span class="operator">)</span> {
		<span class="keyword">if</span><span class="operator">(</span>SegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>SegmentSelector<span class="operator">.</span>Index<span class="operator">)</span> <span class="operator">||</span> SegmentSelector<span class="operator">.</span>RPL <span class="operator">!=</span> CPL <span class="operator">||</span> <span class="operator">!</span>IndicatesWritableDataSegment<span class="operator">(</span>SegmentSelector<span class="operator">)</span> <span class="operator">||</span> DPL <span class="operator">!=</span> CPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>Segment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		SS <span class="operator">=</span> SegmentSelector<span class="operator">.</span>Source<span class="operator">;</span>
		SS <span class="operator">=</span> SegmentDescriptor<span class="operator">.</span>Source<span class="operator">;</span> <span class="comment">//Source: segment relative offset</span>
	}
	<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>IsLoaded<span class="operator">(</span>DS<span class="operator">)</span> <span class="operator">||</span> IsLoaded<span class="operator">(</span>ES<span class="operator">)</span> <span class="operator">||</span> IsLoaded<span class="operator">(</span>FS<span class="operator">)</span> <span class="operator">||</span> IsLoaded<span class="operator">(</span>GS<span class="operator">)</span><span class="operator">)</span> <span class="operator">&amp;&amp;</span> SegmentSelector <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> { <span class="comment">//DS, ES, FS, or GS is loaded with non-null segment selector</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>SegmentSelector<span class="operator">.</span>Index<span class="operator">)</span> <span class="operator">||</span> IsData<span class="operator">(</span>SegmentSelector<span class="operator">)</span> <span class="operator">||</span> IsReadableCodeSegment<span class="operator">(</span>SegmentSelector<span class="operator">)</span> <span class="operator">||</span> <span class="operator">(</span>IsData<span class="operator">(</span>Segment<span class="operator">)</span> <span class="operator">||</span> <span class="operator">!</span>IsConformingCodeSegment<span class="operator">(</span>Segment<span class="operator">)</span> <span class="operator">&amp;&amp;</span> RPL <span class="operator">&gt;</span> DPL <span class="operator">&amp;&amp;</span> CPL <span class="operator">&gt;</span> DPL<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>Segment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		SegmentRegister <span class="operator">=</span> SegmentSelector<span class="operator">.</span>Source <span class="operator">&amp;</span> RPL<span class="operator">;</span>
		SegmentRegister <span class="operator">=</span> SegmenDescriptor<span class="operator">.</span>Source<span class="operator">;</span> <span class="comment">//Source: segment relative offset</span>
	}
	<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>IsLoaded<span class="operator">(</span>DS<span class="operator">)</span> <span class="operator">||</span> IsLoaded<span class="operator">(</span>ES<span class="operator">)</span> <span class="operator">||</span> IsLoaded<span class="operator">(</span>FS<span class="operator">)</span> <span class="operator">||</span> IsLoaded<span class="operator">(</span>GS<span class="operator">)</span><span class="operator">)</span> <span class="operator">&amp;&amp;</span> SegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> { <span class="comment">//DS, ES, FS, or GS is loaded with a null selector</span>
		SegmentRegister <span class="operator">=</span> NullSelector<span class="operator">;</span>
		SegmentRegister<span class="operator">.</span>DescriptorValidBit <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//hidden flag, not accessible by software</span>
	}
}
<span class="keyword">if</span><span class="operator">(</span>IsRealAddressMode<span class="operator">(</span><span class="operator">)</span> <span class="operator">||</span> IsVirtual8086Mode<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> SegmentRegister <span class="operator">=</span> SegmentSelector<span class="operator">.</span>Source<span class="operator">;</span>
Destination <span class="operator">=</span> Offset<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>LEA</strong><br />Load Effective Address<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>8D /r</code></td>
<td class="grid"><code>LEA r16,m</code></td>
<td class="grid">Store effective address for m in register r16.</td>
</tr>
<tr>
<td class="grid"><code>8D /r</code></td>
<td class="grid"><code>LEA r32,m</code></td>
<td class="grid">Store effective address for m in register r32.</td>
</tr>
</table></td><td>
<p>Computes the effective address of the second operand (the source operand) and stores it in the first operand (destination operand). The source operand is a memory address (offset part) specified with one of the processors addressing modes; the destination operand is a general-purpose register. The address-size and operand-size attributes affect the action performed by this instruction, as shown in the following table. The operand-size attribute of the instruction is determined by the chosen register; the address-size attribute is determined by the attribute of the code segment.</p>
<div>
<table class="grid">
<caption>Address and Operand Size Attributes</caption>
<tr><th>Operand Size</th><th>Address Size</th><th>Action Performed</th></tr>
<tr><td>16</td><td>16</td><td>16-bit effective address is calculated and stored in requested 16-bit register destination.</td></tr>
<tr><td>16</td><td>32</td><td>32-bit effective address is calculated. The lower 16 bits of the address are stored in the requested 16-bit register destination.</td></tr>
<tr><td>32</td><td>16</td><td>16-bit effective address is calculated. The 16-bit address is zeroextended and stored in the requested 32-bit register destination.</td></tr>
<tr><td>32</td><td>32</td><td>32-bit effective address is calculated and stored in the requested 32-bit register destination.</td></tr>
</table>
</div>
<p>Different assemblers may use different algorithms based on the size attribute and symbolic reference of the source operand.</p>
<br />16</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span> <span class="operator">&amp;&amp;</span> AddressSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> Destination <span class="operator">=</span> EffectiveAddress<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span> <span class="comment">//16-bit address</span>
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span> <span class="operator">&amp;&amp;</span> AddressSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
	Temporary <span class="operator">=</span> EffectiveAddress<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span> <span class="comment">//32-bit address</span>
	Destination <span class="operator">=</span> Temporary<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span> <span class="comment">//16-bit address</span>
}
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span> <span class="operator">&amp;&amp;</span> AddressSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> {
	Temporary <span class="operator">=</span> EffectiveAddress<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span> <span class="comment">//16-bit address;</span>
	Destination <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Temporary<span class="operator">)</span><span class="operator">;</span> <span class="comment">//32-bit address</span>
}
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span> <span class="operator">&amp;&amp;</span> AddressSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> Destination <span class="operator">=</span> EffectiveAddress<span class="operator">(</span>Source<span class="operator">)</span> <span class="comment">//32-bit address</span>
</pre>
</td></tr><tr><td><strong>LEAVE</strong><br />High Level Procedure Exit<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>C9</code></td>
<td class="grid"><code>LEAVE</code></td>
<td class="grid">Set SP to BP, then pop BP.</td>
</tr>
<tr>
<td class="grid"><code>C9</code></td>
<td class="grid"><code>LEAVE</code></td>
<td class="grid">Set ESP to EBP, then pop EBP.</td>
</tr>
</table></td><td>
<p>Releases the stack frame set up by an earlier ENTER instruction. The LEAVE instruction copies the frame pointer (in the EBP register) into the stack pointer register (ESP), which releases the stack space allocated to the stack frame. The old frame pointer (the frame pointer for the calling procedure that was saved by the ENTER instruction) is then popped from the stack into the EBP register, restoring the calling procedure's stack frame.</p>
<p>A RET instruction is commonly executed following a LEAVE instruction to return program control to the calling procedure.</p>
<p>See &quot;Procedure Calls for Block-Structured Languages&quot; in Chapter 6 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for detailed information on the use of the ENTER and LEAVE instructions.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>StackAddressSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> ESP <span class="operator">=</span> EBP<span class="operator">;</span>
<span class="keyword">else</span> SP <span class="operator">=</span> BP<span class="operator">;</span> <span class="comment">//StackAddressSize = 16</span>

<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> EBP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">else</span> BP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//OperandSize == 16</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>LFENCE</strong><br />Load Fence<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F AE /5</code></td>
<td class="grid"><code>LFENCE</code></td>
<td class="grid">Serializes load operations.</td>
</tr>
</table></td><td>
<p>Performs a serializing operation on all load-from-memory instructions that were issued prior the LFENCE instruction. This serializing operation guarantees that every load instruction that precedes in program order the LFENCE instruction is globally visible before any load instruction that follows the LFENCE instruction is globally visible. The LFENCE instruction is ordered with respect to load instructions, other LFENCE instructions, any MFENCE instructions, and any serializing instructions (such as the CPUID instruction). It is not ordered with respect to store instructions or the SFENCE instruction.</p>
<p>Weakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue and speculative reads. The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data. The LFENCE instruction provides a performance-efficient way of insuring load ordering between routines that produce weakly-ordered results and routines that consume that data.</p>
<p>It should be noted that processors are free to speculatively fetch and cache data from system memory regions that are assigned a memory-type that permits speculative reads (that is, the WB, WC, and WT memory types). The PREFETCHh instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, the LFENCE instruction is not ordered with respect to PREFETCHh instructions or any other speculative fetching mechanism (that is, data could be speculative loaded into the cache just before, during, or after the execution of an LFENCE instruction).</p>
<br />
<pre>WaitOnLoads<span class="operator">(</span>PrecedingLoadsGloballyVisible<span class="operator">)</span><span class="operator">;</span> <span class="comment">//wait on following loads until preceding loads are globally visible</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>LGDT/LIDT</strong><br />Load Global/Interrupt Descriptor Table Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 01 /2</code></td>
<td class="grid"><code>LGDT m16&amp;32</code></td>
<td class="grid">Load m into GDTR.</td>
</tr>
<tr>
<td class="grid"><code>0F 01 /3</code></td>
<td class="grid"><code>LIDT m16&amp;32</code></td>
<td class="grid">Load m into IDTR.</td>
</tr>
</table></td><td>
<p>Loads the values in the source operand into the global descriptor table register (GDTR) or the interrupt descriptor table register (IDTR). The source operand specifies a 6-byte memory location that contains the base address (a linear address) and the limit (size of table in bytes) of the global descriptor table (GDT) or the interrupt descriptor table (IDT). If operand-size attribute is 32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data operand) and a 32-bit base address (upper 4 bytes of the data operand) are loaded into the register. If the operand-size attribute is 16 bits, a 16-bit limit (lower 2 bytes) and a 24-bit base address (third, fourth, and fifth byte) are loaded. Here, the high-order byte of the operand is not used and the high-order byte of the base address in the GDTR or IDTR is filled with zeros.</p>
<p>The LGDT and LIDT instructions are used only in operating-system software; they are not used in application programs. They are the only instructions that directly load a linear address (that is, not a segment-relative address) and a limit in protected mode. They are commonly executed in real-address mode to allow processor initialization prior to switching to protected mode.</p>
<p>See &quot;SGDT-Store Global Descriptor Table Register&quot; in Chapter 4 for information on storing the contents of the GDTR and IDTR.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> LIDT<span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> {
		IDT<span class="operator">.</span>Limit <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
		IDTR<span class="operator">.</span>Base <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..47</span><span class="operator">]</span> <span class="operator">&amp;</span> <span class="number">0xFFFFFF</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> { <span class="comment">//OperandSize == 32</span>
		IDTR<span class="operator">.</span>Limit <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
		IDTR<span class="operator">.</span>Base <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..47</span><span class="operator">]</span><span class="operator">;</span>
	}
}
<span class="keyword">else</span> { <span class="comment">//Instruction == LGDT</span>
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> {
		GDT<span class="operator">.</span>Limit <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
		GDTR<span class="operator">.</span>Base <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..47</span><span class="operator">]</span> <span class="operator">&amp;</span> <span class="number">0xFFFFFF</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> { <span class="comment">//OperandSize == 32</span>
		GDTR<span class="operator">.</span>Limit <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
		GDTR<span class="operator">.</span>Base <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..47</span><span class="operator">]</span><span class="operator">;</span>
	}
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>LLDT</strong><br />Load Local Descriptor Table Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 00 /2</code></td>
<td class="grid"><code>LLDT r/m16</code></td>
<td class="grid">Load segment selector r/m16 into LDTR.</td>
</tr>
</table></td><td>
<p>Loads the source operand into the segment selector field of the local descriptor table register (LDTR). The source operand (a general-purpose register or a memory location) contains a segment selector that points to a local descriptor table (LDT). After the segment selector is loaded in the LDTR, the processor uses the segment selector to locate the segment descriptor for the LDT in the global descriptor table (GDT). It then loads the segment limit and base address for the LDT from the segment descriptor into the LDTR. The segment registers DS, ES, SS, FS, GS, and CS are not affected by this instruction, nor is the LDTR field in the task state segment (TSS) for the current task.</p>
<p>If the source operand is 0, the LDTR is marked invalid and all references to descriptors in the LDT (except by the LAR, VERR, VERW or LSL instructions) cause a general protection exception (#GP).</p>
<p>The operand-size attribute has no effect on this instruction.</p>
<p>The LLDT instruction is provided for use in operating-system software; it should not be used in application programs. Also, this instruction can only be executed in protected mode.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimit<span class="operator">(</span>Source<span class="operator">.</span>Offset<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>

SegmentDescriptor <span class="operator">=</span> ReadSegmentDescriptor<span class="operator">;</span>

<span class="keyword">if</span><span class="operator">(</span>SegmentDescriptor<span class="operator">.</span>Type <span class="operator">!=</span> LDT<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>SegmentDescriptor<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>

LDTR<span class="operator">.</span>SegmentSelector <span class="operator">=</span> Source<span class="operator">;</span>
LDTR<span class="operator">.</span>SegmentDescriptor <span class="operator">=</span> GDTSegmentDescriptor<span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>LMSW</strong><br />Load Machine Status Word<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 01 /6</code></td>
<td class="grid"><code>LMSW r/m16</code></td>
<td class="grid">Loads r/m16 in machine status word of CR0.</td>
</tr>
</table></td><td>
<p>Loads the source operand into the machine status word, bits 0 through 15 of register CR0. The source operand can be a 16-bit general-purpose register or a memory location. Only the loworder 4 bits of the source operand (which contains the PE, MP, EM, and TS flags) are loaded into CR0. The PG, CD, NW, AM, WP, NE, and ET flags of CR0 are not affected. The operandsize attribute has no effect on this instruction.</p>
<p>If the PE flag of the source operand (bit 0) is set to 1, the instruction causes the processor to switch to protected mode. While in protected mode, the LMSW instruction cannot be used to clear the PE flag and force a switch back to real-address mode.</p>
<p>The LMSW instruction is provided for use in operating-system software; it should not be used in application programs. In protected or virtual-8086 mode, it can only be executed at CPL 0.</p>
<p>This instruction is provided for compatibility with the Intel 286&Atilde;&cent;&acirc;&Acirc;&cent; processor; programs and procedures intended to run on the Pentium 4, Intel Xeon, P6 family, Pentium, Intel486, and Intel386 processors should use the MOV (control registers) instruction to load the whole CR0 register. The MOV CR0 instruction can be used to set and clear the PE flag in CR0, allowing a procedure or program to switch between protected and real-address modes.</p>
<p>This instruction is a serializing instruction.</p>
<br />
<pre>CR0<span class="operator">[</span><span class="number">0..3</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..3</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>LOCK</strong><br />Assert LOCK# Signal Prefix<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F0</code></td>
<td class="grid"><code>LOCK</code></td>
<td class="grid">Asserts LOCK# signal for duration of the accompanying</td>
</tr>
</table></td><td>
<p>Causes the processor's LOCK# signal to be asserted during execution of the accompanying instruction (turns the instruction into an atomic instruction). In a multiprocessor environment, the LOCK# signal insures that the processor has exclusive use of any shared memory while the signal is asserted.</p>
<p>Note that in later IA-32 processors (including the Pentium 4, Intel Xeon, and P6 family processors), locking may occur without the LOCK# signal being asserted. See IA-32 Architecture Compatibility below.</p>
<p>The LOCK prefix can be prepended only to the following instructions and only to those forms of the instructions where the destination operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG. If the LOCK prefix is used with one of these instructions and the source operand is a memory operand, an undefined opcode exception (#UD) may be generated. An undefined opcode exception will also be generated if the LOCK prefix is used with any instruction not in the above list. The XCHG instruction always asserts the LOCK# signal regardless of the presence or absence of the LOCK prefix.</p>
<p>The LOCK prefix is typically used with the BTS instruction to perform a read-modify-write operation on a memory location in shared memory environment.</p>
<p>The integrity of the LOCK prefix is not affected by the alignment of the memory field. Memory locking is observed for arbitrarily misaligned fields.</p>
<br />
<pre>AssertLOCK<span class="operator">(</span>DurationOfAccompaningInstruction<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
instruction.
</p>
</td></tr><tr><td><strong>LODS/LODSB/LODSW/LODSD</strong><br />Load String<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>AC</code></td>
<td class="grid"><code>LODS m8</code></td>
<td class="grid">Load byte at address DS:(E)SI into AL.</td>
</tr>
<tr>
<td class="grid"><code>AD</code></td>
<td class="grid"><code>LODS m16</code></td>
<td class="grid">Load word at address DS:(E)SI into AX.</td>
</tr>
<tr>
<td class="grid"><code>AD</code></td>
<td class="grid"><code>LODS m32</code></td>
<td class="grid">Load doubleword at address DS:(E)SI into EAX.</td>
</tr>
<tr>
<td class="grid"><code>AC</code></td>
<td class="grid"><code>LODSB</code></td>
<td class="grid">Load byte at address DS:(E)SI into AL.</td>
</tr>
<tr>
<td class="grid"><code>AD</code></td>
<td class="grid"><code>LODSW</code></td>
<td class="grid">Load word at address DS:(E)SI into AX.</td>
</tr>
<tr>
<td class="grid"><code>AD</code></td>
<td class="grid"><code>LODSD</code></td>
<td class="grid">Load doubleword at address DS:(E)SI into EAX.</td>
</tr>
</table></td><td>
<p>Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The source operand is a memory location, the address of which is read from the DS:EDI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be overridden with a segment override prefix.</p>
<p>At the assembly-code level, two forms of this instruction are allowed: the &quot;explicit-operands&quot; form and the &quot;no-operands&quot; form. The explicit-operands form (specified with the LODS mnemonic) allows the source operand to be specified explicitly. Here, the source operand should be a symbol that indicates the size and location of the source value. The destination operand is then automatically selected to match the size of the source operand (the AL register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location.</p>
<p>The location is always specified by the DS:(E)SI registers, which must be loaded correctly before the load string instruction is executed.</p>
<p>The no-operands form provides &quot;short forms&quot; of the byte, word, and doubleword versions of the LODS instructions. Here also DS:(E)SI is assumed to be the source operand and the AL, AX, or EAX register is assumed to be the destination operand. The size of the source and destination operands is selected with the mnemonic: LODSB (byte loaded into register AL), LODSW (word loaded into AX), or LODSD (doubleword loaded into EAX).</p>
<p>After the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.</p>
<p>The LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because further processing of the data moved into the register is usually necessary before the next transfer can be made. See &quot;REP/REPE/REPZ/REPNE /REPNZ-Repeat String Operation Prefix&quot; in Chapter 4 for a description of the REP prefix.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>IsByteOperation<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	AL <span class="operator">=</span> Source<span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
	<span class="keyword">else</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
}
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>IsWordOperation<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	AX <span class="operator">=</span> Source<span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
	<span class="keyword">else</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
}
<span class="keyword">else</span> { <span class="comment">//doubleword transfer</span>
	EAX <span class="operator">=</span> Source<span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
	<span class="keyword">else</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>LOOP/LOOPcc</strong><br />Loop According to ECX Counter<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>E2 cb</code></td>
<td class="grid"><code>LOOP rel8</code></td>
<td class="grid">Decrement count; jump short if count != 0.</td>
</tr>
<tr>
<td class="grid"><code>E1 cb</code></td>
<td class="grid"><code>LOOPE rel8</code></td>
<td class="grid">Decrement count; jump short if count != 0 and ZF=1.</td>
</tr>
<tr>
<td class="grid"><code>E1 cb</code></td>
<td class="grid"><code>LOOPZ rel8</code></td>
<td class="grid">Decrement count; jump short if count != 0 and ZF=1.</td>
</tr>
<tr>
<td class="grid"><code>E0 cb</code></td>
<td class="grid"><code>LOOPNE rel8</code></td>
<td class="grid">Decrement count; jump short if count != 0 and ZF=0.</td>
</tr>
<tr>
<td class="grid"><code>E0 cb</code></td>
<td class="grid"><code>LOOPNZ rel8</code></td>
<td class="grid">Decrement count; jump short if count != 0 and ZF=0.</td>
</tr>
</table></td><td>
<p>Performs a loop operation using the ECX or CX register as a counter. Each time the LOOP instruction is executed, the count register is decremented, then checked for 0. If the count is 0, the loop is terminated and program execution continues with the instruction following the LOOP instruction. If the count is not zero, a near jump is performed to the destination (target) operand, which is presumably the instruction at the beginning of the loop. If the address-size attribute is 32 bits, the ECX register is used as the count register; otherwise the CX register is used.</p>
<p>The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). This offset is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit immediate value, which is added to the instruction pointer. Offsets of -128 to +127 are allowed with this instruction.</p>
<p>Some forms of the loop instruction (LOOPcc) also accept the ZF flag as a condition for terminating the loop before the count reaches zero. With these forms of the instruction, a condition code (cc) is associated with each instruction to indicate the condition being tested for. Here, the LOOPcc instruction itself does not affect the state of the ZF flag; the ZF flag is changed by other instructions in the loop.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>AddressSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> Count <span class="operator">=</span> ECX<span class="operator">;</span>
<span class="keyword">else</span> Count <span class="operator">=</span> CX<span class="operator">;</span> <span class="comment">//AddressSize == 16</span>

Count <span class="operator">=</span> Count <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>

<span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> LOOPE<span class="operator">:</span>
	<span class="keyword">case</span> LOOPZ<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>ZF <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> Count <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> BranchCond <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">else</span> BranchCond <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> LOOPNE<span class="operator">:</span>
	<span class="keyword">case</span> LOOPNZ<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>ZF <span class="operator">==</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> Count <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> BranchCond <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">else</span> BranchCond <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">default</span><span class="operator">:</span> <span class="comment">//LOOP</span>
		<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> BranchCond <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">else</span> BranchCond <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
<span class="keyword">if</span><span class="operator">(</span>BranchCond <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> {
	EIP <span class="operator">=</span> EIP <span class="operator">+</span> SignExtend<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> EIP <span class="operator">=</span> EIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span>
	<span class="keyword">else</span> <span class="comment">/*OperandSize == 32*/</span> <span class="keyword">if</span><span class="operator">(</span>EIP <span class="operator">&lt;</span> CS<span class="operator">.</span>Base <span class="operator">||</span> EIP <span class="operator">&lt;</span> CS<span class="operator">.</span>Limit<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">)</span><span class="operator">;</span>
}
<span class="keyword">else</span> ResumeExecution<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//Terminate loop and continue program execution at EIP</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>LSL</strong><br />Load Segment Limit<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 03 /r</code></td>
<td class="grid"><code>LSL r16,r/m16</code></td>
<td class="grid">Load: r16 = segment limit, selector r/m16.</td>
</tr>
<tr>
<td class="grid"><code>0F 03 /r</code></td>
<td class="grid"><code>LSL r32,r/m32</code></td>
<td class="grid">Load: r32 = segment limit, selector r/m32.</td>
</tr>
</table></td><td>
<p>Loads the unscrambled segment limit from the segment descriptor specified with the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the EFLAGS register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. The destination operand is a general-purpose register.</p>
<p>The processor performs access checks as part of the loading process. Once loaded in the destination register, software can compare the segment limit with the offset of a pointer.</p>
<p>The segment limit is a 20-bit value contained in bytes 0 and 1 and in the first 4 bits of byte 6 of the segment descriptor. If the descriptor has a byte granular segment limit (the granularity flag is set to 0), the destination operand is loaded with a byte granular value (byte limit). If the descriptor has a page granular segment limit (the granularity flag is set to 1), the LSL instruction will translate the page granular limit (page limit) into a byte limit before loading it into the destination operand. The translation is performed by shifting the 20-bit &quot;raw&quot; limit left 12 bits and filling the low-order 12 bits with 1s.</p>
<p>When the operand size is 32 bits, the 32-bit byte limit is stored in the destination operand. When the operand size is 16 bits, a valid 32-bit limit is computed; however, the upper 16 bits are truncated and only the low-order 16 bits are loaded into the destination operand.</p>
<p>This instruction performs the following checks before it loads the segment limit into the destination register:</p>
<ul>
<li>Checks that the segment selector is not null.</li>
<li>Checks that the segment selector points to a descriptor that is within the limits of the GDT or LDT being accessed</li>
<li>Checks that the descriptor type is valid for this instruction. All code and data segment descriptors are valid for (can be accessed with) the LSL instruction. The valid special segment and gate descriptor types are given in the following table.</li>
<li>If the segment is not a conforming code segment, the instruction checks that the specified segment descriptor is visible at the CPL (that is, if the CPL and the RPL of the segment selector are less than or equal to the DPL of the segment selector).</li>
</ul>
<p>If the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no value is loaded in the destination operand.</p>
<div>
<table class="grid">
<caption>Segment and Gate Descriptor Types</caption>
<tr><th>Type</th><th>Name</th><th>Valid</th></tr>
<tr><td>0</td><td>Reserved</td><td>No</td></tr>
<tr><td>1</td><td>Available 16-bit TSS</td><td>Yes</td></tr>
<tr><td>2</td><td>LDT</td><td>Yes</td></tr>
<tr><td>3</td><td>Busy 16-bit TSS</td><td>Yes</td></tr>
<tr><td>4</td><td>16-bit call gate</td><td>Yes</td></tr>
<tr><td>5</td><td>16-bit/32-bit task gate</td><td>Yes</td></tr>
<tr><td>6</td><td>16-bit interrupt gate</td><td>No</td></tr>
<tr><td>7</td><td>16-bit trap gate</td><td>No</td></tr>
<tr><td>8</td><td>Reserved</td><td>No</td></tr>
<tr><td>9</td><td>Available 32-bit TSS</td><td>Yes</td></tr>
<tr><td>A</td><td>Reserved</td><td>No</td></tr>
<tr><td>B</td><td>Busy 32-bit TSS</td><td>Yes</td></tr>
<tr><td>C</td><td>32-bit call gate</td><td>Yes</td></tr>
<tr><td>D</td><td>Reserved</td><td>No</td></tr>
<tr><td>E</td><td>32-bit interrupt gate</td><td>No</td></tr>
<tr><td>F</td><td>32-bit trap gate</td><td>No</td></tr>
</table>
</div>
<br />0</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>Source<span class="operator">.</span>Offset<span class="operator">)</span><span class="operator">)</span> ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>

SegmentDescriptor <span class="operator">=</span> ReadSegmentDescriptor<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsConformingCodeSegment<span class="operator">(</span>SegmentDescriptor<span class="operator">)</span> <span class="operator">&amp;&amp;</span> CPL <span class="operator">&gt;</span> DPL <span class="operator">||</span> RPL <span class="operator">&gt;</span> DPL <span class="operator">||</span> <span class="operator">!</span>ValidSegmentType<span class="operator">(</span>SegmentDescriptor<span class="operator">)</span> <span class="comment">/*Segment type is not valid for instruction*/</span><span class="operator">)</span> ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
<span class="keyword">else</span> {
	Temporary <span class="operator">=</span> SegmentLimit<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span> <span class="comment">//Source: segment relative offset</span>
	<span class="keyword">if</span><span class="operator">(</span>G <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Temporary <span class="operator">=</span> <span class="operator">(</span>Temporary <span class="operator">&lt;&lt;</span> <span class="number">12</span><span class="operator">)</span> <span class="operator">|</span> <span class="number">0xFFF</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> Destination <span class="operator">=</span> Temporary<span class="operator">;</span>
	<span class="keyword">else</span> Destination <span class="operator">=</span> Temporary <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span> <span class="comment">//OperandSize == 16</span>
}
</pre>
</td></tr><tr><td><strong>LTR</strong><br />Load Task Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 00 /3</code></td>
<td class="grid"><code>LTR r/m16</code></td>
<td class="grid">Load r/m16 into task register.</td>
</tr>
</table></td><td>
<p>Loads the source operand into the segment selector field of the task register. The source operand (a general-purpose register or a memory location) contains a segment selector that points to a task state segment (TSS). After the segment selector is loaded in the task register, the processor uses the segment selector to locate the segment descriptor for the TSS in the global descriptor table (GDT). It then loads the segment limit and base address for the TSS from the segment descriptor into the task register. The task pointed to by the task register is marked busy, but a switch to the task does not occur.</p>
<p>The LTR instruction is provided for use in operating-system software; it should not be used in application programs. It can only be executed in protected mode when the CPL is 0. It is commonly used in initialization code to establish the first task to be executed.</p>
<p>The operand-size attribute has no effect on this instruction.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimit<span class="operator">(</span>Source<span class="operator">.</span>Offset<span class="operator">)</span> <span class="operator">||</span> Source<span class="operator">.</span>Type <span class="operator">!=</span> TypeGlobal<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
SegmentDescriptor <span class="operator">=</span> ReadSegmentDescriptor<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsForAnAvailableTSS<span class="operator">(</span>SegmentDescriptor<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>SegmentDescriptor<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
TSSSegmentDescriptor<span class="operator">.</span>Busy <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
<span class="comment">//Locked read-modify-write operation on the entire descriptor when setting busy flag</span>
TaskRegister<span class="operator">.</span>SegmentSelector <span class="operator">=</span> Source<span class="operator">;</span>
TaskRegister<span class="operator">.</span>SegmentDescriptor<span class="operator">.</span>TSSSegmentDescriptor<span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>MASKMOVDQU</strong><br />Store Selected Bytes of Double Quadword<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F F7 /r</code></td>
<td class="grid"><code>MASKMOVDQU xmm1, xmm2</code></td>
<td class="grid">Selectively write bytes from xmm1 to memory</td>
</tr>
</table></td><td>
<p>Stores selected bytes from the source operand (first operand) into an 128-bit memory location.</p>
<p>The mask operand (second operand) selects which bytes from the source operand are written to memory. The source and mask operands are XMM registers. The location of the first byte of the memory location is specified by DI/EDI and DS registers. The memory location does not need to be aligned on a natural boundary. (The size of the store address depends on the address-size attribute.) The most significant bit in each byte of the mask operand determines whether the corresponding byte in the source operand is written to the corresponding byte location in memory: 0 indicates no write and 1 indicates write.</p>
<p>The MASKMOVEDQU instruction generates a non-temporal hint to the processor to minimize cache pollution. The non-temporal hint is implemented by using a write combining (WC) memory type protocol (see &quot;Caching of Temporal vs. Non-Temporal Data&quot; in Chapter 10, of the IA-32 Intel Architecture Software Developer's Manual, Volume 1). Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MASKMOVEDQU instructions if multiple processors might use different memory types to read/write the destination memory locations.</p>
<p>Behavior with a mask of all 0s is as follows:</p>
<ul>
<li>No data will be written to memory.</li>
<li>Signaling of breakpoints (code or data) is not guaranteed; different processor implementations may signal or not signal these breakpoints.</li>
<li>Exceptions associated with addressing memory and page faults may still be signaled (implementation dependent).</li>
<li>If the destination memory region is mapped as UC or WP, enforcement of associated semantics for these memory types is not guaranteed (that is, is reserved) and is implementation- specific.</li>
</ul>
<p>The MASKMOVDQU instruction can be used to improve performance of algorithms that need to merge data on a byte-by-byte basis. MASKMOVDQU should not cause a read for ownership; doing so generates unnecessary bandwidth since data is to be written directly using the bytemask without allocating old data prior to the store.</p>
<p>location using the byte mask in xmm2.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">7</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI<span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">15</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">23</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">31</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">3</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">39</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">4</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">47</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">5</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">55</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">6</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">63</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">7</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">71</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">8</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">79</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">9</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">87</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">10</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">95</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">11</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">103</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">12</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">111</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">13</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">119</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">14</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">127</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">15</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>#GP(0)</code></td><td>For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments. (even if mask is all 0s). If the destination operand is in a nonwritable segment. If the DS, ES, FS, or GS register contains a null segment selector.</td></tr>
<tr><td><code>#GP(0)</code></td><td>For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments. (even if mask is all 0s). If the destination operand is in a nonwritable segment. If the DS, ES, FS, or GS register contains a null segment selector.</td></tr>
<tr><td><code>#SS(0)</code></td><td>For an illegal address in the SS segment (even if mask is all 0s).</td></tr>
<tr><td><code>#PF(fault-code)</code></td><td>For a page fault (implementation specific).</td></tr>
<tr><td><code>#NM</code></td><td>If TS in CR0 is set.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>MASKMOVQ</strong><br />Store Selected Bytes of Quadword<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F F7 /r</code></td>
<td class="grid"><code>MASKMOVQ mm1, mm2</code></td>
<td class="grid">Selectively write bytes from mm1 to memory location using the byte mask in mm2.</td>
</tr>
</table></td><td>
<p>Stores selected bytes from the source operand (first operand) into a 64-bit memory location. The mask operand (second operand) selects which bytes from the source operand are written to memory. The source and mask operands are MMX technology registers. The location of the first byte of the memory location is specified by DI/EDI and DS registers. (The size of the store address depends on the address-size attribute.) The most significant bit in each byte of the mask operand determines whether the corresponding byte in the source operand is written to the corresponding byte location in memory: 0 indicates no write and 1 indicates write.</p>
<p>The MASKMOVQ instruction generates a non-temporal hint to the processor to minimize cache pollution. The non-temporal hint is implemented by using a write combining (WC) memory type protocol (see &quot;Caching of Temporal vs. Non-Temporal Data&quot; in Chapter 10, of the IA-32 Intel Architecture Software Developer's Manual, Volume 1). Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MASKMOVEDQU instructions if multiple processors might use different memory types to read/write the destination memory locations.</p>
<p>This instruction causes a transition from x87 FPU to MMX technology state (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]).</p>
<p>The behavior of the MASKMOVQ instruction with a mask of all 0s is as follows:</p>
<ul>
<li>No data will be written to memory.</li>
<li>Transition from x87 FPU to MMX technology state will occur.</li>
<li>Exceptions associated with addressing memory and page faults may still be signaled (implementation dependent).</li>
<li>Signaling of breakpoints (code or data) is not guaranteed (implementation dependent).</li>
<li>If the destination memory region is mapped as UC or WP, enforcement of associated semantics for these memory types is not guaranteed (that is, is reserved) and is implementation- specific.</li>
</ul>
<p>The MASKMOVQ instruction can be used to improve performance for algorithms that need to merge data on a byte-by-byte basis. It should not cause a read for ownership; doing so generates unnecessary bandwidth since data is to be written directly using the byte-mask without allocating old data prior to the store.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">7</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI<span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">15</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">23</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">31</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">3</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">39</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">4</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">47</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">5</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">55</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">6</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Mask<span class="operator">[</span><span class="number">63</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">7</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>#GP(0)</code></td><td>For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments. (even if mask is all 0s). If the destination operand is in a nonwritable segment. If the DS, ES, FS, or GS register contains a null segment selector.</td></tr>
<tr><td><code>#GP(0)</code></td><td>For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments. (even if mask is all 0s). If the destination operand is in a nonwritable segment. If the DS, ES, FS, or GS register contains a null segment selector.</td></tr>
<tr><td><code>#SS(0)</code></td><td>For an illegal address in the SS segment (even if mask is all 0s).</td></tr>
<tr><td><code>#PF(fault-code)</code></td><td>For a page fault (implementation specific).</td></tr>
<tr><td><code>#NM</code></td><td>If TS in CR0 is set.</td></tr>
<tr><td><code>#MF</code></td><td>If there is a pending FPU exception.</td></tr>
<tr><td><code>#UD</code></td><td>If EM in CR0 is set. If OSFXSR in CR4 is 0. If CPUID feature flag SSE is 0. If Mod field of the ModR/M byte not 11B</td></tr>
</table>
</div>
</td></tr><tr><td><strong>MAXPD</strong><br />Return Maximum Packed Double-Precision Floating- Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 5F /r</code></td>
<td class="grid"><code>MAXPD xmm1, xmm2/m128</code></td>
<td class="grid">Return the maximum double-precision floating-point</td>
</tr>
</table></td><td>
<p>Performs an SIMD compare of the packed double-precision floating-point values in the destination operand (first operand) and the source operand (second operand), and returns the maximum value for each pair of values to the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p>
<p>If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, that SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p>
<p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MAXPD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>Invalid</code></td><td>(including QNaN source operand), Denormal.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>MAXPS</strong><br />Return Maximum Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 5F /r</code></td>
<td class="grid"><code>MAXPS xmm1, xmm2/m128</code></td>
<td class="grid">Return the maximum single-precision floating-point</td>
</tr>
</table></td><td>
<p>Performs an SIMD compare of the packed single-precision floating-point values in the destination operand (first operand) and the source operand (second operand), and returns the maximum value for each pair of values to the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p>
<p>If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p>
<p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MAXPS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>Invalid</code></td><td>(including QNaN source operand), Denormal.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>MAXSD</strong><br />Return Maximum Scalar Double-Precision Floating-Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 5F /r</code></td>
<td class="grid"><code>MAXSD xmm1, xmm2/m64</code></td>
<td class="grid">Return the maximum scalar double-precision floating-point</td>
</tr>
</table></td><td>
<p>Compares the low double-precision floating-point values in the destination operand (first operand) and the source operand (second operand), and returns the maximum value to the low quadword of the destination operand. The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. When the source operand is a memory operand, only 64 bits are accessed. The high quadword of the destination operand remains unchanged.</p>
<p>If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p>
<p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MAXSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[64..127] is unchanged</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>Invalid</code></td><td>(including QNaN source operand), Denormal. value between xmm2/mem64 and xmm1.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>MAXSS</strong><br />Return Maximum Scalar Single-Precision Floating-Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 5F /r</code></td>
<td class="grid"><code>MAXSS xmm1, xmm2/m32</code></td>
<td class="grid">Return the maximum scalar single-precision floating-point value between xmm2/mem32 and xmm1.</td>
</tr>
</table></td><td>
<p>Compares the low single-precision floating-point values in the destination operand (first operand) and the source operand (second operand), and returns the maximum value to the low doubleword of the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. When the source operand is a memory operand, only 32 bits are accessed. The three high-order doublewords of the destination operand remain unchanged.</p>
<p>If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p>
<p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MAXSS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[32..127] is unchanged</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>Invalid</code></td><td>(including QNaN source operand), Denormal.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>MFENCE</strong><br />Memory Fence<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F AE /6</code></td>
<td class="grid"><code>MFENCE</code></td>
<td class="grid">Serializes load and store operations.</td>
</tr>
</table></td><td>
<p>Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior the MFENCE instruction. This serializing operation guarantees that every load and store instruction that precedes in program order the MFENCE instruction is globally visible before any load or store instruction that follows the MFENCE instruction is globally visible. The MFENCE instruction is ordered with respect to all load and store instructions, other MFENCE instructions, any SFENCE and LFENCE instructions, and any serializing instructions (such as the CPUID instruction).</p>
<p>Weakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue, speculative reads, write-combining, and write-collapsing.</p>
<p>The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data. The MFENCE instruction provides a performance-efficient way of ensuring load and store ordering between routines that produce weakly-ordered results and routines that consume that data.</p>
<p>It should be noted that processors are free to speculatively fetch and cache data from system memory regions that are assigned a memory-type that permits speculative reads (that is, the WB, WC, and WT memory types). The PREFETCHh instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, the MFENCE instruction is not ordered with respect to PREFETCHh instructions or any other speculative fetching mechanism (that is, data could be speculatively loaded into the cache just before, during, or after the execution of an MFENCE instruction).</p>
<br />
<pre>WaitOnLoadsAndStores<span class="operator">(</span>PrecedingLoadsAndStoreGloballyVisible<span class="operator">)</span><span class="operator">;</span> <span class="comment">//wait on following loads and stores until the preceding loads and stores are globally visible</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MINPD</strong><br />Return Minimum Packed Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 5D /r</code></td>
<td class="grid"><code>MINPD xmm1, xmm2/m128</code></td>
<td class="grid">Return the minimum double-precision floating-point values between xmm2/m128 and xmm1.</td>
</tr>
</table></td><td>
<p>Performs an SIMD compare of the packed double-precision floating-point values in the destination operand (first operand) and the source operand (second operand), and returns the minimum value for each pair of values to the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p>
<p>If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p>
<p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MINPD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>Invalid</code></td><td>(including QNaN source operand), Denormal.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>MINPS</strong><br />Return Minimum Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 5D /r</code></td>
<td class="grid"><code>MINPS xmm1, xmm2/m128</code></td>
<td class="grid">Return the minimum single-precision floating-point values between xmm2/m128 and xmm1.</td>
</tr>
</table></td><td>
<p>Performs an SIMD compare of the packed single-precision floating-point values in the destination operand (first operand) and the source operand (second operand), and returns the minimum value for each pair of values to the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p>
<p>If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p>
<p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MINPS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>Invalid</code></td><td>(including QNaN source operand), Denormal.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>MINSD</strong><br />Return Minimum Scalar Double-Precision Floating-Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 5D /r</code></td>
<td class="grid"><code>MINSD xmm1, xmm2/m64</code></td>
<td class="grid">Return the minimum scalar double-precision floating-point value between xmm2/mem64 and xmm1.</td>
</tr>
</table></td><td>
<p>Compares the low double-precision floating-point values in the destination operand (first operand) and the source operand (second operand), and returns the minimum value to the low quadword of the destination operand. The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. When the source operand is a memory operand, only the 64 bits are accessed. The high quadword of the destination operand remains unchanged.</p>
<p>If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p>
<p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MINSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[64..127] is unchanged</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>Invalid</code></td><td>(including QNaN source operand), Denormal.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>MINSS</strong><br />Return Minimum Scalar Single-Precision Floating-Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 5D /r</code></td>
<td class="grid"><code>MINSS xmm1, xmm2/m32 Return the minimum scalar single-precision floating-point value between xmm2/mem32 and xmm1.</code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Compares the low single-precision floating-point values in the destination operand (first operand) and the source operand (second operand), and returns the minimum value to the low doubleword of the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. When the source operand is a memory operand, only 32 bits are accessed. The three high-order doublewords of the destination operand remain unchanged.</p>
<p>If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p>
<p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MINSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span> <span class="operator">&amp;&amp;</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0.0</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> IsSNaN<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">||</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[32..127] is unchanged</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>Invalid</code></td><td>(including QNaN source operand), Denormal.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>MONITOR</strong><br />Setup Monitor Address<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 01 C8</code></td>
<td class="grid"><code>MONITOR</code></td>
<td class="grid">Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be of a write-back memory caching type.</td>
</tr>
</table></td><td>
<p>The MONITOR instruction arms the address monitoring hardware using the address specified in EAX. The address range that the monitoring hardware will check for store operations can be determined by the CPUID instruction. The monitoring hardware will detect stores to an address within the address range and triggers the monitor hardware when the write is detected. The state of the monitor hardware is used by the MWAIT instruction.</p>
<p>The content of EAX is an effective address. By default, the DS segment is used to create a linear address that is then monitored. Segment overrides can be used with the MONITOR instruction.</p>
<p>ECX and EDX are used to communicate other information to the MONITOR instruction. ECX specifies optional extensions for the MONITOR instruction. EDX specifies optional hints for the MONITOR instruction and does not change the architectural behavior of the instruction. For the Pentium 4 processor with CPUID signature of family = 15 and model = 3, no extensions or hints are defined. Specifying undefined hints in EDX are ignored by the processor, whereas specifying undefined extensions in ECX will raise a general protection fault exception on the execution of the MONITOR instruction.</p>
<p>The address range must be in memory of write-back type. Only write-back memory type stores to the monitored address range will trigger the monitoring hardware. If the address range is not in memory of write-back type, the address monitor hardware may not be armed properly. The MONITOR instruction is ordered as a load operation with respect to other memory transactions.</p>
<p>Additional information for determining the address range to prevent false wake-ups is described in Chapter 7 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3.</p>
<p>The MONITOR instruction can be used at all privilege levels and is subject to all permission checking and faults associated with a byte load. Like a load, the MONITOR instruction sets the A-bit but not the D-bit in the page tables. The MONITOR CPUID feature flag (bit 3 of ECX when CPUID is executed with EAX=1) indicates the availability of MONITOR and MWAIT instructions in the processor. When set, the unconditional execution of MONITOR is supported at privilege levels 0 and conditional execution at privilege levels 1 through 3 (software should test for the appropriate support of these instructions before unconditional use). The operating system or system BIOS may disable this instruction through the IA32_MISC_ENABLES MSR; disabling the instruction clears the CPUID feature flag and causes execution of the MONITOR instruction to generate an illegal opcode exception.</p>
<br />
<pre><span class="comment">/*</span>
<span class="comment">MONITOR sets up an address range for the monitor hardware using the content of EAX as an</span>
<span class="comment">effective address and puts the monitor hardware in armed state. The memory address range</span>
<span class="comment">should be within memory of the write-back caching type. A store to the specified address range</span>
<span class="comment">will trigger the monitor hardware. The content of ECX and EDX are used to communicate other</span>
<span class="comment">information to the monitor hardware.</span>
<span class="comment">*/</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>#GP(0)</code></td><td>For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.</td></tr>
<tr><td><code>#GP(0)</code></td><td>For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.</td></tr>
<tr><td><code>#GP(0)</code></td><td>For ECX has a value other than 0.</td></tr>
<tr><td><code>#SS(0)</code></td><td>For an illegal address in the SS segment.</td></tr>
<tr><td><code>#PF(fault-code)</code></td><td>For a page fault (TBD).</td></tr>
</table>
</div>
</td></tr><tr><td><strong>MOV</strong><br />Move<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>88 /r</code></td>
<td class="grid"><code>MOV r/m8,r8</code></td>
<td class="grid">Move r8 to r/m8.</td>
</tr>
<tr>
<td class="grid"><code>89 /r</code></td>
<td class="grid"><code>MOV r/m16,r16</code></td>
<td class="grid">Move r16 to r/m16.</td>
</tr>
<tr>
<td class="grid"><code>89 /r</code></td>
<td class="grid"><code>MOV r/m32,r32</code></td>
<td class="grid">Move r32 to r/m32.</td>
</tr>
<tr>
<td class="grid"><code>8A /r</code></td>
<td class="grid"><code>MOV r8,r/m8</code></td>
<td class="grid">Move r/m8 to r8.</td>
</tr>
<tr>
<td class="grid"><code>8B /r</code></td>
<td class="grid"><code>MOV r16,r/m16</code></td>
<td class="grid">Move r/m16 to r16.</td>
</tr>
<tr>
<td class="grid"><code>8B /r</code></td>
<td class="grid"><code>MOV r32,r/m32</code></td>
<td class="grid">Move r/m32 to r32.</td>
</tr>
<tr>
<td class="grid"><code>8C /r</code></td>
<td class="grid"><code>MOV r/m16,Sreg**</code></td>
<td class="grid">Move segment register to r/m16.</td>
</tr>
<tr>
<td class="grid"><code>8E /r</code></td>
<td class="grid"><code>MOV Sreg,r/m16**</code></td>
<td class="grid">Move r/m16 to segment register.</td>
</tr>
<tr>
<td class="grid"><code>A0</code></td>
<td class="grid"><code>MOV AL,moffs8*</code></td>
<td class="grid">Move byte at (seg:offset) to AL.</td>
</tr>
<tr>
<td class="grid"><code>A1</code></td>
<td class="grid"><code>MOV AX,moffs16*</code></td>
<td class="grid">Move word at (seg:offset) to AX.</td>
</tr>
<tr>
<td class="grid"><code>A1</code></td>
<td class="grid"><code>MOV EAX,moffs32*</code></td>
<td class="grid">Move doubleword at (seg:offset) to EAX.</td>
</tr>
<tr>
<td class="grid"><code>A2</code></td>
<td class="grid"><code>MOV moffs8*,AL</code></td>
<td class="grid">Move AL to (seg:offset).</td>
</tr>
<tr>
<td class="grid"><code>A3</code></td>
<td class="grid"><code>MOV moffs16*,AX</code></td>
<td class="grid">Move AX to (seg:offset).</td>
</tr>
<tr>
<td class="grid"><code>A3</code></td>
<td class="grid"><code>MOV moffs32*,EAX</code></td>
<td class="grid">Move EAX to (seg:offset).</td>
</tr>
<tr>
<td class="grid"><code>B0+ rb</code></td>
<td class="grid"><code>MOV r8,imm8</code></td>
<td class="grid">Move imm8 to r8.</td>
</tr>
<tr>
<td class="grid"><code>B8+ rw</code></td>
<td class="grid"><code>MOV r16,imm16</code></td>
<td class="grid">Move imm16 to r16.</td>
</tr>
<tr>
<td class="grid"><code>B8+ rd</code></td>
<td class="grid"><code>MOV r32,imm32</code></td>
<td class="grid">Move imm32 to r32.</td>
</tr>
<tr>
<td class="grid"><code>C6 /0</code></td>
<td class="grid"><code>MOV r/m8,imm8</code></td>
<td class="grid">Move imm8 to r/m8.</td>
</tr>
<tr>
<td class="grid"><code>C7 /0</code></td>
<td class="grid"><code>MOV r/m16,imm16</code></td>
<td class="grid">Move imm16 to r/m16.</td>
</tr>
<tr>
<td class="grid"><code>C7 /0</code></td>
<td class="grid"><code>MOV r/m32,imm32</code></td>
<td class="grid">Move imm32 to r/m32.</td>
</tr>
</table></td><td>
<p>* The moffs8, moffs16, and moffs32 operands specify a simple offset relative to the segment base, where 8, 16, and 32 refer to the size of the data. The address-size attribute of the instruction determines the size of the offset, either 16 or 32 bits.</p>
<p>** In 32-bit mode, the assembler may insert the 16-bit operand-size prefix with this instruction.</p>
<p>Copies the second operand (source operand) to the first operand (destination operand). The source operand can be an immediate value, general-purpose register, segment register, or memory location; the destination register can be a general-purpose register, segment register, or memory location. Both operands must be the same size, which can be a byte, a word, or a doubleword.</p>
<p>The MOV instruction cannot be used to load the CS register. Attempting to do so results in an invalid opcode exception (#UD). To load the CS register, use the far JMP, CALL, or RET instruction.</p>
<p>If the destination operand is a segment register (DS, ES, FS, GS, or SS), the source operand must be a valid segment selector. In protected mode, moving a segment selector into a segment register automatically causes the segment descriptor information associated with that segment selector to be loaded into the hidden (shadow) part of the segment register. While loading this information, the segment selector and segment descriptor information is validated (see the &quot;Operation&quot; algorithm below). The segment descriptor data is obtained from the GDT or LDT entry for the specified segment selector.</p>
<p>A null segment selector (values 0000-0003) can be loaded into the DS, ES, FS, and GS registers without causing a protection exception. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded with a null value causes a general protection exception (#GP) and no memory reference occurs.</p>
<p>Loading the SS register with a MOV instruction inhibits all interrupts until after the execution of the next instruction. This operation allows a stack pointer to be loaded into the ESP register with the next instruction (MOV ESP, stack-pointer value) before an interrupt occurs1. Be aware that the LSS instruction offers a more efficient method of loading the SS and ESP registers.</p>
<p>When operating in 32-bit mode and moving data between a segment register and a generalpurpose register, the 32-bit IA-32 processors do not require the use of the 16-bit operand-size prefix (a byte with the value 66H) with this instruction, but most assemblers will insert it if the standard form of the instruction is used (for example, MOV DS, AX). The processor will execute this instruction correctly, but it will usually require an extra clock. With most assemblers, using the instruction form MOV DS, EAX will avoid this unneeded 66H prefix. When the processor executes the instruction with a 32-bit general-purpose register, it assumes that the 16 least-significant bits of the general-purpose register are the destination or source operand. If the register is a destination operand, the resulting value in the two high-order bytes of the register is implementation dependent. For the Pentium 4, Intel Xeon, and P6 family processors, the two high-order bytes are filled with zeros; for earlier 32-bit IA-32 processors, the two high order bytes are undefined.</p>
<br />
<pre>Destination <span class="operator">=</span> Source<span class="operator">;</span>

<span class="comment">/*</span>
<span class="comment">Loading a segment register while in protected mode results in special checks and actions,</span>
<span class="comment">as described in the following listing. These checks are performed on the segment selector</span>
<span class="comment">and the segment descriptor it points to. If a code instruction breakpoint (for debug)</span>
<span class="comment">is placed on an instruction located immediately after a MOV SS instruction,</span>
<span class="comment">the breakpoint may not be triggered. Note that in a sequence of instructions that</span>
<span class="comment">individually delay interrupts past the following instruction, only the first instruction</span>
<span class="comment">in the sequence is guaranteed to delay the interrupt, but subsequent interrupt-delaying</span>
<span class="comment">instructions may not delay the interrupt. Thus, in the following instruction sequence:</span>
<span class="comment">	STI</span>
<span class="comment">	MOV SS, EAX</span>
<span class="comment">	MOV ESP, EBP</span>
<span class="comment">Interrupts may be recognized before MOV ESP, EBP executes, because STI also delays interrupts for one instruction.</span>
<span class="comment">*/</span>

<span class="keyword">if</span><span class="operator">(</span>IsLoaded<span class="operator">(</span>SS<span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>SegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>SegmentSelector<span class="operator">)</span> <span class="operator">||</span> SegmentSelector<span class="operator">.</span>RPL <span class="operator">!=</span> CPL <span class="operator">||</span> <span class="operator">!</span>IsWritableDataSegment<span class="operator">(</span>SegmentSelector<span class="operator">)</span> <span class="operator">||</span> DPL <span class="operator">!=</span> CPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>Segment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	SS <span class="operator">=</span> SegmentSelector<span class="operator">;</span>
	SS <span class="operator">=</span> SegmentDescriptor<span class="operator">;</span>
}

<span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>IsLoaded<span class="operator">(</span>DS<span class="operator">)</span> <span class="operator">||</span> IsLoaded<span class="operator">(</span>ES<span class="operator">)</span> <span class="operator">||</span> IsLoaded<span class="operator">(</span>FS<span class="operator">)</span> <span class="operator">||</span> IsLoaded<span class="operator">(</span>GS<span class="operator">)</span><span class="operator">)</span> <span class="operator">&amp;&amp;</span> Selector <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> {
	SS <span class="operator">=</span> SegmentSelector<span class="operator">;</span>
	SS <span class="operator">=</span> SegmentDescriptor<span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>MOV</strong><br />Move to/from Control Registers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 22 /r</code></td>
<td class="grid"><code>MOV CR0,r32</code></td>
<td class="grid">Move r32 to CR0.</td>
</tr>
<tr>
<td class="grid"><code>0F 22 /r</code></td>
<td class="grid"><code>MOV CR2,r32</code></td>
<td class="grid">Move r32 to CR2.</td>
</tr>
<tr>
<td class="grid"><code>0F 22 /r</code></td>
<td class="grid"><code>MOV CR3,r32</code></td>
<td class="grid">Move r32 to CR3.</td>
</tr>
<tr>
<td class="grid"><code>0F 22 /r</code></td>
<td class="grid"><code>MOV CR4,r32</code></td>
<td class="grid">Move r32 to CR4.</td>
</tr>
<tr>
<td class="grid"><code>0F 20 /r</code></td>
<td class="grid"><code>MOV r32,CR0</code></td>
<td class="grid">Move CR0 to r32.</td>
</tr>
<tr>
<td class="grid"><code>0F 20 /r</code></td>
<td class="grid"><code>MOV r32,CR2</code></td>
<td class="grid">Move CR2 to r32.</td>
</tr>
<tr>
<td class="grid"><code>0F 20 /r</code></td>
<td class="grid"><code>MOV r32,CR3</code></td>
<td class="grid">Move CR3 to r32.</td>
</tr>
<tr>
<td class="grid"><code>0F 20 /r</code></td>
<td class="grid"><code>MOV r32,CR4</code></td>
<td class="grid">Move CR4 to r32.</td>
</tr>
</table></td><td>
<p>Moves the contents of a control register (CR0, CR2, CR3, or CR4) to a general-purpose register or vice versa. The operand size for these instructions is always 32 bits, regardless of the operandsize attribute. (See &quot;Control Registers&quot; in Chapter 2 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3, for a detailed description of the flags and fields in the control registers.) This instruction can be executed only when the current privilege level is 0.</p>
<p>When loading control registers, programs should not attempt to change the reserved bits; that is, always set reserved bits to the value previously read. An attempt to change CR4's reserved bits will cause a general protection fault. Reserved bits in CR0 and CR3 remain clear after any load of those registers; attempts to set them have no impact. On Pentium 4, Intel Xeon and P6 family processors, CR0.ET remains set after any load of CR0; attempts to clear this bit have no impact.</p>
<p>At the opcode level, the reg field within the ModR/M byte specifies which of the control registers is loaded or read. The 2 bits in the mod field are always 11B. The r/m field specifies the general-purpose register loaded or read.</p>
<p>These instructions have the following side effect: When writing to control register CR3, all non-global TLB entries are flushed (see &quot;Translation Lookaside Buffers (TLBs)&quot; in Chapter 3 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3).</p>
<p>The following side effects are implementation specific for the Pentium 4, Intel Xeon, and P6 family processors. Software should not depend on this functionality in all IA-32 processors:</p>
<ul>
<li>- When modifying any of the paging flags in the control registers (PE and PG in register CR0 and PGE, PSE, and PAE in register CR4), all TLB entries are flushed, including global entries.</li>
<li>- If the PG flag is set to 1 and control register CR4 is written to set the PAE flag to 1 (to enable the physical address extension mode), the pointers in the page-directory pointers table (PDPT) are loaded into the processor (into internal, non-architectural registers).</li>
<li>- If the PAE flag is set to 1 and the PG flag set to 1, writing to control register CR3 will cause the PDPTRs to be reloaded into the processor. If the PAE flag is set to 1 and control register CR0 is written to set the PG flag, the PDPTRs are reloaded into the processor.</li>
</ul>
<br />
<pre>Destination <span class="operator">=</span> Source<span class="operator">;</span>
</pre>
</td><td>
<p>The OF, SF, ZF, AF, PF, and CF flags are undefined.
</p>
</td></tr><tr><td><strong>MOV</strong><br />Move to/from Debug Registers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 21/r</code></td>
<td class="grid"><code>MOV r32, DR0-DR7</code></td>
<td class="grid">Move debug register to r32.</td>
</tr>
<tr>
<td class="grid"><code>0F 23 /r</code></td>
<td class="grid"><code>MOV DR0-DR7,r32</code></td>
<td class="grid">Move r32 to debug register.</td>
</tr>
</table></td><td>
<p>Moves the contents of a debug register (DR0, DR1, DR2, DR3, DR4, DR5, DR6, or DR7) to a general-purpose register or vice versa. The operand size for these instructions is always 32 bits, regardless of the operand-size attribute. (See Chapter 15, Debugging and Performance Monitoring, of the IA-32 Intel Architecture Software Developer's Manual, Volume 3, for a detailed description of the flags and fields in the debug registers.) The instructions must be executed at privilege level 0 or in real-address mode.</p>
<p>When the debug extension (DE) flag in register CR4 is clear, these instructions operate on debug registers in a manner that is compatible with Intel386 and Intel486 processors. In this mode, references to DR4 and DR5 refer to DR6 and DR7, respectively. When the DE flag in CR4 is set, attempts to reference DR4 and DR5 result in an undefined opcode (#UD) exception. (The CR4 register was added to the IA-32 Architecture beginning with the Pentium processor.) At the opcode level, the reg field within the ModR/M byte specifies which of the debug registers is loaded or read. The two bits in the mod field are always 11. The r/m field specifies the generalpurpose register loaded or read.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>DE <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> Source <span class="operator">==</span> DR4 <span class="operator">||</span> Source <span class="operator">==</span> DR5 <span class="operator">||</span> Destination <span class="operator">==</span> DR4 <span class="operator">||</span> Destination <span class="operator">==</span> DR5<span class="operator">)</span> Exception<span class="operator">(</span>UD<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">else</span> Destination <span class="operator">=</span> Source<span class="operator">;</span>
</pre>
</td><td>
<p>The OF, SF, ZF, AF, PF, and CF flags are undefined.
</p>
</td></tr><tr><td><strong>MOVAPD</strong><br />Move Aligned Packed Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 28 /r</code></td>
<td class="grid"><code>MOVAPD xmm1, xmm2/m128</code></td>
<td class="grid">Move packed double-precision floating-point values from xmm2/m128 to xmm1.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 29 /r</code></td>
<td class="grid"><code>MOVAPD xmm2/m128, xmm1</code></td>
<td class="grid">Move packed double-precision floating-point values from xmm1 to xmm2/m128.</td>
</tr>
</table></td><td>
<p>Moves a double quadword containing two packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.</p>
<p>When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.</p>
<p>To move double-precision floating-point values to and from unaligned memory locations, use the MOVUPD instruction.</p>
<br />
<pre>Destination <span class="operator">=</span> Source<span class="operator">;</span>
<span class="comment">//#GP if Source or Destination unaligned memory operand</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVAPS</strong><br />Move Aligned Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 28 /r</code></td>
<td class="grid"><code>MOVAPS xmm1, xmm2/m128</code></td>
<td class="grid">Move packed single-precision floating-point values from xmm2/m128 to xmm1.</td>
</tr>
<tr>
<td class="grid"><code>0F 29 /r</code></td>
<td class="grid"><code>MOVAPS xmm2/m128, xmm1</code></td>
<td class="grid">Move packed single-precision floating-point values from xmm1 to xmm2/m128.</td>
</tr>
</table></td><td>
<p>Moves a double quadword containing four packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.</p>
<p>When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) is generated.</p>
<p>To move packed single-precision floating-point values to or from unaligned memory locations, use the MOVUPS instruction.</p>
<br />
<pre>Destination <span class="operator">=</span> Source<span class="operator">;</span>
<span class="comment">//#GP if Source or Destination unaligned memory operand</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVD</strong><br />Move Doubleword<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 6E /r</code></td>
<td class="grid"><code>MOVD mm, r/m32</code></td>
<td class="grid">Move doubleword from r/m32 to mm.</td>
</tr>
<tr>
<td class="grid"><code>0F 7E /r</code></td>
<td class="grid"><code>MOVD r/m32, mm</code></td>
<td class="grid">Move doubleword from mm to r/m32.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 6E /r</code></td>
<td class="grid"><code>MOVD xmm, r/m32</code></td>
<td class="grid">Move doubleword from r/m32 to xmm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 7E /r</code></td>
<td class="grid"><code>MOVD r/m32, xmm</code></td>
<td class="grid">Move doubleword from xmm register to r/m32.</td>
</tr>
</table></td><td>
<p>Copies a doubleword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be general-purpose registers, MMX technology registers, XMM registers, or 32-bit memory locations. This instruction can be used to move a doubleword to and from the low doubleword of an MMX technology register and a general-purpose register or a 32-bit memory location, or to and from the low doubleword of an XMM register and a general-purpose register or a 32-bit memory location. The instruction cannot be used to transfer data between MMX technology registers, between XMM registers, between general-purpose registers, or between memory locations.</p>
<p>When the destination operand is an MMX technology register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 64 bits. When the destination operand is an XMM register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 128 bits.</p>
<br />
<pre><span class="comment">//MOVD instruction when destination operand is MMX technology register:</span>
<span class="keyword">if</span><span class="operator">(</span>IsMMXRegister<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">)</span> {
	Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
}
<span class="comment">//MOVD instruction when destination operand is XMM register:</span>
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>IsXMMRegister<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">)</span> {
	Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">32..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
}
<span class="comment">//MOVD instruction when source operand is MMX technology or XMM register:</span>
<span class="keyword">else</span> Destination <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>MOVDDUP</strong><br />Move One Double-FP and Duplicate<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 12 /r</code></td>
<td class="grid"><code>MOVDDUP xmm1, xmm2/m64</code></td>
<td class="grid">Move 64 bits representing the lower DP data element from xmm2/m64 to xmm1 register and duplicate.</td>
</tr>
</table></td><td>
<p>The linear address corresponds to the address of the least-significant byte of the referenced memory data. When a memory address is indicated, the 8 bytes of data at memory location m64 are loaded. When the register-register form of this operation is used, the lower half of the 128- bit source register is duplicated and copied into the 128-bit destination register.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Source <span class="operator">==</span> m64<span class="operator">)</span> {
	<span class="comment">//Load instruction</span>
	xmm1<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> m64<span class="operator">;</span>
	xmm1<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> m64<span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//Move instruction</span>
	xmm1<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> xmm2<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
	xmm1<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> xmm2<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
}
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVDQA</strong><br />Move Aligned Double Quadword<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 6F /r</code></td>
<td class="grid"><code>MOVDQA xmm1, xmm2/m128</code></td>
<td class="grid">Move aligned double quadword from xmm2/m128 to xmm1.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 7F /r</code></td>
<td class="grid"><code>MOVDQA xmm2/m128, xmm1</code></td>
<td class="grid">Move aligned double quadword from xmm1 to xmm2/m128.</td>
</tr>
</table></td><td>
<p>Moves a double quadword from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.</p>
<p>To move a double quadword to or from unaligned memory locations, use the MOVDQU instruction.</p>
<br />
<pre>Destination <span class="operator">=</span> Source<span class="operator">;</span>
<span class="comment">//#GP if Source or Destination unaligned memory operand</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVDQU</strong><br />Move Unaligned Double Quadword<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 6F /r</code></td>
<td class="grid"><code>MOVDQU xmm1, xmm2/m128</code></td>
<td class="grid">Move unaligned double quadword from xmm2/m128 to xmm1.</td>
</tr>
<tr>
<td class="grid"><code>F3 0F 7F /r</code></td>
<td class="grid"><code>MOVDQU xmm2/m128, xmm1</code></td>
<td class="grid">Move unaligned double quadword from xmm1 to xmm2/m128.</td>
</tr>
</table></td><td>
<p>Moves a double quadword from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers. When the source or destination operand is a memory operand, the operand may be unaligned on a 16-byte boundary without causing a general-protection exception (#GP) to be generated.</p>
<p>To move a double quadword to or from memory locations that are known to be aligned on 16- byte boundaries, use the MOVDQA instruction.</p>
<p>While executing in 16-bit addressing mode, a linear address for a 128-bit data access that overlaps the end of a 16-bit segment is not allowed and is defined as reserved behavior. A specific processor implementation may or may not generate a general-protection exception (#GP) in this situation, and the address that spans the end of the segment may or may not wrap around to the beginning of the segment.</p>
<br />
<pre>Destination <span class="operator">=</span> Source<span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVDQ2Q</strong><br />Move Quadword from XMM to MMX Technology Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F D6</code></td>
<td class="grid"><code>MOVDQ2Q mm, xmm</code></td>
<td class="grid">Move low quadword from xmm to MMX technology register.</td>
</tr>
</table></td><td>
<p>Moves the low quadword from the source operand (second operand) to the destination operand (first operand). The source operand is an XMM register and the destination operand is an MMX technology register.</p>
<p>This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the MOVDQ2Q instruction is executed.</p>
<br />
<pre>Destination <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVHLPS</strong><br /> Move Packed Single-Precision Floating-Point Values High to Low<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 12 /r</code></td>
<td class="grid"><code>MOVHLPS xmm1, xmm2</code></td>
<td class="grid">Move two packed single-precision floating-point values from high quadword of xmm2 to low quadword of xmm1.</td>
</tr>
</table></td><td>
<p>Moves two packed single-precision floating-point values from the high quadword of the source operand (second operand) to the low quadword of the destination operand (first operand). The high quadword of the destination operand is left unchanged.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[64..127] unchanged</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVHPD</strong><br />Move High Packed Double-Precision Floating-Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 16 /r</code></td>
<td class="grid"><code>MOVHPD xmm, m64</code></td>
<td class="grid">Move double-precision floating-point value from m64 to high quadword of xmm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 17 /r</code></td>
<td class="grid"><code>MOVHPD m64, xmm</code></td>
<td class="grid">Move double-precision floating-point value from high quadword of xmm to m64.</td>
</tr>
</table></td><td>
<p>Moves a double-precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be an XMM register or a 64-bit memory location. This instruction allows a double-precision floating-point value to be moved to and from the high quadword of an XMM register and memory. It cannot be used for register to register or memory to memory moves. When the destination operand is an XMM register, the low quadword of the register remains unchanged.</p>
<br />
<pre><span class="comment">//MOVHPD instruction for memory to XMM move:</span>
<span class="keyword">if</span><span class="operator">(</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">;</span>
<span class="comment">//Destination[0..63] unchanged</span>
<span class="comment">//MOVHPD instruction for XMM to memory move:</span>
Destination <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVHPS</strong><br />Move High Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 16 /r</code></td>
<td class="grid"><code>MOVHPS xmm, m64</code></td>
<td class="grid">Move two packed single-precision floating-point values from m64 to high quadword of xmm.</td>
</tr>
<tr>
<td class="grid"><code>0F 17 /r</code></td>
<td class="grid"><code>MOVHPS m64, xmm</code></td>
<td class="grid">Move two packed single-precision floating-point values from high quadword of xmm to m64.</td>
</tr>
</table></td><td>
<p>Moves two packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be an XMM register or a 64-bit memory location. This instruction allows two single-precision floating-point values to be moved to and from the high quadword of an XMM register and memory. It cannot be used for register to register or memory to memory moves. When the destination operand is an XMM register, the low quadword of the register remains unchanged.</p>
<br />
<pre><span class="comment">//MOVHPS instruction for memory to XMM move:</span>
<span class="keyword">if</span><span class="operator">(</span>IsXMM<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">;</span>
<span class="comment">//Destination[0..63] unchanged</span>
<span class="comment">//MOVHPS instruction for XMM to memory move:</span>
<span class="keyword">else</span> Destination <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVLHPS</strong><br />Move Packed Single-Precision Floating-Point Values Low to High<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 16 /r</code></td>
<td class="grid"><code>MOVLHPS xmm1, xmm2</code></td>
<td class="grid">Move two packed single-precision floating-point values from low quadword of xmm2 to high quadword of xmm1.</td>
</tr>
</table></td><td>
<p>Moves two packed single-precision floating-point values from the low quadword of the source operand (second operand) to the high quadword of the destination operand (first operand). The low quadword of the destination operand is left unchanged.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[0..63] unchanged</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVLPD</strong><br />Move Low Packed Double-Precision Floating-Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 12 /r</code></td>
<td class="grid"><code>MOVLPD xmm, m64</code></td>
<td class="grid">Move double-precision floating-point value from m64 to low quadword of xmm register.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 13 /r</code></td>
<td class="grid"><code>MOVLPD m64, xmm</code></td>
<td class="grid">Move double-precision floating-point nvalue from low quadword of xmm register to m64.</td>
</tr>
</table></td><td>
<p>Moves a double-precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be an XMM register or a 64-bit memory location. This instruction allows a double-precision floating-point value to be moved to and from the low quadword of an XMM register and memory. It cannot be used for register to register or memory to memory moves. When the destination operand is an XMM register, the high quadword of the register remains unchanged.</p>
<br />
<pre><span class="comment">//MOVLPD instruction for memory to XMM move:</span>
<span class="keyword">if</span><span class="operator">(</span>IsXMM<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">;</span>
<span class="comment">//Destination[64..127] unchanged</span>
<span class="comment">//MOVLPD instruction for XMM to memory move:</span>
<span class="keyword">else</span> Destination <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVLPS</strong><br />Move Low Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 12 /r</code></td>
<td class="grid"><code>MOVLPS xmm, m64</code></td>
<td class="grid">Move two packed single-precision floating-point values from m64 to low quadword of xmm.</td>
</tr>
<tr>
<td class="grid"><code>0F 13 /r</code></td>
<td class="grid"><code>MOVLPS m64, xmm</code></td>
<td class="grid">Move two packed single-precision floating-point values from low quadword of xmm to m64.</td>
</tr>
</table></td><td>
<p>Moves two packed single-precision floating-point values from the source operand (second operand) and the destination operand (first operand). The source and destination operands can be an XMM register or a 64-bit memory location. This instruction allows two single-precision floating-point values to be moved to and from the low quadword of an XMM register and memory. It cannot be used for register to register or memory to memory moves. When the destination operand is an XMM register, the high quadword of the register remains unchanged.</p>
<br />
<pre><span class="comment">//MOVLPS instruction for memory to XMM move:</span>
<span class="keyword">if</span><span class="operator">(</span>IsXMM<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">;</span>
<span class="comment">//Destination[64..127] unchanged</span>
<span class="comment">//MOVLPS instruction for XMM to memory move:</span>
<span class="keyword">else</span> Destination <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVMSKPD</strong><br />Extract Packed Double-Precision Floating-Point Sign Mask<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 50 /r</code></td>
<td class="grid"><code>MOVMSKPD r32, xmm</code></td>
<td class="grid">Extract 2-bit sign mask of from xmm and store in r32.</td>
</tr>
</table></td><td>
<p>Extracts the sign bits from the packed double-precision floating-point values in the source operand (second operand), formats them into a 2-bit mask, and stores the mask in the destination operand (first operand). The source operand is an XMM register, and the destination operand is a general-purpose register. The mask is stored in the 2 low-order bits of the destination operand.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">63</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">127</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">2..3</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">4..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVMSKPS</strong><br />Extract Packed Single-Precision Floating-Point Sign Mask<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 50 /r</code></td>
<td class="grid"><code>MOVMSKPS r32, xmm</code></td>
<td class="grid">Extract 4-bit sign mask of from xmm and store in r32.</td>
</tr>
</table></td><td>
<p>Extracts the sign bits from the packed single-precision floating-point values in the source operand (second operand), formats them into a 4-bit mask, and stores the mask in the destination operand (first operand). The source operand is an XMM register, and the destination operand is a general-purpose register. The mask is stored in the 4 low-order bits of the destination operand.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">31</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">63</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">95</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">127</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">4..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVNTDQ</strong><br />Store Double Quadword Using Non-Temporal Hint<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F E7 /r</code></td>
<td class="grid"><code>MOVNTDQ m128, xmm</code></td>
<td class="grid">Move double quadword from xmm to m128 using nontemporal hint.</td>
</tr>
</table></td><td>
<p>Moves the double quadword in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register, which is assumed to contain integer data (packed bytes, words, doublewords, or quadwords). The destination operand is a 128-bit memory location.</p>
<p>The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see &quot;Caching of Temporal vs. Non-Temporal Data&quot; in Chapter 10 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1.</p>
<p>Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTDQ instructions if multiple processors might use different memory types to read/write the destination memory locations.</p>
<br />
<pre>Destination <span class="operator">=</span> Source<span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVNTI</strong><br />Store Doubleword Using Non-Temporal Hint<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F C3 /r</code></td>
<td class="grid"><code>MOVNTI m32, r32</code></td>
<td class="grid">Move doubleword from r32 to m32 using non-temporal hint.</td>
</tr>
</table></td><td>
<p>Moves the doubleword integer in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is a general-purpose register. The destination operand is a 32-bit memory location.</p>
<p>The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see &quot;Caching of Temporal vs. Non-Temporal Data&quot; in Chapter 10 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1.</p>
<p>Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTI instructions if multiple processors might use different memory types to read/write the destination memory locations.</p>
<br />
<pre>Destination <span class="operator">=</span> Source<span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVNTPD</strong><br />Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 2B /r</code></td>
<td class="grid"><code>MOVNTPD m128, xmm</code></td>
<td class="grid">Move packed double-precision floating-point values from xmm to m128 using non-temporal hint.</td>
</tr>
</table></td><td>
<p>Moves the double quadword in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is an XMM register, which is assumed to contain two packed double-precision floating-point values. The destination operand is a 128-bit memory location.</p>
<p>The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see &quot;Caching of Temporal vs. Non-Temporal Data&quot; in Chapter 10 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1.</p>
<p>Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPD instructions if multiple processors might use different memory types to read/write the destination memory locations.</p>
<br />
<pre>Destination <span class="operator">=</span> Source<span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVNTPS</strong><br />Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 2B /r</code></td>
<td class="grid"><code>MOVNTPS m128, xmm</code></td>
<td class="grid">Move packed single-precision floating-point values from xmm to m128 using non-temporal hint.</td>
</tr>
</table></td><td>
<p>Moves the double quadword in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is an XMM register, which is assumed to contain four packed single-precision floating-point values. The destination operand is a 128-bit memory location.</p>
<p>The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see &quot;Caching of Temporal vs. Non-Temporal Data&quot; in Chapter 10 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1.</p>
<p>Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPS instructions if multiple processors might use different memory types to read/write the destination memory locations.</p>
<br />
<pre>Destination <span class="operator">=</span> Source<span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVNTQ</strong><br />Store of Quadword Using Non-Temporal Hint<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F E7 /r</code></td>
<td class="grid"><code>MOVNTQ m64, mm</code></td>
<td class="grid">Move quadword from mm to m64 using non-temporal hint.</td>
</tr>
</table></td><td>
<p>Moves the quadword in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory.</p>
<p>The source operand is an MMX technology register, which is assumed to contain packed integer data (packed bytes, words, or doublewords). The destination operand is a 64-bit memory location.</p>
<p>The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see &quot;Caching of Temporal vs. Non-Temporal Data&quot; in Chapter 10 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1.</p>
<p>Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTQ instructions if multiple processors might use different memory types to read/write the destination memory locations.</p>
<br />
<pre>Destination <span class="operator">=</span> Source<span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVSHDUP</strong><br />Move Packed Single-FP High and Duplicate<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 16 /r</code></td>
<td class="grid"><code>MOVSHDUP xmm1, xmm2/m128</code></td>
<td class="grid">Move two single-precision floating-point values from the higher 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the lower 32-bits of each qword.</td>
</tr>
</table></td><td>
<p>The linear address corresponds to the address of the least-significant byte of the referenced memory data. When a memory address is indicated, the 16 bytes of data at memory location m128 are loaded and the single-precision elements in positions 1 and 3 are duplicated. When the register-register form of this operation is used, the same operation is performed but with data coming from the 128-bit source register.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>source <span class="operator">==</span> m128<span class="operator">)</span> {
	<span class="comment">//load instruction</span>
	xmm1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> m128<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
	xmm1<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> m128<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span>
	xmm1<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> m128<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
	xmm1<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> m128<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//move instruction</span>
	xmm1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> xmm2<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
	xmm1<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> xmm2<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
	xmm1<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> xmm2<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
	xmm1<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> xmm2<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
}
</pre>
</td><td>
General protection exception if not aligned on 16-byte boundary, regardless of segment.
</td></tr><tr><td><strong>MOVSLDUP</strong><br />Move Packed Single-FP Low and Duplicate<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 12 /r</code></td>
<td class="grid"><code>MOVSLDUP xmm1, xmm2/m128</code></td>
<td class="grid">Move 128 bits representing packed SP data elements from xmm2/m128 to xmm1 register and duplicate low.</td>
</tr>
</table></td><td>
<p>The linear address corresponds to the address of the least-significant byte of the referenced memory data. When a memory address is indicated, the 16 bytes of data at memory location m128 are loaded and the single-precision elements in positions 0 and 2 are duplicated. When the register-register form of this operation is used, the same operation is performed but with data coming from the 128-bit source register.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>source <span class="operator">==</span> m128<span class="operator">)</span> {
	<span class="comment">//load instruction</span>
	xmm1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> m128<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
	xmm1<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> m128<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span>
	xmm1<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> m128<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
	xmm1<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> m128<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//move instruction</span>
	xmm1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> xmm2<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
	xmm1<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> xmm2<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
	xmm1<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> xmm2<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
	xmm1<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> xmm2<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
}
</pre>
</td><td>
General protection exception if not aligned on 16-byte boundary, regardless of segment.
</td></tr><tr><td><strong>MOVQ</strong><br />Move Quadword<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 6F /r</code></td>
<td class="grid"><code>MOVQ mm, mm/m64</code></td>
<td class="grid">Move quadword from mm/m64 to mm.</td>
</tr>
<tr>
<td class="grid"><code>0F 7F /r</code></td>
<td class="grid"><code>MOVQ mm/m64, mm</code></td>
<td class="grid">Move quadword from mm to mm/m64.</td>
</tr>
<tr>
<td class="grid"><code>F3 0F 7E</code></td>
<td class="grid"><code>MOVQ xmm1, xmm2/m64</code></td>
<td class="grid">Move quadword from xmm2/mem64 to xmm1.</td>
</tr>
<tr>
<td class="grid"><code>66 0F D6</code></td>
<td class="grid"><code>MOVQ xmm2/m64, xmm1</code></td>
<td class="grid">Move quadword from xmm1 to xmm2/mem64.</td>
</tr>
</table></td><td>
<p>Copies a quadword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be MMX technology registers, XMM registers, or 64-bit memory locations. This instruction can be used to move a quadword between two MMX technology registers or between an MMX technology register and a 64-bit memory location, or to move data between two XMM registers or between an XMM register and a 64-bit memory location. The instruction cannot be used to transfer data between memory locations.</p>
<p>When the source operand is an XMM register, the low quadword is moved; when the destination operand is an XMM register, the quadword is stored to the low quadword of the register, and the high quadword is cleared to all 0s.</p>
<br />
<pre><span class="comment">//MOVQ instruction when operating on MMX technology registers and memory locations:</span>
<span class="keyword">if</span><span class="operator">(</span>IsMMX<span class="operator">(</span>Source<span class="operator">)</span> <span class="operator">||</span> IsMMX<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">)</span> Destination <span class="operator">=</span> Source<span class="operator">;</span>
<span class="comment">//MOVQ instruction when source and destination operands are XMM registers:</span>
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>IsXMM<span class="operator">(</span>Source<span class="operator">)</span> <span class="operator">&amp;&amp;</span> IsXMM<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//MOVQ instruction when source operand is XMM register and destination operand is memory location:</span>
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>IsXMM<span class="operator">(</span>Source<span class="operator">)</span> <span class="operator">&amp;&amp;</span> IsMemory<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">)</span> Destination <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//MOVQ instruction when source operand is memory location and destination operand is XMM register:</span>
<span class="keyword">else</span> {
	Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>MOVQ2DQ</strong><br />Move Quadword from MMX Technology to XMM Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F D6</code></td>
<td class="grid"><code>MOVQ2DQ xmm, mm</code></td>
<td class="grid">Move quadword from mmx to low quadword of xmm.</td>
</tr>
</table></td><td>
<p>Moves the quadword from the source operand (second operand) to the low quadword of the destination operand (first operand). The source operand is an MMX technology register and the destination operand is an XMM register.</p>
<p>This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the MOVQ2DQ instruction is executed.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVS/MOVSB/MOVSW/MOVSD</strong><br />Move Data from String to String<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>A4</code></td>
<td class="grid"><code>MOVS m8, m8</code></td>
<td class="grid">Move byte at address DS:(E)SI to address ES:(E)DI.</td>
</tr>
<tr>
<td class="grid"><code>A5</code></td>
<td class="grid"><code>MOVS m16, m16</code></td>
<td class="grid">Move word at address DS:(E)SI to address ES:(E)DI.</td>
</tr>
<tr>
<td class="grid"><code>A5</code></td>
<td class="grid"><code>MOVS m32, m32</code></td>
<td class="grid">Move doubleword at address DS:(E)SI to address ES:(E)DI.</td>
</tr>
<tr>
<td class="grid"><code>A4</code></td>
<td class="grid"><code>MOVSB</code></td>
<td class="grid">Move byte at address DS:(E)SI to address ES:(E)DI.</td>
</tr>
<tr>
<td class="grid"><code>A5</code></td>
<td class="grid"><code>MOVSW</code></td>
<td class="grid">Move word at address DS:(E)SI to address ES:(E)DI.</td>
</tr>
<tr>
<td class="grid"><code>A5</code></td>
<td class="grid"><code>MOVSD</code></td>
<td class="grid">Move doubleword at address DS:(E)SI to address</td>
</tr>
</table></td><td>
<p>Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified with the first operand (destination operand). Both the source and destination operands are located in memory. The address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively).</p>
<p>The address of the destination operand is read from the ES:EDI or the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.</p>
<p>At the assembly-code level, two forms of this instruction are allowed: the &quot;explicit-operands&quot; form and the &quot;no-operands&quot; form. The explicit-operands form (specified with the MOVS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source and destination operands should be symbols that indicate the size and location of the source value and the destination, respectively. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading.</p>
<p>That is, the source and destination operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords), but they do not have to specify the correct location.</p>
<p>The locations of the source and destination operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the move string instruction is executed.</p>
<p>The no-operands form provides &quot;short forms&quot; of the byte, word, and doubleword versions of the MOVS instructions. Here also DS:(E)SI and ES:(E)DI are assumed to be the source and destination operands, respectively. The size of the source and destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW (word move), or MOVSD (doubleword move).</p>
<p>After the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incremented; if the DF flag is 1, the (E)SI and (E)DI registers are decremented.) The registers are incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.</p>
<p>The MOVS, MOVSB, MOVSW, and MOVSD instructions can be preceded by the REP prefix (see &quot;REP/REPE/REPZ/REPNE /REPNZ-Repeat String Operation Prefix&quot; in Chapter 4) for block moves of ECX bytes, words, or doublewords.</p>
<p>ES:(E)DI.</p>
<br />
<pre>Destination <span class="operator">=</span> Source<span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>IsByteMove<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
	}
}
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>IsWordMove<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
	}
}
<span class="keyword">else</span> { <span class="comment">//doubleword move</span>
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
	}
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>MOVSD</strong><br />Move Scalar Double-Precision Floating-Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 10 /r</code></td>
<td class="grid"><code>MOVSD xmm1, xmm2/m64</code></td>
<td class="grid">Move scalar double-precision floating-point value from xmm2/m64 to xmm1 register.</td>
</tr>
<tr>
<td class="grid"><code>F2 0F 11 /r</code></td>
<td class="grid"><code>MOVSD xmm2/m64, xmm</code></td>
<td class="grid">Move scalar double-precision floating-point value from xmm1 register to xmm2/m64.</td>
</tr>
</table></td><td>
<p>Moves a scalar double-precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be XMM registers or 64-bit memory locations. This instruction can be used to move a double-precision floating-point value to and from the low quadword of an XMM register and a 64-bit memory location, or to move a double-precision floating-point value between the low quadwords of two XMM registers. The instruction cannot be used to transfer data between memory locations.</p>
<p>When the source and destination operands are XMM registers, the high quadword of the destination operand remains unchanged. When the source operand is a memory location and destination operand is an XMM registers, the high quadword of the destination operand is cleared to all 0s.</p>
<br />
<pre><span class="comment">//MOVSD instruction when source and destination operands are XMM registers:</span>
<span class="keyword">if</span><span class="operator">(</span>IsXMM<span class="operator">(</span>Source<span class="operator">)</span> <span class="operator">&amp;&amp;</span> IsXMM<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[64..127] remains unchanged</span>
<span class="comment">//MOVSD instruction when source operand is XMM register and destination operand is memory location:</span>
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>IsXMM<span class="operator">(</span>Source<span class="operator">)</span> <span class="operator">&amp;&amp;</span> IsMemory<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">)</span> Destination <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//MOVSD instruction when source operand is memory location and destination operand is XMM register:</span>
<span class="keyword">else</span> {
	Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
}
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVSS</strong><br />Move Scalar Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 10 /r</code></td>
<td class="grid"><code>MOVSS xmm1, xmm2/m32</code></td>
<td class="grid">Move scalar single-precision floating-point value from xmm2/m32 to xmm1 register.</td>
</tr>
<tr>
<td class="grid"><code>F3 0F 11 /r</code></td>
<td class="grid"><code>MOVSS xmm2/m32, xmm1</code></td>
<td class="grid">Move scalar single-precision floating-point value from xmm1 register to xmm2/m32.</td>
</tr>
</table></td><td>
<p>Moves a scalar single-precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be XMM registers or 32-bit memory locations. This instruction can be used to move a single-precision floating-point value to and from the low doubleword of an XMM register and a 32-bit memory location, or to move a single-precision floating-point value between the low doublewords of two XMM registers. The instruction cannot be used to transfer data between memory locations.</p>
<p>When the source and destination operands are XMM registers, the three high-order doublewords of the destination operand remain unchanged. When the source operand is a memory location and destination operand is an XMM registers, the three high-order doublewords of the destination operand are cleared to all 0s.</p>
<br />
<pre><span class="comment">//MOVSS instruction when source and destination operands are XMM registers:</span>
<span class="keyword">if</span><span class="operator">(</span>IsXMM<span class="operator">(</span>Source<span class="operator">)</span> <span class="operator">&amp;&amp;</span> IsXMM<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[32..127] remains unchanged</span>
<span class="comment">//MOVSS instruction when source operand is XMM register and destination operand is memory location:</span>
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>IsXMM<span class="operator">(</span>Source<span class="operator">)</span> <span class="operator">&amp;&amp;</span> IsMemory<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">)</span> Destination <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//MOVSS instruction when source operand is memory location and destination operand is XMM register:</span>
<span class="keyword">else</span> {
	Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">32..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
}
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVSX</strong><br />Move with Sign-Extension<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F BE /r</code></td>
<td class="grid"><code>MOVSX r16,r/m8</code></td>
<td class="grid">Move byte to word with sign-extension.</td>
</tr>
<tr>
<td class="grid"><code>0F BE /r</code></td>
<td class="grid"><code>MOVSX r32,r/m8</code></td>
<td class="grid">Move byte to doubleword, sign-extension.</td>
</tr>
<tr>
<td class="grid"><code>0F BF /r</code></td>
<td class="grid"><code>MOVSX r32,r/m16</code></td>
<td class="grid">Move word to doubleword, sign-extension.</td>
</tr>
</table></td><td>
<p>Copies the contents of the source operand (register or memory location) to the destination operand (register) and sign extends the value to 16 or 32 bits (see Figure 7-6 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1). The size of the converted value depends on the operand-size attribute.</p>
<br />
<pre>Destination <span class="operator">=</span> SignExtend<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>MOVUPD</strong><br />Move Unaligned Packed Double-Precision Floating- Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 10 /r</code></td>
<td class="grid"><code>MOVUPD xmm1, xmm2/m128</code></td>
<td class="grid">Move packed double-precision floating-point values from xmm2/m128 to xmm1.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 11 /r</code></td>
<td class="grid"><code>MOVUPD xmm2/m128, xmm</code></td>
<td class="grid">Move packed double-precision floating-point values from xmm1 to xmm2/m128.</td>
</tr>
</table></td><td>
<p>Moves a double quadword containing two packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, store the contents of an XMM register into a 128-bit memory location, or move data between two XMM registers. When the source or destination operand is a memory operand, the operand may be unaligned on a 16- byte boundary without causing a general-protection exception (#GP) to be generated.</p>
<p>To move double-precision floating-point values to and from memory locations that are known to be aligned on 16-byte boundaries, use the MOVAPD instruction.</p>
<p>While executing in 16-bit addressing mode, a linear address for a 128-bit data access that overlaps the end of a 16-bit segment is not allowed and is defined as reserved behavior. A specific processor implementation may or may not generate a general-protection exception (#GP) in this situation, and the address that spans the end of the segment may or may not wrap around to the beginning of the segment.</p>
<br />
<pre>Destination <span class="operator">=</span> Source<span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVUPS</strong><br />Move Unaligned Packed Single-Precision Floating- Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 10 /r</code></td>
<td class="grid"><code>MOVUPS xmm1, xmm2/m128</code></td>
<td class="grid">Move packed single-precision floating-point values from xmm2/m128 to xmm1.</td>
</tr>
<tr>
<td class="grid"><code>0F 11 /r</code></td>
<td class="grid"><code>MOVUPS xmm2/m128, xmm1</code></td>
<td class="grid">Move packed single-precision floating-point values from xmm1 to xmm2/m128.</td>
</tr>
</table></td><td>
<p>Moves a double quadword containing four packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, store the contents of an XMM register into a 128-bit memory location, or move data between two XMM registers. When the source or destination operand is a memory operand, the operand may be unaligned on a 16- byte boundary without causing a general-protection exception (#GP) to be generated.</p>
<p>To move packed single-precision floating-point values to and from memory locations that are known to be aligned on 16-byte boundaries, use the MOVAPS instruction.</p>
<p>While executing in 16-bit addressing mode, a linear address for a 128-bit data access that overlaps the end of a 16-bit segment is not allowed and is defined as reserved behavior. A specific processor implementation may or may not generate a general-protection exception (#GP) in this situation, and the address that spans the end of the segment may or may not wrap around to the beginning of the segment.</p>
<br />
<pre>Destination <span class="operator">=</span> Source<span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>MOVZX</strong><br />Move with Zero-Extend<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F B6 /r</code></td>
<td class="grid"><code>MOVZX r16,r/m8</code></td>
<td class="grid">Move byte to word with zero-extension.</td>
</tr>
<tr>
<td class="grid"><code>0F B6 /r</code></td>
<td class="grid"><code>MOVZX r32,r/m8</code></td>
<td class="grid">Move byte to doubleword, zero-extension.</td>
</tr>
<tr>
<td class="grid"><code>0F B7 /r</code></td>
<td class="grid"><code>MOVZX r32,r/m16</code></td>
<td class="grid">Move word to doubleword, zero-extension.</td>
</tr>
</table></td><td>
<p>Copies the contents of the source operand (register or memory location) to the destination operand (register) and zero extends the value to 16 or 32 bits. The size of the converted value depends on the operand-size attribute.</p>
<br />
<pre>Destination <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Source<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>MUL</strong><br />Unsigned Multiply<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F6 /4</code></td>
<td class="grid"><code>MUL r/m8</code></td>
<td class="grid">Unsigned multiply (AX = AL * r/m8).</td>
</tr>
<tr>
<td class="grid"><code>F7 /4</code></td>
<td class="grid"><code>MUL r/m16</code></td>
<td class="grid">Unsigned multiply (DX:AX = AX * r/m16).</td>
</tr>
<tr>
<td class="grid"><code>F7 /4</code></td>
<td class="grid"><code>MUL r/m32</code></td>
<td class="grid">Unsigned multiply (EDX:EAX = EAX * r/m32).</td>
</tr>
</table></td><td>
<p>Performs an unsigned multiplication of the first operand (destination operand) and the second operand (source operand) and stores the result in the destination operand. The destination operand is an implied operand located in register AL, AX or EAX (depending on the size of the operand); the source operand is located in a general-purpose register or a memory location. The action of this instruction and the location of the result depends on the opcode and the operand size as shown in the following table.</p>
<div>
<table class="grid">
<caption>MUL Results</caption>
<tr><th>Operand Size</th><th>Source 1</th><th>Source 2</th><th>Destination</th></tr>
<tr><td>Byte</td><td>AL</td><td>r/m8</td><td>AX</td></tr>
<tr><td>Word</td><td>AX</td><td>r/m16</td><td>DX:AX</td></tr>
<tr><td>Doubleword</td><td>EAX</td><td>r/m32</td><td>EDX:EAX</td></tr>
</table>
</div>
<p>The result is stored in register AX, register pair DX:AX, or register pair EDX:EAX (depending on the operand size), with the high-order bits of the product contained in register AH, DX, or EDX, respectively. If the high-order bits of the product are 0, the CF and OF flags are cleared; otherwise, the flags are set.</p>
<br />Byte</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>IsByteOperation<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> AX <span class="operator">=</span> AL <span class="operator">*</span> Source<span class="operator">;</span>
<span class="keyword">else</span> { <span class="comment">//word or doubleword operation</span>
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> DX<span class="operator">:</span>AX <span class="operator">=</span> AX <span class="operator">*</span> Source<span class="operator">;</span> <span class="comment">//word operation</span>
	<span class="keyword">else</span> EDX<span class="operator">:</span>EAX <span class="operator">=</span> EAX <span class="operator">*</span> Source<span class="operator">;</span> <span class="comment">//doubleword operation</span>
}
</pre>
</td></tr><tr><td><strong>MULPD</strong><br />Multiply Packed Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 59 /r</code></td>
<td class="grid"><code>MULPD xmm1, xmm2/m128</code></td>
<td class="grid">Multiply packed double-precision floating-point values in xmm2/m128 by xmm1.</td>
</tr>
</table></td><td>
<p>Performs an SIMD multiply of the two packed double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the packed double-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 11-3 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD double-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>Overflow,</code></td><td>Underflow, Invalid, Precision, Denormal.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>MULPS</strong><br />Multiply Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 59 /r</code></td>
<td class="grid"><code>MULPS xmm1, xmm2/m128</code></td>
<td class="grid">Multiply packed single-precision floating-point values in xmm2/mem by xmm1.</td>
</tr>
</table></td><td>
<p>Performs an SIMD multiply of the four packed single-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD single-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>Overflow,</code></td><td>Underflow, Invalid, Precision, Denormal.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>MULSD</strong><br />Multiply Scalar Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 59 /r</code></td>
<td class="grid"><code>MULSD xmm1, xmm2/m64</code></td>
<td class="grid">Multiply the low double-precision floating-point value in xmm2/mem64 by low double-precision floating-point value in xmm1.</td>
</tr>
</table></td><td>
<p>Multiplies the low double-precision floating-point value in the source operand (second operand) by the low double-precision floating-point value in the destination operand (first operand), and stores the double-precision floating-point result in the destination operand. The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. The high quadword of the destination operand remains unchanged. See Figure 11-4 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of a scalar double-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">*</span> xmm2/m64<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[64..127] remains unchanged</span>
</pre>
</td><td>
Overflow, Underflow, Invalid, Precision, Denormal.
</td></tr><tr><td><strong>MULSS</strong><br />Multiply Scalar Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 59 /r</code></td>
<td class="grid"><code>MULSS xmm1, xmm2/m32</code></td>
<td class="grid">Multiply the low single-precision floating-point value in xmm2/mem by the low single-precision floating-point value in xmm1.</td>
</tr>
</table></td><td>
<p>Multiplies the low single-precision floating-point value from the source operand (second operand) by the low single-precision floating-point value in the destination operand (first operand), and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of a scalar single-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[32..127] remains unchanged</span>
</pre>
</td><td>
<div>
<table class="operations_table">
<tr><td><code>Overflow,</code></td><td>Underflow, Invalid, Precision, Denormal.</td></tr>
</table>
</div>
</td></tr><tr><td><strong>MWAIT</strong><br />Monitor Wait<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 01 C9</code></td>
<td class="grid"><code>MWAIT</code></td>
<td class="grid">A hint that allows the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events; it is architecturally identical to a NOP instruction.</td>
</tr>
</table></td><td>
<p>The MWAIT instruction is designed to operate with the MONITOR instruction. The two instructions allow the definition of an address at which to 'wait' (MONITOR) and an instruction that causes a predefined 'implementation-dependent-optimized operation' to commence at the 'wait' address (MWAIT). The execution of MWAIT is a hint to the processor that it can enter an implementation-dependent-optimized state while waiting for an event or a store operation to the address range armed by the preceding MONITOR instruction in program flow.</p>
<p>EAX and ECX is used to communicate other information to the MWAIT instruction, such as the kind of optimized state the processor should enter. ECX specifies optional extensions for the MWAIT instruction. EAX may contain hints such as the preferred optimized state the processor should enter. For Pentium 4 processors with CPUID signature family = 15 and model = 3, all non-zero values for EAX and ECX are reserved. The processor will raise a general protection fault on the execution of MWAIT with reserved values in ECX, whereas it ignores the setting of reserved bits in EAX.</p>
<p>A store to the address range armed by the MONITOR instruction, an interrupt, an NMI or SMI, a debug exception, a machine check exception, the BINIT# signal, the INIT# signal, or the RESET# signal will exit the implementation-dependent-optimized state. Note that an interrupt will cause the processor to exit only if the state was entered with interrupts enabled.</p>
<p>If a store to the address range causes the processor to exit, execution will resume at the instruction following the MWAIT instruction. If an interrupt (including NMI) caused the processor to exit the implementation-dependent-optimized state, the processor will exit the state and handle the interrupt. If an SMI caused the processor to exit the implementation-dependent-optimized state, execution will resume at the instruction following MWAIT after handling of the SMI.</p>
<p>Unlike the HLT instruction, the MWAIT instruction does not support a restart at the MWAIT instruction. There may also be other implementation-dependent events or time-outs that may take the processor out of the implementation-dependent-optimized state and resume execution at the instruction following the MWAIT.</p>
<p>If the preceding MONITOR instruction did not successfully arm an address range or if the MONITOR instruction has not been executed prior to executing MWAIT, then the processor will not enter the implementation-dependent-optimized state. Execution will resume at the instruction following the MWAIT.</p>
<p>The MWAIT instruction can be executed at any privilege level. The MONITOR CPUID feature flag (ECX[bit 3] when CPUID is executed with EAX = 1) indicates the availability of the MONITOR and MWAIT instruction in a processor. When set, the unconditional execution of MWAIT is supported at privilege level 0 and conditional execution is supported at privilege levels 1 through 3 (software should test for the appropriate support of these instructions before unconditional use).</p>
<p>The operating system or system BIOS may disable this instruction using the IA32_MISC_ENABLES MSR; disabling the instruction clears the CPUID feature flag and causes execution of the MWAIT instruction to generate an illegal opcode exception.</p>
<br />
<pre><span class="comment">/*</span>
<span class="comment">MWAIT takes the argument in EAX as a hint extension and is</span>
<span class="comment">architected to take the argument in ECX as an instruction extension</span>
<span class="comment">MWAIT EAX, ECX</span>
<span class="comment">*/</span>

<span class="keyword">while</span><span class="operator">(</span>GetMonitorState<span class="operator">(</span><span class="operator">)</span> <span class="operator">!=</span> StateArmed<span class="operator">)</span> OptimizedState<span class="operator">(</span>EAX<span class="operator">,</span> ECX<span class="operator">)</span><span class="operator">;</span> <span class="comment">//Monitor Hardware is not in armed state yet => implementation dependent optimized state</span>
SetMonitorState<span class="operator">(</span>MonitorTriggered<span class="operator">)</span><span class="operator">;</span> <span class="comment">//Set the state of Monitor Hardware as Triggered</span>
MONITOR<span class="operator">(</span>EAX<span class="operator">,</span> ECX<span class="operator">,</span> EDX<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>TriggerStoreHappened<span class="operator">)</span> MWAIT<span class="operator">(</span>EAX<span class="operator">,</span> ECX<span class="operator">)</span><span class="operator">;</span>

<span class="comment">/*</span>
<span class="comment">The above code sequence makes sure that a triggering store does not happen between the first</span>
<span class="comment">check of the trigger and the execution of the monitor instruction. Without the second check that</span>
<span class="comment">triggering store would go un-noticed. Typical usage of MONITOR and MWAIT would have the</span>
<span class="comment">above code sequence within a loop.</span>
<span class="comment">*/</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>NEG</strong><br />Two's Complement Negation<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F6 /3</code></td>
<td class="grid"><code>NEG r/m8</code></td>
<td class="grid">Two's complement negate r/m8.</td>
</tr>
<tr>
<td class="grid"><code>F7 /3</code></td>
<td class="grid"><code>NEG r/m16</code></td>
<td class="grid">Two's complement negate r/m16.</td>
</tr>
<tr>
<td class="grid"><code>F7 /3</code></td>
<td class="grid"><code>NEG r/m32</code></td>
<td class="grid">Two's complement negate r/m32.</td>
</tr>
</table></td><td>
<p>Replaces the value of operand (the destination operand) with its two's complement. (This operation is equivalent to subtracting the operand from 0.) The destination operand is located in a general-purpose register or a memory location.</p>
<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Destination <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
<span class="keyword">else</span> CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
Destination <span class="operator">=</span> <span class="operator">-</span>Destination<span class="operator">;</span>
</pre>
</td><td>
<p>The CF flag set to 0 if the source operand is 0; otherwise it is set to 1. The OF, SF, ZF, AF, and PF flags are set according to the result.
</p>
</td></tr><tr><td><strong>NOP</strong><br />No Operation<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>90</code></td>
<td class="grid"><code>NOP</code></td>
<td class="grid">No operation.</td>
</tr>
</table></td><td>
<p>Performs no operation. This instruction is a one-byte instruction that takes up space in the instruction stream but does not affect the machine context, except the EIP register.</p>
<p>The NOP instruction is an alias mnemonic for the XCHG (E)AX, (E)AX instruction.</p>
<br />
<p>None.
</p>
</td><td>
None.
</td></tr><tr><td><strong>NOT</strong><br />One's Complement Negation<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F6 /2</code></td>
<td class="grid"><code>NOT r/m8</code></td>
<td class="grid">Reverse each bit of r/m8.</td>
</tr>
<tr>
<td class="grid"><code>F7 /2</code></td>
<td class="grid"><code>NOT r/m16</code></td>
<td class="grid">Reverse each bit of r/m16.</td>
</tr>
<tr>
<td class="grid"><code>F7 /2</code></td>
<td class="grid"><code>NOT r/m32</code></td>
<td class="grid">Reverse each bit of r/m32.</td>
</tr>
</table></td><td>
<p>Performs a bitwise NOT operation (each 1 is set to 0, and each 0 is set to 1) on the destination operand and stores the result in the destination operand location. The destination operand can be a register or a memory location.</p>
<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<br />
<pre>Destination <span class="operator">=</span> <span class="operator">~</span>Destination<span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>OR</strong><br />Logical Inclusive OR<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0C ib</code></td>
<td class="grid"><code>OR AL,imm8</code></td>
<td class="grid">AL OR imm8.</td>
</tr>
<tr>
<td class="grid"><code>0D iw</code></td>
<td class="grid"><code>OR AX,imm16</code></td>
<td class="grid">AX OR imm16.</td>
</tr>
<tr>
<td class="grid"><code>0D id</code></td>
<td class="grid"><code>OR EAX,imm32</code></td>
<td class="grid">EAX OR imm32.</td>
</tr>
<tr>
<td class="grid"><code>80 /1 ib</code></td>
<td class="grid"><code>OR r/m8,imm8</code></td>
<td class="grid">r/m8 OR imm8.</td>
</tr>
<tr>
<td class="grid"><code>81 /1 iw</code></td>
<td class="grid"><code>OR r/m16,imm16</code></td>
<td class="grid">r/m16 OR imm16.</td>
</tr>
<tr>
<td class="grid"><code>81 /1 id</code></td>
<td class="grid"><code>OR r/m32,imm32</code></td>
<td class="grid">r/m32 OR imm32</td>
</tr>
<tr>
<td class="grid"><code>83 /1 ib</code></td>
<td class="grid"><code>OR r/m16,imm8</code></td>
<td class="grid">r/m16 OR imm8 (sign-extended).</td>
</tr>
<tr>
<td class="grid"><code>83 /1 ib</code></td>
<td class="grid"><code>OR r/m32,imm8</code></td>
<td class="grid">r/m32 OR imm8 (sign-extended).</td>
</tr>
<tr>
<td class="grid"><code>08 /r</code></td>
<td class="grid"><code>OR r/m8,r8</code></td>
<td class="grid">r/m8 OR r8.</td>
</tr>
<tr>
<td class="grid"><code>09 /r</code></td>
<td class="grid"><code>OR r/m16,r16</code></td>
<td class="grid">r/m16 OR r16.</td>
</tr>
<tr>
<td class="grid"><code>09 /r</code></td>
<td class="grid"><code>OR r/m32,r32</code></td>
<td class="grid">r/m32 OR r32.</td>
</tr>
<tr>
<td class="grid"><code>0A /r</code></td>
<td class="grid"><code>OR r8,r/m8</code></td>
<td class="grid">r8 OR r/m8.</td>
</tr>
<tr>
<td class="grid"><code>0B /r</code></td>
<td class="grid"><code>OR r16,r/m16</code></td>
<td class="grid">r16 OR r/m16.</td>
</tr>
<tr>
<td class="grid"><code>0B /r</code></td>
<td class="grid"><code>OR r32,r/m32</code></td>
<td class="grid">r32 OR r/m32.</td>
</tr>
</table></td><td>
<p>Performs a bitwise inclusive OR operation between the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result of the OR instruction is set to 0 if both corresponding bits of the first and second operands are 0; otherwise, each bit is set to 1.</p>
<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<br />
<pre>Destination <span class="operator">=</span> Destination <span class="operator">|</span> Source<span class="operator">;</span>
</pre>
</td><td>
<p>The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined.
</p>
</td></tr><tr><td><strong>ORPD</strong><br />Bitwise Logical OR of Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 56 /r</code></td>
<td class="grid"><code>ORPD xmm1, xmm2/m128</code></td>
<td class="grid">Bitwise OR of xmm2/m128 and xmm1..</td>
</tr>
</table></td><td>
<p>Performs a bitwise logical OR of the two packed double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the result in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">|</span> Source<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>ORPS</strong><br />Bitwise Logical OR of Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 56 /r</code></td>
<td class="grid"><code>ORPS xmm1, xmm2/m128</code></td>
<td class="grid">Bitwise OR of xmm2/m128 and xmm1.</td>
</tr>
</table></td><td>
<p>Performs a bitwise logical OR of the four packed single-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the result in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">|</span> Source<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>OUT</strong><br />Output to Port<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>E6 ib</code></td>
<td class="grid"><code>OUT imm8, AL</code></td>
<td class="grid">Output byte in AL to I/O port address imm8.</td>
</tr>
<tr>
<td class="grid"><code>E7 ib</code></td>
<td class="grid"><code>OUT imm8, AX</code></td>
<td class="grid">Output word in AX to I/O port address imm8.</td>
</tr>
<tr>
<td class="grid"><code>E7 ib</code></td>
<td class="grid"><code>OUT imm8, EAX</code></td>
<td class="grid">Output doubleword in EAX to I/O port address imm8.</td>
</tr>
<tr>
<td class="grid"><code>EE</code></td>
<td class="grid"><code>OUT DX, AL</code></td>
<td class="grid">Output byte in AL to I/O port address in DX.</td>
</tr>
<tr>
<td class="grid"><code>EF</code></td>
<td class="grid"><code>OUT DX, AX</code></td>
<td class="grid">Output word in AX to I/O port address in DX.</td>
</tr>
<tr>
<td class="grid"><code>EF</code></td>
<td class="grid"><code>OUT DX, EAX</code></td>
<td class="grid">Output doubleword in EAX to I/O port address in DX.</td>
</tr>
</table></td><td>
<p>Copies the value from the second operand (source operand) to the I/O port specified with the destination operand (first operand). The source operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively); the destination operand can be a byte-immediate or the DX register. Using a byte immediate allows I/O port addresses 0 to 255 to be accessed; using the DX register as a source operand allows I/O ports from 0 to 65,535 to be accessed.</p>
<p>The size of the I/O port being accessed is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.</p>
<p>At the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0.</p>
<p>This instruction is only useful for accessing I/O ports located in the processor's I/O address space. See Chapter 13, Input/Output, in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>PE <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> <span class="operator">(</span>CPL <span class="operator">&gt;</span> IOPL <span class="operator">||</span> VM <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span><span class="operator">)</span> { <span class="comment">//Protected mode with CPL > IOPL or virtual-8086 mode</span>
	<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IOPermission<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//Any I/O Permission Bit for I/O port being accessed = 1</span>
	<span class="keyword">else</span> Destination <span class="operator">=</span> Source<span class="operator">;</span> <span class="comment">//Writes to selected I/O port</span>
}
<span class="comment">//Real Mode or Protected Mode with CPL <= IOPL</span>
<span class="keyword">else</span> Destination <span class="operator">=</span> Source<span class="operator">;</span> <span class="comment">//Writes to selected I/O port</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>OUTS/OUTSB/OUTSW/OUTSD</strong><br />Output String to Port<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>6E</code></td>
<td class="grid"><code>OUTS DX, m8</code></td>
<td class="grid">Output byte from memory location specified in DS:(E)SI to I/O port specified in DX.</td>
</tr>
<tr>
<td class="grid"><code>6F</code></td>
<td class="grid"><code>OUTS DX, m16</code></td>
<td class="grid">Output word from memory location specified in DS:(E)SI to I/O port specified in DX.</td>
</tr>
<tr>
<td class="grid"><code>6F</code></td>
<td class="grid"><code>OUTS DX, m32</code></td>
<td class="grid">Output doubleword from memory location specified in DS:(E)SI to I/O port specified in DX.</td>
</tr>
<tr>
<td class="grid"><code>6E</code></td>
<td class="grid"><code>OUTSB</code></td>
<td class="grid">Output byte from memory location specified in DS:(E)SI to I/O port specified in DX.</td>
</tr>
<tr>
<td class="grid"><code>6F</code></td>
<td class="grid"><code>OUTSW</code></td>
<td class="grid">Output word from memory location specified in DS:(E)SI to I/O port specified in DX.</td>
</tr>
<tr>
<td class="grid"><code>6F</code></td>
<td class="grid"><code>OUTSD</code></td>
<td class="grid">Output doubleword from memory location specified in DS:(E)SI to I/O port specified in DX.</td>
</tr>
</table></td><td>
<p>Copies data from the source operand (second operand) to the I/O port specified with the destination operand (first operand). The source operand is a memory location, the address of which is read from either the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). (The DS segment may be overridden with a segment override prefix.) The destination operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.</p>
<p>At the assembly-code level, two forms of this instruction are allowed: the &quot;explicit-operands&quot; form and the &quot;no-operands&quot; form. The explicit-operands form (specified with the OUTS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand should be a symbol that indicates the size of the I/O port and the source address, and the destination operand must be DX. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI registers, which must be loaded correctly before the OUTS instruction is executed.</p>
<p>The no-operands form provides &quot;short forms&quot; of the byte, word, and doubleword versions of the OUTS instructions. Here also DS:(E)SI is assumed to be the source operand and DX is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic:</p>
<p>OUTSB (byte), OUTSW (word), or OUTSD (doubleword).</p>
<p>After the byte, word, or doubleword is transferred from the memory location to the I/O port, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the (E)SI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.</p>
<p>The OUTS, OUTSB, OUTSW, and OUTSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See &quot;REP/REPE/REPZ/REPNE /REPNZ-Repeat String Operation Prefix&quot; in this chapter for a description of the REP prefix.</p>
<p>This instruction is only useful for accessing I/O ports located in the processor's I/O address space. See Chapter 13, Input/Output, in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>PE <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> <span class="operator">(</span>CPL <span class="operator">&gt;</span> IOPL <span class="operator">||</span> VM <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span><span class="operator">)</span> { <span class="comment">//Protected mode with CPL > IOPL or virtual-8086 mode</span>
	<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IOPermission<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">)</span><span class="operator">;</span> <span class="comment">//Any I/O Permission Bit for I/O port being accessed = 1</span>
	<span class="keyword">else</span> Destination <span class="operator">=</span> Source<span class="operator">;</span> <span class="comment">//Writes to selected I/O port</span>
}
<span class="comment">//Real Mode or Protected Mode with CPL <= IOPL</span>
<span class="keyword">else</span> Destination <span class="operator">=</span> Source<span class="operator">;</span> <span class="comment">//Writes to selected I/O port</span>

<span class="keyword">if</span><span class="operator">(</span>IsByteMove<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
	}
}
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>IsWordMove<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
	}
}
<span class="keyword">else</span> { <span class="comment">//doubleword move</span>
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
	}
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PACKSSWB/PACKSSDW</strong><br />Pack with Signed Saturation<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 63 /r PACKSSWB mm1, mm2/m64 Converts 4 packed signed word integers from mm1 and from mm2/m64 into 8 packed signed byte integers in mm1 using signed saturation.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>66 0F 63 /r PACKSSWB xmm1, xmm2/m128 Converts 8 packed signed word integers from xmm1 and from xmm2/m128 into 16 packed signed byte integers in xmm1 using signed saturation.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>0F 6B /r PACKSSDW mm1, mm2/m64 Converts 2 packed signed doubleword integers from mm1 and from mm2/m64 into 4 packed signed word integers in mm1 using signed saturation.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>66 0F 6B /r PACKSSDW xmm1, xmm2/m128 Converts 4 packed signed doubleword integers from xmm1 and from xmm2/m128 into 8 packed signed word integers in xmm1 using signed saturation.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Converts packed signed word integers into packed signed byte integers (PACKSSWB) or converts packed signed doubleword integers into packed signed word integers (PACKSSDW), using saturation to handle overflow conditions. See Figure 4-1 for an example of the packing operation.</p>
<p>The PACKSSWB instruction converts 4 or 8 signed word integers from the destination operand (first operand) and 4 or 8 signed word integers from the source operand (second operand) into 8 or 16 signed byte integers and stores the result in the destination operand. If a signed word integer value is beyond the range of a signed byte integer (that is, greater than 7FH for a positive integer or greater than 80H for a negative integer), the saturated signed byte integer value of 7FH or 80H, respectively, is stored in the destination.</p>
<p>The PACKSSDW instruction packs 2 or 4 signed doublewords from the destination operand (first operand) and 2 or 4 signed doublewords from the source operand (second operand) into 4 or 8 signed words in the destination operand. If a signed doubleword integer value is beyond the range of a signed word (that is, greater than 7FFFH for a positive integer or greater than 8000H for a negative integer), the saturated signed word integer value of 7FFFH or 8000H, respectively, is stored into the destination.</p>
<p>The PACKSSWB and PACKSSDW instructions operate on either 64-bit or 128-bit operands. When operating on 64-bit operands, the destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location. When operating on 128-bit operands, the destination operand must be an XMM register and the source operand can be either an XMM register or a 128-bit memory location.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> PACKSSWB<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PACKSSWB instruction with 64-bit operands</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PACKSSWB instruction with 128-bit operands</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToSignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PACKSSDW<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PACKSSDW instruction with 64-bit operands</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedDoublewordToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedDoublewordToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedDoublewordToSignedWord<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedDoublewordToSignedWord<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PACKSSDW instruction with 128-bit operands</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedDwordToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedDwordToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedDwordToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedDwordToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedDwordToSignedWord<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedDwordToSignedWord<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedDwordToSignedWord<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedDwordToSignedWord Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PACKUSWB</strong><br />Pack with Unsigned Saturation<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 67 /r</code></td>
<td class="grid"><code>PACKUSWB mm, mm/m64</code></td>
<td class="grid">Converts 4 signed word integers from mm and 4 signed word integers from mm/m64 into 8 unsigned byte integers in mm using unsigned saturation.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 67 /r</code></td>
<td class="grid"><code>PACKUSWB xmm1, xmm2/m128</code></td>
<td class="grid">Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.</td>
</tr>
</table></td><td>
<p>Converts 4 or 8 signed word integers from the destination operand (first operand) and 4 or 8 signed word integers from the source operand (second operand) into 8 or 16 unsigned byte integers and stores the result in the destination operand. (See Figure 4-1 for an example of the packing operation.) If a signed word integer value is beyond the range of an unsigned byte integer (that is, greater than FFH or less than 00H), the saturated unsigned byte integer value of FFH or 00H, respectively, is stored in the destination.</p>
<p>The PACKUSWB instruction operates on either 64-bit or 128-bit operands. When operating on 64-bit operands, the destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location. When operating on 128-bit operands, the destination operand must be an XMM register and the source operand can be either an XMM register or a 128-bit memory location.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
	<span class="comment">//PACKUSWB instruction with 64-bit operands:</span>
	Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//PACKUSWB instruction with 128-bit operands:</span>
	Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> SaturateSignedWordToUnsignedByte<span class="operator">(</span>Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PADDB/PADDW/PADDD</strong><br />Add Packed Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F FC /r PADDB mm, mm/m64</code></td>
<td class="grid"><code>Add packed byte integers from mm/m64 and mm.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>66 0F FC /r PADDB xmm1,xmm2/m128</code></td>
<td class="grid"><code>Add packed byte integers from xmm2/m128 and xmm1.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>0F FD /r PADDW mm, mm/m64</code></td>
<td class="grid"><code>Add packed word integers from mm/m64 and mm.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>66 0F FD /r PADDW xmm1, xmm2/m128</code></td>
<td class="grid"><code>Add packed word integers from xmm2/m128 and xmm1.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>0F FE /r PADDD mm, mm/m64</code></td>
<td class="grid"><code>Add packed doubleword integers from mm/m64 and mm.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>66 0F FE /r PADDD xmm1, xmm2/m128</code></td>
<td class="grid"><code>Add packed doubleword integers from xmm2/m128 and xmm1.</code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Performs an SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.</p>
<p>These instructions can operate on either 64-bit or 128-bit operands. When operating on 64-bit operands, the destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location. When operating on 128- bit operands, the destination operand must be an XMM register and the source operand can be either an XMM register or a 128-bit memory location.</p>
<p>The PADDB instruction adds packed byte integers. When an individual result is too large to be represented in 8 bits (overflow), the result is wrapped around and the low 8 bits are written to the destination operand (that is, the carry is ignored).</p>
<p>The PADDW instruction adds packed word integers. When an individual result is too large to be represented in 16 bits (overflow), the result is wrapped around and the low 16 bits are written to the destination operand.</p>
<p>The PADDD instruction adds packed doubleword integers. When an individual result is too large to be represented in 32 bits (overflow), the result is wrapped around and the low 32 bits are written to the destination operand.</p>
<p>Note that the PADDB, PADDW, and PADDD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values operated on.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> PADDB<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PADDB instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PADDB instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="operator">]</span><span class="number">72..79</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">120..111</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PADDW<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PADDW instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PADDW instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PADDD<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PADDD instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">31..0</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">31..0</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">31..0</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">63..32</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">63..32</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">63..32</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PADDD instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PADDQ</strong><br />Add Packed Quadword Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F D4 /r</code></td>
<td class="grid"><code>PADDQ mm1,mm2/m64</code></td>
<td class="grid">Add quadword integer mm2/m64 to mm1.</td>
</tr>
<tr>
<td class="grid"><code>66 0F D4 /r</code></td>
<td class="grid"><code>PADDQ xmm1,xmm2/m128</code></td>
<td class="grid">Add packed quadword integers xmm2/m128 to xmm1.</td>
</tr>
</table></td><td>
<p>Adds the first operand (destination operand) to the second operand (source operand) and stores the result in the destination operand. The source operand can be a quadword integer stored in an MMX technology register or a 64-bit memory location, or it can be two packed quadword integers stored in an XMM register or an 128-bit memory location. The destination operand can be a quadword integer stored in an MMX technology register or two packed quadword integers stored in an XMM register. When packed quadword operands are used, an SIMD add is performed. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).</p>
<p>Note that the PADDQ instruction can operate on either unsigned or signed (two's complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.</p>
<br />
<pre><span class="comment">//PADDQ instruction with 64-Bit operands:</span>
<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//PADDQ instruction with 128-Bit operands:</span>
<span class="keyword">else</span> {
	Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PADDSB/PADDSW</strong><br />Add Packed Signed Integers with Signed Saturation<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F EC /r</code></td>
<td class="grid"><code>PADDSB mm, mm/m64</code></td>
<td class="grid">Add packed signed byte integers from mm/m64 and mm and saturate the results.</td>
</tr>
<tr>
<td class="grid"><code>66 0F EC /r</code></td>
<td class="grid"><code>PADDSB xmm1</code></td>
<td class="grid">Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results.</td>
</tr>
<tr>
<td class="grid"><code>0F ED /r</code></td>
<td class="grid"><code>PADDSW mm, mm/m64</code></td>
<td class="grid">Add packed signed word integers from mm/m64 and mm and saturate the results.</td>
</tr>
<tr>
<td class="grid"><code>66 0F ED /r</code></td>
<td class="grid"><code>PADDSW xmm1, xmm2/m128</code></td>
<td class="grid">Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results.</td>
</tr>
</table></td><td>
<p>Performs an SIMD add of the packed signed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD operation. Overflow is handled with signed saturation, as described in the following paragraphs.</p>
<p>These instructions can operate on either 64-bit or 128-bit operands. When operating on 64-bit operands, the destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location. When operating on 128- bit operands, the destination operand must be an XMM register and the source operand can be either an XMM register or a 128-bit memory location.</p>
<p>The PADDSB instruction adds packed signed byte integers. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.</p>
<p>The PADDSW instruction adds packed signed word integers. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> PADDSB<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PADDSB instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PADDSB instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="operator">]</span><span class="number">72..79</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">120..111</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PADDSW<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PADDSW instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PADDSW instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PADDUSB/PADDUSW</strong><br />Add Packed Unsigned Integers with Unsigned Saturation<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F DC /r PADDUSB mm, mm/m64</code></td>
<td class="grid"><code>Add packed unsigned byte integers from mm/m64 and mm and saturate the results.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>66 0F DC /r PADDUSB xmm1, xmm2/m128</code></td>
<td class="grid"><code>Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>0F DD /r PADDUSW mm, mm/m64</code></td>
<td class="grid"><code>Add packed unsigned word integers from mm/m64 and mm and saturate the results.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>66 0F DD /r PADDUSW xmm1, xmm2/m128</code></td>
<td class="grid"><code>Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results.</code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Performs an SIMD add of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs.</p>
<p>These instructions can operate on either 64-bit or 128-bit operands. When operating on 64-bit operands, the destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location. When operating on 128- bit operands, the destination operand must be an XMM register and the source operand can be either an XMM register or a 128-bit memory location.</p>
<p>The PADDUSB instruction adds packed unsigned byte integers. When an individual byte result is beyond the range of an unsigned byte integer (that is, greater than FFH), the saturated value of FFH is written to the destination operand.</p>
<p>The PADDUSW instruction adds packed unsigned word integers. When an individual word result is beyond the range of an unsigned word integer (that is, greater than FFFFH), the saturated value of FFFFH is written to the destination operand.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> PADDUSB<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PADDUSB instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PADDUSB instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="operator">]</span><span class="number">72..79</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">120..111</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PADDUSW<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PADDUSW instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWordDestination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWordDestination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWordDestination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PADDUSW instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWordDestination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWordDestination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWordDestination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWordDestination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWordDestination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWordDestination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWordDestination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWordDestination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">+</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PAND</strong><br />Logical AND<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F DB /r</code></td>
<td class="grid"><code>PAND mm, mm/m64</code></td>
<td class="grid">Bitwise AND mm/m64 and mm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F DB /r</code></td>
<td class="grid"><code>PAND xmm1, xmm2/m128</code></td>
<td class="grid">Bitwise AND of xmm2/m128 and xmm1.</td>
</tr>
</table></td><td>
<p>Performs a bitwise logical AND operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. The source operand can be an MMX technology register or a 64-bit memory location or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register. Each bit of the result is set to 1 if the corresponding bits of the first and second operands are 1; otherwise, it is set to 0.</p>
<br />
<pre>Destination <span class="operator">=</span> Destination <span class="operator">&amp;</span> Source<span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PANDN</strong><br />Logical AND NOT<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F DF /r</code></td>
<td class="grid"><code>PANDN mm, mm/m64</code></td>
<td class="grid">Bitwise AND NOT of mm/m64 and mm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F DF /r</code></td>
<td class="grid"><code>PANDN xmm1, xmm2/m128</code></td>
<td class="grid">Bitwise AND NOT of xmm2/m128 and xmm1.</td>
</tr>
</table></td><td>
<p>Performs a bitwise logical NOT of the destination operand (first operand), then performs a bitwise logical AND of the source operand (second operand) and the inverted destination operand. The result is stored in the destination operand. The source operand can be an MMX technology register or a 64-bit memory location or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register. Each bit of the result is set to 1 if the corresponding bit in the first operand is 0 and the corresponding bit in the second operand is 1; otherwise, it is set to 0.</p>
<br />
<pre>Destination <span class="operator">=</span> <span class="operator">~</span>Destination <span class="operator">&amp;</span> Source<span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PAUSE</strong><br />Spin Loop Hint<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 90</code></td>
<td class="grid"><code>PAUSE</code></td>
<td class="grid">Gives hint to processor that improves performance of spin-wait loops.</td>
</tr>
</table></td><td>
<p>Improves the performance of spin-wait loops. When executing a &quot;spin-wait loop,&quot; a Pentium 4 or Intel Xeon processor suffers a severe performance penalty when exiting the loop because it detects a possible memory order violation. The PAUSE instruction provides a hint to the processor that the code sequence is a spin-wait loop. The processor uses this hint to avoid the memory order violation in most situations, which greatly improves processor performance. For this reason, it is recommended that a PAUSE instruction be placed in all spin-wait loops.</p>
<p>An additional function of the PAUSE instruction is to reduce the power consumed by a Pentium 4 processor while executing a spin loop. The Pentium 4 processor can execute a spinwait loop extremely quickly, causing the processor to consume a lot of power while it waits for the resource it is spinning on to become available. Inserting a pause instruction in a spinwait loop greatly reduces the processor's power consumption.</p>
<p>This instruction was introduced in the Pentium 4 processors, but is backward compatible with all IA-32 processors. In earlier IA-32 processors, the PAUSE instruction operates like a NOP instruction. The Pentium 4 and Intel Xeon processors implement the PAUSE instruction as a pre-defined delay. The delay is finite and can be zero for some processors. This instruction does not change the architectural state of the processor (that is, it performs essentially a delaying noop operation).</p>
<br />
<pre>ExecuteNextInstruction<span class="operator">(</span>Delay<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
None.
</td></tr><tr><td><strong>PAVGB/PAVGW</strong><br />Average Packed Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F E0 /r PAVGB mm1, mm2/m64 Average packed unsigned byte integers from mm2/m64 and mm1 with rounding.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>66 0F E0, /r PAVGB xmm1, xmm2/m128 Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>0F E3 /r PAVGW mm1, mm2/m64 Average packed unsigned word integers from mm2/m64 and mm1 with rounding.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>66 0F E3 /r PAVGW xmm1, xmm2/m128 Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Performs an SIMD average of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the results in the destination operand. For each corresponding pair of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary sum, and that result is shifted right one bit position. The source operand can be an MMX technology register or a 64-bit memory location or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register.</p>
<p>The PAVGB instruction operates on packed unsigned bytes and the PAVGW instruction operates on packed unsigned words.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> PAVGB<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PAVGB instruction with 64-bit operands:</span>
			<span class="comment">//temporary sum before shifting is 9 bits</span>
			Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PAVGB instruction with 128-bit operands:</span>
			<span class="comment">//temporary sum before shifting is 9 bits</span>
			Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PAVGW<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PAVGW instruction with 64-bit operands:</span>
			<span class="comment">//temporary sum before shifting is 17 bits</span>
			Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PAVGW instruction with 128-bit operands:</span>
			<span class="comment">//temporary sum before shifting is 17 bits</span>
			Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
			Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">+</span> Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PCMPEQB/PCMPEQW/PCMPEQD</strong><br /> Compare Packed Data for Equal<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 74 /r</code></td>
<td class="grid"><code>PCMPEQB mm, mm/m64</code></td>
<td class="grid">Compare packed bytes in mm/m64 and mm for equality.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 74 /r</code></td>
<td class="grid"><code>PCMPEQB xmm1, xmm2/m128</code></td>
<td class="grid">Compare packed bytes in xmm2/m128 and xmm1 for equality.</td>
</tr>
<tr>
<td class="grid"><code>0F 75 /r</code></td>
<td class="grid"><code>PCMPEQW mm, mm/m64</code></td>
<td class="grid">Compare packed words in mm/m64 and mm for equality.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 75 /r</code></td>
<td class="grid"><code>PCMPEQW xmm1, xmm2/m128</code></td>
<td class="grid">Compare packed words in xmm2/m128 and xmm1 for equality.</td>
</tr>
<tr>
<td class="grid"><code>0F 76 /r</code></td>
<td class="grid"><code>PCMPEQD mm, mm/m64</code></td>
<td class="grid">Compare packed doublewords in mm/m64 and mm for equality.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 76 /r</code></td>
<td class="grid"><code>PCMPEQD xmm1, xmm2/m128</code></td>
<td class="grid">Compare packed doublewords in xmm2/m128 and xmm1 for equality.</td>
</tr>
</table></td><td>
<p>Performs an SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s. The source operand can be an MMX technology register or a 64-bit memory location, or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register.</p>
<p>The PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the PCMPEQW instruction compares the corresponding words in the destination and source operands; and the PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> PCMPEQB<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PCMPEQB instruction with 64-bit operands:</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PCMPEQB instruction with 128-bit operands:</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PCMPEQW<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PCMPEQW instruction with 64-bit operands:</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PCMPEQW instruction with 128-bit operands:</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PCMPEQD<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PCMPEQD instruction with 64-bit operands:</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PCMPEQD instruction with 128-bit operands:</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">==</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PCMPGTB/PCMPGTW/PCMPGTD</strong><br />Compare Packed Signed Integers for Greater Than<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 64 /r</code></td>
<td class="grid"><code>PCMPGTB mm, mm/m64</code></td>
<td class="grid">Compare packed signed byte integers in mm and mm/m64 for greater than.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 64 /r</code></td>
<td class="grid"><code>PCMPGTB xmm1, xmm2/m128</code></td>
<td class="grid">Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than.</td>
</tr>
<tr>
<td class="grid"><code>0F 65 /r</code></td>
<td class="grid"><code>PCMPGTW mm, mm/m64</code></td>
<td class="grid">Compare packed signed word integers in mm and mm/m64 for greater than.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 65 /r</code></td>
<td class="grid"><code>PCMPGTW xmm1, xmm2/m128</code></td>
<td class="grid">Compare packed signed word integers in xmm1 and xmm2/m128 for greater than.</td>
</tr>
<tr>
<td class="grid"><code>0F 66 /r</code></td>
<td class="grid"><code>PCMPGTD mm, mm/m64</code></td>
<td class="grid">Compare packed signed doubleword integers in mm and mm/m64 for greater than.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 66 /r</code></td>
<td class="grid"><code>PCMPGTD xmm1, xmm2/m128</code></td>
<td class="grid">Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than.</td>
</tr>
</table></td><td>
<p>Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding date element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s. The source operand can be an MMX technology register or a 64-bit memory location, or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register.</p>
<p>The PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> PCMPGTB<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PCMPGTB instruction with 64-bit operands:</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PCMPGTB instruction with 128-bit operands:</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PCMPGTW<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PCMPGTW instruction with 64-bit operands:</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PCMPGTW instruction with 128-bit operands:</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">:</span>
	<span class="keyword">case</span> PCMPGTD<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PCMPGTD instruction with 64-bit operands:</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PCMPGTD instruction with 128-bit operands:</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">&gt;</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PEXTRW</strong><br />Extract Word<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F C5 /r ib</code></td>
<td class="grid"><code>PEXTRW r32, mm, imm8</code></td>
<td class="grid">Extract the word specified by imm8 from mm and move it to r32.</td>
</tr>
<tr>
<td class="grid"><code>66 0F C5 /r ib</code></td>
<td class="grid"><code>PEXTRW r32, xmm, imm8</code></td>
<td class="grid">Extract the word specified by imm8 from xmm and move it to a r32.</td>
</tr>
</table></td><td>
<p>Copies the word in the source operand (second operand) specified by the count operand (third operand) to the destination operand (first operand). The source operand can be an MMX technology register or an XMM register. The destination operand is the low word of a generalpurpose register. The count operand is an 8-bit immediate. When specifying a word location in an MMX technology register, the 2 least-significant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the location. The high word of the destination operand is cleared (set to all 0s).</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
	<span class="comment">//PEXTRW instruction with 64-bit source operand</span>
	SEL <span class="operator">=</span> COUNT <span class="operator">&amp;</span> <span class="number">3</span><span class="operator">;</span>
	Temporary <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>SEL <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span> <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Temporary<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//PEXTRW instruction with 128-bit source operand:</span>
	SEL <span class="operator">=</span> COUNT <span class="operator">&amp;</span> <span class="number">7</span><span class="operator">;</span>
	Temporary <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>SEL <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span> AND <span class="number">0xFFFF</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Temporary<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PINSRW</strong><br />Insert Word<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F C4 /r ib</code></td>
<td class="grid"><code>PINSRW mm, r32/m16, imm8</code></td>
<td class="grid">Insert the low word from r32 or from m16 into mm at the word position specified by imm8.</td>
</tr>
<tr>
<td class="grid"><code>66 0F C4 /r ib</code></td>
<td class="grid"><code>PINSRW xmm, r32/m16, imm8</code></td>
<td class="grid">Move the low word of r32 or from m16 into xmm at the word position specified by imm8.</td>
</tr>
</table></td><td>
<p>Copies a word from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other words in the destination register are left untouched.) The source operand can be a generalpurpose register or a 16-bit memory location. (When the source operand is a general-purpose register, the low word of the register is copied.) The destination operand can be an MMX technology register or an XMM register. The count operand is an 8-bit immediate. When specifying a word location in an MMX technology register, the 2 least-significant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the location.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>OperandSize<span class="operator">)</span> {
	<span class="keyword">case</span> <span class="number">8</span><span class="operator">:</span>
		<span class="comment">//PINSRW instruction with 64-bit source operand:</span>
		Masks<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
			<span class="number">0x000000000000FFFF</span><span class="operator">,</span>
			<span class="number">0x00000000FFFF0000</span><span class="operator">,</span>
			<span class="number">0x0000FFFF00000000</span><span class="operator">,</span>
			<span class="number">0xFFFF000000000000</span>
		}<span class="operator">;</span>
		SEL <span class="operator">=</span> Count <span class="operator">&amp;</span> <span class="number">3</span><span class="operator">;</span>
		Mask <span class="operator">=</span> Masks<span class="operator">[</span>SEL<span class="operator">]</span><span class="operator">;</span>
		Destination <span class="operator">=</span> <span class="operator">(</span>Destination <span class="operator">&amp;</span> <span class="operator">~</span>Mask<span class="operator">)</span> <span class="operator">|</span> <span class="operator">(</span><span class="operator">(</span><span class="operator">(</span>Source <span class="operator">&lt;&lt;</span> <span class="operator">(</span>SEL <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span> <span class="operator">&amp;</span> Mask<span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">16</span><span class="operator">:</span>
		<span class="comment">//PINSRW instruction with 128-bit source operand:</span>
		Masks<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
			<span class="number">0x0000000000000000000000000000FFFF</span><span class="operator">,</span>
			<span class="number">0x000000000000000000000000FFFF0000</span><span class="operator">,</span>
			<span class="number">0x00000000000000000000FFFF00000000</span><span class="operator">,</span>
			<span class="number">0x0000000000000000FFFF000000000000</span><span class="operator">,</span>
			<span class="number">0x000000000000FFFF0000000000000000</span><span class="operator">,</span>
			<span class="number">0x00000000FFFF00000000000000000000</span><span class="operator">,</span>
			<span class="number">0x0000FFFF000000000000000000000000</span><span class="operator">,</span>
			<span class="number">0xFFFF0000000000000000000000000000</span>
		}<span class="operator">;</span>
		SEL <span class="operator">=</span> Count <span class="operator">&amp;</span> <span class="number">7</span><span class="operator">;</span>
		Mask <span class="operator">=</span> Masks<span class="operator">[</span>SEL<span class="operator">]</span><span class="operator">;</span>
		Destination <span class="operator">=</span> <span class="operator">(</span>Destination <span class="operator">&amp;</span> <span class="operator">~</span>Mask<span class="operator">)</span> <span class="operator">|</span> <span class="operator">(</span><span class="operator">(</span><span class="operator">(</span>Source <span class="operator">&lt;&lt;</span> <span class="operator">(</span>SEL <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span> <span class="operator">&amp;</span> Mask<span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PMADDWD</strong><br />Multiply and Add Packed Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F F5 /r</code></td>
<td class="grid"><code>PMADDWD mm, mm/m64</code></td>
<td class="grid">Multiply the packed words in mm by the packed words in mm/m64, add adjacent doubleword results, and store in mm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F F5 /r</code></td>
<td class="grid"><code>PMADDWD xmm1, xmm2/m128</code></td>
<td class="grid">Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1.</td>
</tr>
</table></td><td>
<p>Multiplies the individual signed words of the destination operand (first operand) by the corresponding signed words of the source operand (second operand), producing temporary signed, doubleword results. The adjacent doubleword results are then summed and stored in the destination operand. For example, the corresponding low-order words (15-0) and (31-16) in the source and destination operands are multiplied by one another and the doubleword results are added together and stored in the low doubleword of the destination register (31-0). The same operation is performed on the other pairs of adjacent words. (Figure 4-2 shows this operation when using 64-bit operands.) The source operand can be an MMX technology register or a 64- bit memory location, or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register.</p>
<p>The PMADDWD instruction wraps around only in one situation: when the 2 pairs of words being operated on in a group are all 8000H. In this case, the result wraps around to 80000000H.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
	<span class="comment">//PMADDWD instruction with 64-bit operands:</span>
	Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">+</span> <span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">+</span> <span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//PMADDWD instruction with 128-bit operands:</span>
	Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">+</span> <span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">+</span> <span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">+</span> <span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">+</span> <span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PMAXSW</strong><br />Maximum of Packed Signed Word Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F EE /r</code></td>
<td class="grid"><code>PMAXSW mm1, mm2/m64</code></td>
<td class="grid">Compare signed word integers in mm2/m64 and mm1 and return maximum values.</td>
</tr>
<tr>
<td class="grid"><code>66 0F EE /r</code></td>
<td class="grid"><code>PMAXSW xmm1, xmm2/m128</code></td>
<td class="grid">Compare signed word integers in xmm2/m128 and xmm1 and return maximum values.</td>
</tr>
</table></td><td>
<p>Performs an SIMD compare of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and returns the maximum value for each pair of word integers to the destination operand. The source operand can be an MMX technology register or a 64-bit memory location, or it can be an XMM register or a 128-bit memory location.</p>
<p>The destination operand can be an MMX technology register or an XMM register.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
	<span class="comment">//PMAXSW instruction for 64-bit operands:</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//PMAXSW instruction for 128-bit operands:</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PMAXUB</strong><br />Maximum of Packed Unsigned Byte Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F DE /r</code></td>
<td class="grid"><code>PMAXUB mm1, mm2/m64</code></td>
<td class="grid">Compare unsigned byte integers in mm2/m64 and mm1 and returns maximum values.</td>
</tr>
<tr>
<td class="grid"><code>66 0F DE /r</code></td>
<td class="grid"><code>PMAXUB xmm1, xmm2/m128</code></td>
<td class="grid">Compare unsigned byte integers in xmm2/m128 and xmm1 and returns maximum values.</td>
</tr>
</table></td><td>
<p>Performs an SIMD compare of the packed unsigned byte integers in the destination operand (first operand) and the source operand (second operand), and returns the maximum value for each pair of byte integers to the destination operand. The source operand can be an MMX technology register or a 64-bit memory location, or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
	<span class="comment">//PMAXUB instruction for 64-bit operands:</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//PMAXUB instruction for 128-bit operands:</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">&lt;=</span> Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PMINSW</strong><br />Minimum of Packed Signed Word Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F EA /r</code></td>
<td class="grid"><code>PMINSW mm1, mm2/m64</code></td>
<td class="grid">Compare signed word integers in mm2/m64 and mm1 and return minimum values.</td>
</tr>
<tr>
<td class="grid"><code>66 0F EA /r</code></td>
<td class="grid"><code>PMINSW xmm1, xmm2/m128</code></td>
<td class="grid">Compare signed word integers in xmm2/m128 and xmm1 and return minimum values.</td>
</tr>
</table></td><td>
<p>Performs an SIMD compare of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and returns the minimum value for each pair of word integers to the destination operand. The source operand can be an MMX technology register or a 64-bit memory location, or it can be an XMM register or a 128-bit memory location.</p>
<p>The destination operand can be an MMX technology register or an XMM register.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
	<span class="comment">//PMINSW instruction for 64-bit operands:</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//PMINSW instruction for 128-bit operands:</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PMINUB</strong><br />Minimum of Packed Unsigned Byte Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F DA /r</code></td>
<td class="grid"><code>PMINUB mm1, mm2/m64</code></td>
<td class="grid">Compare unsigned byte integers in mm2/m64 and mm1 and return minimum values.</td>
</tr>
<tr>
<td class="grid"><code>66 0F DA /r</code></td>
<td class="grid"><code>PMINUB xmm1, xmm2/m128</code></td>
<td class="grid">Compare unsigned byte integers in xmm2/m128 and xmm1 and return minimum values.</td>
</tr>
</table></td><td>
<p>Performs an SIMD compare of the packed unsigned byte integers in the destination operand (first operand) and the source operand (second operand), and returns the minimum value for each pair of byte integers to the destination operand. The source operand can be an MMX technology register or a 64-bit memory location, or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
	<span class="comment">//PMINUB instruction for 64-bit operands:</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//PMINUB instruction for 128-bit operands:</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">&gt;=</span> Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PMOVMSKB</strong><br />Move Byte Mask<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F D7 /r</code></td>
<td class="grid"><code>PMOVMSKB r32, mm Move a byte mask of mm to r32.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>66 0F D7 /r</code></td>
<td class="grid"><code>PMOVMSKB r32, xmm Move a byte mask of xmm to r32.</code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Creates a mask made up of the most significant bit of each byte of the source operand (second operand) and stores the result in the low byte or word of the destination operand (first operand).</p>
<p>The source operand is an MMX technology register or an XMM register; the destination operand is a general-purpose register. When operating on 64-bit operands, the byte mask is 8 bits; when operating on 128-bit operands, the byte mask is 16-bits.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
	<span class="comment">//PMOVMSKB instruction with 64-bit source operand:</span>
	r32<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">7</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">15</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">23</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">31</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">4</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">39</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">5</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">47</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">6</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">55</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">7</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">63</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">8..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//PMOVMSKB instruction with 128-bit source operand:</span>
	r32<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">7</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">15</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">23</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">31</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">4</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">39</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">5</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">47</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">6</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">55</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">7</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">63</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">8</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">71</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">9</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">79</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">10</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">87</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">11</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">95</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">12</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">103</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">13</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">111</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">14</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">119</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">15</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">127</span><span class="operator">]</span><span class="operator">;</span>
	r32<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PMULHUW</strong><br />Multiply Packed Unsigned Integers and Store High Result<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F E4 /r</code></td>
<td class="grid"><code>PMULHUW mm1, mm2/m64</code></td>
<td class="grid">Multiply the packed unsigned word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.</td>
</tr>
<tr>
<td class="grid"><code>66 0F E4 /r</code></td>
<td class="grid"><code>PMULHUW xmm1, xmm2/m128</code></td>
<td class="grid">Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.</td>
</tr>
</table></td><td>
<p>Performs an SIMD unsigned multiply of the packed unsigned word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each 32-bit intermediate results in the destination operand. (Figure 4-3 shows this operation when using 64-bit operands.) The source operand can be an MMX technology register or a 64- bit memory location, or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
<span class="comment">//PMULHUW instruction with 64-bit operands:</span>
	<span class="comment">//Unsigned multiplication</span>
	Temporary0<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Temporary1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Temporary2<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
	Temporary3<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Temporary0<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Temporary1<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Temporary2<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Temporary3<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//PMULHUW instruction with 128-bit operands:</span>
	<span class="comment">//Unsigned multiplication</span>
	Temporary0<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Temporary1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Temporary2<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
	Temporary3<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
	Temporary4<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">;</span>
	Temporary5<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">;</span>
	Temporary6<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">;</span>
	Temporary7<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Temporary0<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Temporary1<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Temporary2<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Temporary3<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> Temporary4<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> Temporary5<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> Temporary6<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> Temporary7<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PMULHW</strong><br />Multiply Packed Signed Integers and Store High Result<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F E5 /r</code></td>
<td class="grid"><code>PMULHW mm, mm/m64</code></td>
<td class="grid">Multiply the packed signed word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.</td>
</tr>
<tr>
<td class="grid"><code>66 0F E5 /r</code></td>
<td class="grid"><code>PMULHW xmm1, xmm2/m128</code></td>
<td class="grid">Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.</td>
</tr>
</table></td><td>
<p>Performs an SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each intermediate 32-bit result in the destination operand. (Figure 4-3 shows this operation when using 64-bit operands.) The source operand can be an MMX technology register or a 64-bit memory location, or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
	<span class="comment">//PMULHW instruction with 64-bit operands:</span>
	<span class="comment">//Signed multiplication</span>
	Temporary0<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Temporary1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Temporary2<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
	Temporary3<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Temporary0<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Temporary1<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Temporary2<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Temporary3<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//PMULHW instruction with 128-bit operands:</span>
	<span class="comment">//Signed multiplication</span>
	Temporary0<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Temporary1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Temporary2<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
	Temporary3<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
	Temporary4<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">;</span>
	Temporary5<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">;</span>
	Temporary6<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">;</span>
	Temporary7<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Temporary0<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Temporary1<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Temporary2<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Temporary3<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> Temporary4<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> Temporary5<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> Temporary6<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> Temporary7<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PMULLW</strong><br />Multiply Packed Signed Integers and Store Low Result<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F D5 /r</code></td>
<td class="grid"><code>PMULLW mm, mm/m64 Multiply the packed signed word integers in mm1 register and mm2/m64, and store the low 16 bits of the results in mm1.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>66 0F D5 /r</code></td>
<td class="grid"><code>PMULLW xmm1, xmm2/m128 Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1.</code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Performs an SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the low 16 bits of each intermediate 32-bit result in the destination operand. (Figure 4-3 shows this operation when using 64-bit operands.) The source operand can be an MMX technology register or a 64-bit memory location, or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
	<span class="comment">//PMULLW instruction with 64-bit operands:</span>
	<span class="comment">//Signed multiplication</span>
	Temporary0<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Temporary1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Temporary2<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
	Temporary3<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Temporary0<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Temporary1<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Temporary2<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Temporary3<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//PMULLW instruction with 64-bit operands:</span>
	<span class="comment">//Signed multiplication</span>
	Temporary0<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Temporary1<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
	Temporary2<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
	Temporary3<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
	Temporary4<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">;</span>
	Temporary5<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">;</span>
	Temporary6<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">;</span>
	Temporary7<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Temporary0<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Temporary1<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Temporary2<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Temporary3<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> Temporary4<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> Temporary5<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> Temporary6<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> Temporary7<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PMULUDQ</strong><br />Multiply Packed Unsigned Doubleword Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F F4 /r</code></td>
<td class="grid"><code>PMULUDQ mm1, mm2/m64</code></td>
<td class="grid">Multiply unsigned doubleword integer in mm1 by unsigned doubleword integer in mm2/m64, and store the quadword result in mm1.</td>
</tr>
<tr>
<td class="grid"><code>66 0F F4 /r</code></td>
<td class="grid"><code>PMULUDQ xmm1, xmm2/m128</code></td>
<td class="grid">Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1.</td>
</tr>
</table></td><td>
<p>Multiplies the first operand (destination operand) by the second operand (source operand) and stores the result in the destination operand. The source operand can be an unsigned doubleword integer stored in the low doubleword of an MMX technology register or a 64-bit memory location, or it can be two packed unsigned doubleword integers stored in the first (low) and third doublewords of an XMM register or an 128-bit memory location. The destination operand can be an unsigned doubleword integer stored in the low doubleword an MMX technology register or two packed doubleword integers stored in the first and third doublewords of an XMM register. The result is an unsigned quadword integer stored in the destination an MMX technology register or two packed unsigned quadword integers stored in an XMM register. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).</p>
<p>For 64-bit memory operands, 64 bits are fetched from memory, but only the low doubleword is used in the computation; for 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation.</p>
<br />
<pre><span class="comment">//PMULUDQ instruction with 64-Bit operands:</span>
<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//PMULUDQ instruction with 128-Bit operands:</span>
<span class="keyword">else</span> {
	Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">*</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>POP</strong><br />Pop a Value from the Stack<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>8F /0</code></td>
<td class="grid"><code>POP r/m16</code></td>
<td class="grid">Pop top of stack into m16; increment stack pointer.</td>
</tr>
<tr>
<td class="grid"><code>8F /0</code></td>
<td class="grid"><code>POP r/m32</code></td>
<td class="grid">Pop top of stack into m32; increment stack pointer.</td>
</tr>
<tr>
<td class="grid"><code>58+ rw</code></td>
<td class="grid"><code>POP r16</code></td>
<td class="grid">Pop top of stack into r16; increment stack pointer.</td>
</tr>
<tr>
<td class="grid"><code>58+ rd</code></td>
<td class="grid"><code>POP r32 Pop top of stack into r32; increment stack pointer.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>1F</code></td>
<td class="grid"><code>POP DS</code></td>
<td class="grid">Pop top of stack into DS; increment stack pointer.</td>
</tr>
<tr>
<td class="grid"><code>07</code></td>
<td class="grid"><code>POP ES</code></td>
<td class="grid">Pop top of stack into ES; increment stack pointer.</td>
</tr>
<tr>
<td class="grid"><code>17</code></td>
<td class="grid"><code>POP SS</code></td>
<td class="grid">Pop top of stack into SS; increment stack pointer.</td>
</tr>
<tr>
<td class="grid"><code>0F A1</code></td>
<td class="grid"><code>POP FS</code></td>
<td class="grid">Pop top of stack into FS; increment stack pointer.</td>
</tr>
<tr>
<td class="grid"><code>0F A9</code></td>
<td class="grid"><code>POP GS</code></td>
<td class="grid">Pop top of stack into GS; increment stack pointer.</td>
</tr>
</table></td><td>
<p>Loads the value from the top of the stack to the location specified with the destination operand and then increments the stack pointer. The destination operand can be a general-purpose register, memory location, or segment register.</p>
<p>The address-size attribute of the stack segment determines the stack pointer size (16 bits or 32 bits-the source address size), and the operand-size attribute of the current code segment determines the amount the stack pointer is incremented (2 bytes or 4 bytes). For example, if these address- and operand-size attributes are 32, the 32-bit ESP register (stack pointer) is incremented by 4 and, if they are 16, the 16-bit SP register is incremented by 2. (The B flag in the stack segment's segment descriptor determines the stack's address-size attribute, and the D flag in the current code segment's segment descriptor, along with prefixes, determines the operandsize attribute and also the address-size attribute of the destination operand.) If the destination operand is one of the segment registers DS, ES, FS, GS, or SS, the value loaded into the register must be a valid segment selector. In protected mode, popping a segment selector into a segment register automatically causes the descriptor information associated with that segment selector to be loaded into the hidden (shadow) part of the segment register and causes the selector and the descriptor information to be validated (see the &quot;Operation&quot; section below).</p>
<p>A null value (0000-0003) may be popped into the DS, ES, FS, or GS register without causing a general protection fault. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded with a null value causes a general protection exception (#GP). In this situation, no memory reference occurs and the saved value of the segment register is null.</p>
<p>The POP instruction cannot pop a value into the CS register. To load the CS register from the stack, use the RET instruction.</p>
<p>If the ESP register is used as a base register for addressing a destination operand in memory, the POP instruction computes the effective address of the operand after it increments the ESP register. For the case of a 16-bit stack where ESP wraps to 0h as a result of the POP instruction, the resulting location of the memory write is processor-family-specific.</p>
<p>The POP ESP instruction increments the stack pointer (ESP) before data at the old top of stack is written into the destination.</p>
<p>A POP SS instruction inhibits all interrupts, including the NMI interrupt, until after execution of the next instruction. This action allows sequential execution of POP SS and MOV ESP, EBP instructions without the danger of having an invalid stack during an interrupt1. However, use of the LSS instruction is the preferred method of loading the SS and ESP registers.</p>
<br />
<pre><span class="comment">/*</span>
<span class="comment">1. Note that in a sequence of instructions that individually delay interrupts past the following instruction, only</span>
<span class="comment">the first instruction in the sequence is guaranteed to delay the interrupt, but subsequent interrupt-delaying</span>
<span class="comment">instructions may not delay the interrupt. Thus, in the following instruction sequence:</span>
<span class="comment">	STI</span>
<span class="comment">	POP SS</span>
<span class="comment">	POP ESP</span>
<span class="comment">interrupts may be recognized before the POP ESP executes, because STI also delays interrupts for one instruction.</span>
<span class="comment">*/</span>

<span class="keyword">if</span><span class="operator">(</span>StackAddressSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
		Destination <span class="operator">=</span> SS<span class="operator">:</span>ESP<span class="operator">;</span> <span class="comment">//copy a doubleword</span>
		ESP <span class="operator">=</span> ESP <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> { <span class="comment">//OperandSize == 16</span>
		Destination <span class="operator">=</span> SS<span class="operator">:</span>ESP<span class="operator">;</span> <span class="comment">//copy word</span>
		ESP <span class="operator">=</span> ESP <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
	}
}
<span class="keyword">else</span> { <span class="comment">//StackAddressSize == 16</span>
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> {
		Destination<span class="operator">=</span> SS<span class="operator">:</span>SP<span class="operator">;</span> <span class="comment">//copy a word</span>
		SP <span class="operator">=</span> SP <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> { <span class="comment">//OperanSize == 32</span>
		Destination <span class="operator">=</span> SS<span class="operator">:</span>SP<span class="operator">;</span> <span class="comment">//copy a doubleword</span>
		SP <span class="operator">=</span> SP <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
	}
}

<span class="comment">/*</span>
<span class="comment">Loading a segment register while in protected mode results in special actions, as described in</span>
<span class="comment">the following listing. These checks are performed on the segment selector and the segment</span>
<span class="comment">descriptor it points to.</span>
<span class="comment">*/</span>

<span class="keyword">if</span><span class="operator">(</span>IsLoaded<span class="operator">(</span>SS<span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>SegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>SegmentSelector<span class="operator">.</span>Index<span class="operator">)</span> <span class="operator">||</span> SegmentSelector<span class="operator">.</span>RPL <span class="operator">!=</span> CPL <span class="operator">||</span> <span class="operator">!</span>IsWritableDataSegment<span class="operator">(</span>SegmentSelector<span class="operator">)</span> <span class="operator">||</span> DPL <span class="operator">!=</span> CPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>Segment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	SS <span class="operator">=</span> SegmentSelector<span class="operator">;</span>
	SS <span class="operator">=</span> SegmentDescriptor<span class="operator">;</span>
}

<span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>IsLoaded<span class="operator">(</span>DS<span class="operator">)</span> <span class="operator">||</span> IsLoaded<span class="operator">(</span>ES<span class="operator">)</span> <span class="operator">||</span> IsLoaded<span class="operator">(</span>FS<span class="operator">)</span> <span class="operator">||</span> IsLoaded<span class="operator">(</span>GS<span class="operator">)</span><span class="operator">)</span> <span class="operator">&amp;&amp;</span> SegmentSelector <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> { <span class="comment">//DS, ES, FS, or GS is loaded with non-null segment selector</span>
	<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>SegmentSelector<span class="operator">.</span>Index<span class="operator">)</span> <span class="operator">||</span> IsData<span class="operator">(</span>SegmentSelector<span class="operator">)</span> <span class="operator">||</span> IsReadableCodeSegment<span class="operator">(</span>SegmentSelector<span class="operator">)</span> <span class="operator">||</span> <span class="operator">(</span>IsData<span class="operator">(</span>Segment<span class="operator">)</span> <span class="operator">||</span> <span class="operator">!</span>IsConformingCodeSegment<span class="operator">(</span>Segment<span class="operator">)</span> <span class="operator">&amp;&amp;</span> RPL <span class="operator">&gt;</span> DPL <span class="operator">&amp;&amp;</span> CPL <span class="operator">&gt;</span> DPL<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>Segment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">else</span> {
		SegmentRegister <span class="operator">=</span> SegmentSelector<span class="operator">;</span>
		SegmentRegister <span class="operator">=</span> SegmenDescriptor<span class="operator">;</span>
	}
}

<span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>IsLoaded<span class="operator">(</span>DS<span class="operator">)</span> <span class="operator">||</span> IsLoaded<span class="operator">(</span>ES<span class="operator">)</span> <span class="operator">||</span> IsLoaded<span class="operator">(</span>FS<span class="operator">)</span> <span class="operator">||</span> IsLoaded<span class="operator">(</span>GS<span class="operator">)</span><span class="operator">)</span> <span class="operator">&amp;&amp;</span> SegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> { <span class="comment">//DS, ES, FS, or GS is loaded with a null segment selector</span>
	SegmentRegister <span class="operator">=</span> SegmentSelector<span class="operator">;</span>
	SegmentRegister <span class="operator">=</span> SegmenDescriptor<span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>POPA/POPAD</strong><br />Pop All General-Purpose Registers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>61 POPA</code></td>
<td class="grid"><code>Pop DI, SI, BP, BX, DX, CX, and AX.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>61 POPAD</code></td>
<td class="grid"><code>Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX.</code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Pops doublewords (POPAD) or words (POPA) from the stack into the general-purpose registers.</p>
<p>The registers are loaded in the following order: EDI, ESI, EBP, EBX, EDX, ECX, and EAX (if the operand-size attribute is 32) and DI, SI, BP, BX, DX, CX, and AX (if the operand-size attribute is 16). (These instructions reverse the operation of the PUSHA/PUSHAD instructions.) The value on the stack for the ESP or SP register is ignored. Instead, the ESP or SP register is incremented after each register is loaded.</p>
<p>The POPA (pop all) and POPAD (pop all double) mnemonics reference the same opcode. The POPA instruction is intended for use when the operand-size attribute is 16 and the POPAD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when POPA is used and to 32 when POPAD is used (using the operand-size override prefix [66H] if necessary). Others may treat these mnemonics as synonyms (POPA/POPAD) and use the current setting of the operand-size attribute to determine the size of values to be popped from the stack, regardless of the mnemonic used. (The D flag in the current code segment's segment descriptor determines the operand-size attribute.)</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
	<span class="comment">//Instruction == POPAD</span>
	EDI <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	ESI <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	EBP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	ESP <span class="operator">=</span> ESP <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span> <span class="comment">//skip next 4 bytes of stack</span>
	EBX <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	EDX <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	ECX <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	EAX <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//OperandSize == 16, instruction == POPA</span>
	DI <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	SI <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	BP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	ESP <span class="operator">=</span> ESP <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span> <span class="comment">//skip next 2 bytes of stack</span>
	BX <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	DX <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	CX <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	AX <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>POPF/POPFD</strong><br />Pop Stack into EFLAGS Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>9D POPF</code></td>
<td class="grid"><code>Pop top of stack into lower 16 bits of EFLAGS.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>9D POPFD</code></td>
<td class="grid"><code>Pop top of stack into EFLAGS.</code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Pops a doubleword (POPFD) from the top of the stack (if the current operand-size attribute is 32) and stores the value in the EFLAGS register, or pops a word from the top of the stack (if the operand-size attribute is 16) and stores it in the lower 16 bits of the EFLAGS register (that is, the FLAGS register). These instructions reverse the operation of the PUSHF/PUSHFD instructions.</p>
<p>The POPF (pop flags) and POPFD (pop flags double) mnemonics reference the same opcode.</p>
<p>The POPF instruction is intended for use when the operand-size attribute is 16 and the POPFD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when POPF is used and to 32 when POPFD is used. Others may treat these mnemonics as synonyms (POPF/POPFD) and use the current setting of the operand-size attribute to determine the size of values to be popped from the stack, regardless of the mnemonic used.</p>
<p>The effect of the POPF/POPFD instructions on the EFLAGS register changes slightly, depending on the mode of operation of the processor. When the processor is operating in protected mode at privilege level 0 (or in real-address mode, which is equivalent to privilege level 0), all the non-reserved flags in the EFLAGS register except the VIP, VIF, and VM flags can be modified. The VIP and VIF flags are cleared, and the VM flag is unaffected.</p>
<p>When operating in protected mode, with a privilege level greater than 0, but less than or equal to IOPL, all the flags can be modified except the IOPL field and the VIP, VIF, and VM flags.</p>
<p>Here, the IOPL flags are unaffected, the VIP and VIF flags are cleared, and the VM flag is unaffected.</p>
<p>The interrupt flag (IF) is altered only when executing at a level at least as privileged as the IOPL. If a POPF/POPFD instruction is executed with insufficient privilege, an exception does not occur, but the privileged bits do not change.</p>
<p>When operating in virtual-8086 mode, the I/O privilege level (IOPL) must be equal to 3 to use POPF/POPFD instructions and the VM, RF, IOPL, VIP, and VIF flags are unaffected. If the IOPL is less than 3, the POPF/POPFD instructions cause a general-protection exception (#GP).</p>
<p>See the section titled &quot;EFLAGS Register&quot; in Chapter 3 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for information about the EFLAGS registers.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>VM <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> { <span class="comment">//Not in Virtual-8086 Mode</span>
	<span class="keyword">if</span><span class="operator">(</span>CPL <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> EFLAGS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//All non-reserved flags except VIP, VIF, and VM can be modified; VIP and VIF are cleared; VM is unaffected</span>
		<span class="comment">//OperandSize == 16</span>
		<span class="keyword">else</span> EFLAGS<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//All non-reserved flags can be modified</span>
	}
	<span class="keyword">else</span> { <span class="comment">//CPL > 0</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> EFLAGS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//All non-reserved bits except IOPL, VIP, and VIF can be modified; IOPL is unaffected; VIP and VIF are cleared; VM is unaffected</span>
		<span class="comment">//OperandSize == 16</span>
		<span class="keyword">else</span> EFLAGS<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//All non-reserved bits except IOPL can be modified; IOPL is unaffected</span>
	}
}
<span class="keyword">else</span> { <span class="comment">//In Virtual-8086 Mode</span>
	<span class="keyword">if</span><span class="operator">(</span>IOPL <span class="operator">==</span> <span class="number">3</span><span class="operator">)</span> {
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> EFLAGS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//All non-reserved bits except VM, RF, IOPL, VIP, and VIF can be modified; VM, RF, IOPL, VIP, and VIF are unaffected</span>
		<span class="comment">//OperandSize == 16</span>
		<span class="keyword">else</span> EFLAGS<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//All non-reserved bits except IOPL can be modified; IOPL is unaffected</span>
	}
	<span class="comment">//IOPL > 3</span>
	<span class="keyword">else</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//trap to virtual-8086 monitor</span>
}
</pre>
</td><td>
<p>All flags except the reserved bits and the VM bit.
</p>
</td></tr><tr><td><strong>POR</strong><br />Bitwise Logical OR<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F EB /r</code></td>
<td class="grid"><code>POR mm, mm/m64</code></td>
<td class="grid">Bitwise OR of mm/m64 and mm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F EB /r</code></td>
<td class="grid"><code>POR xmm1, xmm2/m128</code></td>
<td class="grid">Bitwise OR of xmm2/m128 and xmm1.</td>
</tr>
</table></td><td>
<p>Performs a bitwise logical OR operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. The source operand can be an MMX technology register or a 64-bit memory location or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register. Each bit of the result is set to 1 if either or both of the corresponding bits of the first and second operands are 1; otherwise, it is set to 0.</p>
<br />
<pre>Destination <span class="operator">=</span> Destination <span class="operator">|</span> Source<span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PREFETCHh</strong><br />Prefetch Data Into Caches<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 18 /1</code></td>
<td class="grid"><code>PREFETCHT0 m8</code></td>
<td class="grid">Move data from m8 closer to the processor using T0 hint.</td>
</tr>
<tr>
<td class="grid"><code>0F 18 /2</code></td>
<td class="grid"><code>PREFETCHT1 m8</code></td>
<td class="grid">Move data from m8 closer to the processor using T1 hint.</td>
</tr>
<tr>
<td class="grid"><code>0F 18 /3</code></td>
<td class="grid"><code>PREFETCHT2 m8</code></td>
<td class="grid">Move data from m8 closer to the processor using T2 hint.</td>
</tr>
<tr>
<td class="grid"><code>0F 18 /0</code></td>
<td class="grid"><code>PREFETCHNTA m8</code></td>
<td class="grid">Move data from m8 closer to the processor using NTA hint.</td>
</tr>
</table></td><td>
<p>Fetches the line of data from memory that contains the byte specified with the source operand to a location in the cache hierarchy specified by a locality hint:</p>
<ul>
<li>T0 (temporal data)-prefetch data into all levels of the cache hierarchy.</li>
<li>Pentium III processor-1st- or 2nd-level cache.</li>
<li>Pentium 4 and Intel Xeon processors-2nd-level cache.</li>
<li>T1 (temporal data with respect to first level cache)-prefetch data into level 2 cache and higher.</li>
<li>Pentium III processor-2nd-level cache.</li>
<li>Pentium 4 and Intel Xeon processors-2nd-level cache.</li>
<li>T2 (temporal data with respect to second level cache)-prefetch data into level 2 cache and higher.</li>
<li>Pentium III processor-2nd-level cache.</li>
<li>Pentium 4 and Intel Xeon processors-2nd-level cache.</li>
<li>NTA (non-temporal data with respect to all cache levels)-prefetch data into non-temporal cache structure and into a location close to the processor, minimizing cache pollution.</li>
<li>Pentium III processor-1st-level cache - Pentium 4 and Intel Xeon processors-2nd-level cache The source operand is a byte memory location. (The locality hints are encoded into the machine level instruction using bits 3 through 5 of the ModR/M byte. Use of any ModR/M value other than the specified ones will lead to unpredictable behavior.) If the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement occurs. Prefetches from uncacheable or WC memory are ignored.</li>
</ul>
<p>The PREFETCHh instruction is merely a hint and does not affect program behavior. If executed, this instruction moves data closer to the processor in anticipation of future use.</p>
<p>The implementation of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a processor implementation. The amount of data prefetched is also processor implementation-dependent. It will, however, be a minimum of 32 bytes.</p>
<p>It should be noted that processors are free to speculatively fetch and cache data from system memory regions that are assigned a memory-type that permits speculative reads (that is, the WB, WC, and WT memory types). A PREFETCHh instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, a PREFETCHh instruction is not ordered with respect to the fence instructions (MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCHh instruction is also unordered with respect to CLFLUSH instructions, other PREFETCHh instructions, or any other general instruction. It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.</p>
<br />
<pre>Fetch<span class="operator">(</span>m8<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td></td></tr><tr><td><strong>PSADBW</strong><br />Compute Sum of Absolute Differences<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F F6 /r</code></td>
<td class="grid"><code>PSADBW mm1, mm2/m64</code></td>
<td class="grid">Computes the absolute differences of the packed unsigned byte integers from mm2 /m64 and mm1; differences are then summed to produce an unsigned word integer result.</td>
</tr>
<tr>
<td class="grid"><code>66 0F F6 /r</code></td>
<td class="grid"><code>PSADBW xmm1, xmm2/m128</code></td>
<td class="grid">Computes the absolute differences of the packed unsigned byte integers from xmm2/m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.</td>
</tr>
</table></td><td>
<p>Computes the absolute value of the difference of 8 unsigned byte integers from the source operand (second operand) and from the destination operand (first operand). These 8 differences are then summed to produce an unsigned word integer result that is stored in the destination operand. The source operand can be an MMX technology register or a 64-bit memory location or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register. Figure 4-5 shows the operation of the PSADBW instruction when using 64-bit operands.</p>
<p>When operating on 64-bit operands, the word integer result is stored in the low word of the destination operand, and the remaining bytes in the destination operand are cleared to all 0s.</p>
<p>When operating on 128-bit operands, two packed results are computed. Here, the 8 low-order bytes of the source and destination operands are operated on to produce a word result that is stored in the low word of the destination operand, and the 8 high-order bytes are operated on to produce a word result that is stored in bits 64 through 79 of the destination operand. The remaining bytes of the destination operand are cleared.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
	<span class="comment">//PSADBW instructions when using 64-bit operands:</span>
	Temporary0 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary1 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary2 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary3 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary4 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary5 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary6 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary7 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> CalculateSum<span class="operator">(</span>Temporary0<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>Temporary7<span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">16..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
}
<span class="keyword">else</span> {
	<span class="comment">//PSADBW instructions when using 128-bit operands:</span>
	Temporary0 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary1 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary2 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary3 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary4 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary5 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary6 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary7 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary8 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary9 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary10 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary11 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary12 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary13 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary14 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Temporary15 <span class="operator">=</span> GetAbsoluteValue<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> CalculateSum<span class="operator">(</span>Temporary0<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>Temporary7<span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">16..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> CalculateSum<span class="operator">(</span>Temporary8<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>Temporary15<span class="operator">)</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">80..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PSHUFD</strong><br />Shuffle Packed Doublewords<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 70 /r ib</code></td>
<td class="grid"><code>PSHUFD xmm1, xmm2/m128, imm8</code></td>
<td class="grid">Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.</td>
</tr>
</table></td><td>
<p>Copies doublewords from source operand (second operand) and inserts them in the destination operand (first operand) at the locations selected with the order operand (third operand). Figure 4-6 shows the operation of the PSHUFD instruction and the encoding of the order operand.</p>
<p>Each 2-bit field in the order operand selects the contents of one doubleword location in the destination operand. For example, bits 0 and 1 of the order operand select the contents of doubleword 0 of the destination operand. The encoding of bits 0 and 1 of the order operand (see the field encoding in Figure 4-6) determines which doubleword from the source operand will be copied to doubleword 0 of the destination operand.</p>
<p>The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The order operand is an 8-bit immediate.</p>
<p>Note that this instruction permits a doubleword in the source operand to be copied to more than one doubleword location in the destination operand.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">0..1</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">32</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">2..3</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">32</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">4..5</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">32</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">6..7</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">32</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PSHUFHW</strong><br />Shuffle Packed High Words<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 70 /r ib</code></td>
<td class="grid"><code>PSHUFHW xmm1, xmm2/m128, imm8 Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.</code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Copies words from the high quadword of the source operand (second operand) and inserts them in the high quadword of the destination operand (first operand) at word locations selected with the order operand (third operand). This operation is similar to the operation used by the PSHUFD instruction, which is illustrated in Figure 4-6. For the PSHUFHW instruction, each 2- bit field in the order operand selects the contents of one word location in the high quadword of the destination operand. The binary encodings of the order operand fields select words (0, 1, 2 or 3, 4) from the high quadword of the source operand to be copied to the destination operand.</p>
<p>The low quadword of the source operand is copied to the low quadword of the destination operand.</p>
<p>The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The order operand is an 8-bit immediate.</p>
<p>Note that this instruction permits a word in the high quadword of the source operand to be copied to more than one word location in the high quadword of the destination operand.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">0..1</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">2..3</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">4..5</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">6..7</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PSHUFLW</strong><br />Shuffle Packed Low Words<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 70 /r ib</code></td>
<td class="grid"><code>PSHUFLW xmm1, xmm2/m128, imm8</code></td>
<td class="grid">Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.</td>
</tr>
</table></td><td>
<p>Copies words from the low quadword of the source operand (second operand) and inserts them in the low quadword of the destination operand (first operand) at word locations selected with the order operand (third operand). This operation is similar to the operation used by the PSHUFD instruction, which is illustrated in Figure 4-6. For the PSHUFLW instruction, each 2- bit field in the order operand selects the contents of one word location in the low quadword of the destination operand. The binary encodings of the order operand fields select words (0, 1, 2, or 3) from the low quadword of the source operand to be copied to the destination operand. The high quadword of the source operand is copied to the high quadword of the destination operand.</p>
<p>The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The order operand is an 8-bit immediate.</p>
<p>Note that this instruction permits a word in the low quadword of the source operand to be copied to more than one word location in the low quadword of the destination operand.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">0..1</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">2..3</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">4..5</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">6..7</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PSHUFW</strong><br />Shuffle Packed Words<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 70 /r ib</code></td>
<td class="grid"><code>PSHUFW mm1, mm2/m64, imm8</code></td>
<td class="grid">Shuffle the words in mm2/m64 based on the encoding in imm8 and store the result in mm1.</td>
</tr>
</table></td><td>
<p>Copies words from the source operand (second operand) and inserts them in the destination operand (first operand) at word locations selected with the order operand (third operand). This operation is similar to the operation used by the PSHUFD instruction, which is illustrated in Figure 4-6. For the PSHUFW instruction, each 2-bit field in the order operand selects the contents of one word location in the destination operand. The encodings of the order operand fields select words from the source operand to be copied to the destination operand.</p>
<p>The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register. The order operand is an 8-bit immediate.</p>
<p>Note that this instruction permits a word in the source operand to be copied to more than one word location in the destination operand.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">0..1</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">2..3</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">4..5</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span>Source <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Order<span class="operator">[</span><span class="number">6..7</span><span class="operator">]</span> <span class="operator">*</span> <span class="number">16</span><span class="operator">)</span><span class="operator">)</span><span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PSLLDQ</strong><br />Shift Double Quadword Left Logical<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 73 /7 ib</code></td>
<td class="grid"><code>PSLLDQ xmm1, imm8</code></td>
<td class="grid">Shift xmm1 left by imm8 bytes while shifting in 0s.</td>
</tr>
</table></td><td>
<p>Shifts the destination operand (first operand) to the left by the number of bytes specified in the count operand (second operand). The empty low-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s.</p>
<p>The destination operand is an XMM register. The count operand is an 8-bit immediate.</p>
<br />
<pre>Temporary <span class="operator">=</span> Count<span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Temporary <span class="operator">&gt;</span> <span class="number">15</span><span class="operator">)</span> Temporary <span class="operator">=</span> <span class="number">16</span><span class="operator">;</span>
Destination <span class="operator">=</span> Destination <span class="operator">&lt;&lt;</span> <span class="operator">(</span>Temporary <span class="operator">*</span> <span class="number">8</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PSLLW/PSLLD/PSLLQ</strong><br />Shift Packed Data Left Logical<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F F1 /r</code></td>
<td class="grid"><code>PSLLW mm, mm/m64</code></td>
<td class="grid">Shift words in mm left mm/m64 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>66 0F F1 /r</code></td>
<td class="grid"><code>PSLLW xmm1, xmm2/m128</code></td>
<td class="grid">Shift words in xmm1 left by xmm2/m128 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>0F 71 /6 ib</code></td>
<td class="grid"><code>PSLLW mm, imm8</code></td>
<td class="grid">Shift words in mm left by imm8 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 71 /6 ib</code></td>
<td class="grid"><code>PSLLW xmm1, imm8</code></td>
<td class="grid">Shift words in xmm1 left by imm8 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>0F F2 /r</code></td>
<td class="grid"><code>PSLLD mm, mm/m64</code></td>
<td class="grid">Shift doublewords in mm left by mm/m64 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>66 0F F2 /r</code></td>
<td class="grid"><code>PSLLD xmm1, xmm2/m128</code></td>
<td class="grid">Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>0F 72 /6 ib</code></td>
<td class="grid"><code>PSLLD mm, imm8</code></td>
<td class="grid">Shift doublewords in mm left by imm8 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 72 /6 ib</code></td>
<td class="grid"><code>PSLLD xmm1, imm8</code></td>
<td class="grid">Shift doublewords in xmm1 left by imm8 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>0F F3 /r</code></td>
<td class="grid"><code>PSLLQ mm, mm/m64</code></td>
<td class="grid">Shift quadword in mm left by mm/m64 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>66 0F F3 /r</code></td>
<td class="grid"><code>PSLLQ xmm1, xmm2/m128</code></td>
<td class="grid">Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>0F 73 /6 ib</code></td>
<td class="grid"><code>PSLLQ mm, imm8</code></td>
<td class="grid">Shift quadword in mm left by imm8 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 73 /6 ib</code></td>
<td class="grid"><code>PSLLQ xmm1, imm8</code></td>
<td class="grid">Shift quadwords in xmm1 left by imm8 while shifting in 0s.</td>
</tr>
</table></td><td>
<p>Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. (Figure 4-7 gives an example of shifting words in a 64-bit operand.) The destination operand may be an MMX technology register or an XMM register; the count operand can be either an MMX technology register or an 64-bit memory location, an XMM register or a 128-bit memory location, or an 8-bit immediate.</p>
<p>The PSLLW instruction shifts each of the words in the destination operand to the left by the number of bits specified in the count operand; the PSLLD instruction shifts each of the doublewords in the destination operand; and the PSLLQ instruction shifts the quadword (or quadwords) in the destination operand.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> PSLLW<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PSLLW instruction with 64-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">15</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..64</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">else</span> {
				Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">32..37</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..37</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			}
		}
		<span class="keyword">else</span> {
			<span class="comment">//PSLLW instruction with 128-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">15</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">128..0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">else</span> {
				Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			}
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PSLLD<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PSLLD instruction with 64-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">31</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">else</span> {
				Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			}
		}
		<span class="keyword">else</span> {
			<span class="comment">//PSLLD instruction with 128-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">31</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">128..0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">else</span> {
				Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			}
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PSLLQ<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PSLLQ instruction with 64-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">63</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..64</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PSLLQ instruction with 128-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">63</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..128</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">else</span> {
				Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">&lt;&lt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			}
		}
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PSRAW/PSRAD</strong><br />Shift Packed Data Right Arithmetic<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F E1 /r</code></td>
<td class="grid"><code>PSRAW mm, mm/m64</code></td>
<td class="grid">Shift words in mm right by mm/m64 while shifting in sign bits.</td>
</tr>
<tr>
<td class="grid"><code>66 0F E1 /r</code></td>
<td class="grid"><code>PSRAW xmm1, xmm2/m128</code></td>
<td class="grid">Shift words in xmm1 right by xmm2/m128 while shifting in sign bits.</td>
</tr>
<tr>
<td class="grid"><code>0F 71 /4 ib</code></td>
<td class="grid"><code>PSRAW mm, imm8</code></td>
<td class="grid">Shift words in mm right by imm8 while shifting in sign bits</td>
</tr>
<tr>
<td class="grid"><code>66 0F 71 /4 ib</code></td>
<td class="grid"><code>PSRAW xmm1, imm8</code></td>
<td class="grid">Shift words in xmm1 right by imm8 while shifting in sign bits</td>
</tr>
<tr>
<td class="grid"><code>0F E2 /r</code></td>
<td class="grid"><code>PSRAD mm, mm/m64</code></td>
<td class="grid">Shift doublewords in mm right by mm/m64 while shifting in sign bits.</td>
</tr>
<tr>
<td class="grid"><code>66 0F E2 /r</code></td>
<td class="grid"><code>PSRAD xmm1, xmm2/m128</code></td>
<td class="grid">Shift doubleword in xmm1 right by xmm2/m128 while shifting in sign bits.</td>
</tr>
<tr>
<td class="grid"><code>0F 72 /4 ib</code></td>
<td class="grid"><code>PSRAD mm, imm8</code></td>
<td class="grid">Shift doublewords in mm right by imm8 while shifting in sign bits.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 72 /4 ib</code></td>
<td class="grid"><code>PSRAD xmm1, imm8</code></td>
<td class="grid">Shift doublewords in xmm1 right by imm8 while shifting in sign bits.</td>
</tr>
</table></td><td>
<p>Shifts the bits in the individual data elements (words or doublewords) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand).</p>
<p>As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element. If the value specified by the count operand is greater than 15 (for words) or 31 (for doublewords), each destination data element is filled with the initial value of the sign bit of the element.</p>
<p>The destination operand may be an MMX technology register or an XMM register; the count operand can be either an MMX technology register or an 64-bit memory location, an XMM register or a 128-bit memory location, or an 8-bit immediate.</p>
<p>The PSRAW instruction shifts each of the words in the destination operand to the right by the number of bits specified in the count operand, and the PSRAD instruction shifts each of the doublewords in the destination operand.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> PSRAW<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PSRAW instruction with 64-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">15</span><span class="operator">)</span> Count <span class="operator">=</span> <span class="number">16</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PSRAW instruction with 128-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">15</span><span class="operator">)</span> Count <span class="operator">=</span> <span class="number">16</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PSRAD<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PSRAD instruction with 64-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">31</span><span class="operator">)</span> Count <span class="operator">=</span> <span class="number">32</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PSRAD instruction with 128-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">31</span><span class="operator">)</span> Count <span class="operator">=</span> <span class="number">32</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> SignExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span>Count<span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PSRLDQ</strong><br />Shift Double Quadword Right Logical<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 73 /3 ib</code></td>
<td class="grid"><code>PSRLDQ xmm1, imm8</code></td>
<td class="grid">Shift xmm1 right by imm8 while shifting in 0s.</td>
</tr>
</table></td><td>
<p>Shifts the destination operand (first operand) to the right by the number of bytes specified in the count operand (second operand). The empty high-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s.</p>
<p>The destination operand is an XMM register. The count operand is an 8-bit immediate.</p>
<br />
<pre>Temporary <span class="operator">=</span> Count<span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Temporary <span class="operator">&gt;</span> <span class="number">15</span><span class="operator">)</span> Temporary <span class="operator">=</span> <span class="number">16</span><span class="operator">;</span>
Destination <span class="operator">=</span> Destination <span class="operator">&gt;&gt;</span> <span class="operator">(</span>Temporary <span class="operator">*</span> <span class="number">8</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PSRLW/PSRLD/PSRLQ</strong><br />Shift Packed Data Right Logical<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F D1 /r</code></td>
<td class="grid"><code>PSRLW mm, mm/m64</code></td>
<td class="grid">Shift words in mm right by amount specified in mm/m64 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>66 0F D1 /r</code></td>
<td class="grid"><code>PSRLW xmm1, xmm2/m128</code></td>
<td class="grid">Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>0F 71 /2 ib</code></td>
<td class="grid"><code>PSRLW mm, imm8</code></td>
<td class="grid">Shift words in mm right by imm8 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 71 /2 ib</code></td>
<td class="grid"><code>PSRLW xmm1, imm8</code></td>
<td class="grid">Shift words in xmm1 right by imm8 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>0F D2 /r</code></td>
<td class="grid"><code>PSRLD mm, mm/m64</code></td>
<td class="grid">Shift doublewords in mm right by amount specified in mm/m64 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>66 0F D2 /r</code></td>
<td class="grid"><code>PSRLD xmm1, xmm2/m128</code></td>
<td class="grid">Shift doublewords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>0F 72 /2 ib</code></td>
<td class="grid"><code>PSRLD mm, imm8</code></td>
<td class="grid">Shift doublewords in mm right by imm8 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 72 /2 ib</code></td>
<td class="grid"><code>PSRLD xmm1, imm8</code></td>
<td class="grid">Shift doublewords in xmm1 right by imm8 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>0F D3 /r</code></td>
<td class="grid"><code>PSRLQ mm, mm/m64</code></td>
<td class="grid">Shift mm right by amount specified in mm/m64 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>66 0F D3 /r</code></td>
<td class="grid"><code>PSRLQ xmm1, xmm2/m128</code></td>
<td class="grid">Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>0F 73 /2 ib</code></td>
<td class="grid"><code>PSRLQ mm, imm8</code></td>
<td class="grid">Shift mm right by imm8 while shifting in 0s.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 73 /2 ib</code></td>
<td class="grid"><code>PSRLQ xmm1, imm8</code></td>
<td class="grid">Shift quadwords in xmm1 right by imm8 while shifting in 0s.</td>
</tr>
</table></td><td>
<p>Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. The destination operand may be an MMX technology register or an XMM register; the count operand can be either an MMX technology register or an 64-bit memory location, an XMM register or a 128-bit memory location, or an 8-bit immediate.</p>
<p>The PSRLW instruction shifts each of the words in the destination operand to the right by the number of bits specified in the count operand; the PSRLD instruction shifts each of the doublewords in the destination operand; and the PSRLQ instruction shifts the quadword (or quadwords) in the destination operand.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> PSRLW<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PSRLW instruction with 64-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">15</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">else</span> {
				Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			}
		}
		<span class="keyword">else</span> {
			<span class="comment">//PSRLW instruction with 128-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">15</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">128..0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">else</span> {
				Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			}
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PSRLD<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PSRLD instruction with 64-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">31</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">else</span> {
				Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			}
		}
		<span class="keyword">else</span> {
			<span class="comment">//PSRLD instruction with 128-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">31</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">128..0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">else</span> {
				Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			}
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PSRLQ<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PSRLQ instruction with 64-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">63</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">else</span> Destination <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PSRLQ instruction with 128-bit operand:</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> <span class="number">15</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">128..0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
			<span class="keyword">else</span> {
				Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
				Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> ZeroExtend<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">&gt;&gt;</span> Count<span class="operator">)</span><span class="operator">;</span>
			}
		}
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PSUBB/PSUBW/PSUBD</strong><br />Subtract Packed Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F F8 /r</code></td>
<td class="grid"><code>PSUBB mm, mm/m64</code></td>
<td class="grid">Subtract packed byte integers in mm/m64 from packed byte integers in mm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F F8 /r</code></td>
<td class="grid"><code>PSUBB xmm1, xmm2/m128</code></td>
<td class="grid">Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1.</td>
</tr>
<tr>
<td class="grid"><code>0F F9 /r</code></td>
<td class="grid"><code>PSUBW mm, mm/m64</code></td>
<td class="grid">Subtract packed word integers in mm/m64 from packed word integers in mm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F F9 /r</code></td>
<td class="grid"><code>PSUBW xmm1, xmm2/m128</code></td>
<td class="grid">Subtract packed word integers in xmm2/m128 from packed word integers in xmm1.</td>
</tr>
<tr>
<td class="grid"><code>0F FA /r</code></td>
<td class="grid"><code>PSUBD mm, mm/m64</code></td>
<td class="grid">Subtract packed doubleword integers in mm/m64 from packed doubleword integers in mm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F FA /r</code></td>
<td class="grid"><code>PSUBD xmm1, xmm2/m128</code></td>
<td class="grid">Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1.</td>
</tr>
</table></td><td>
<p>Performs an SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.</p>
<p>These instructions can operate on either 64-bit or 128-bit operands. When operating on 64-bit operands, the destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location. When operating on 128-bit operands, the destination operand must be an XMM register and the source operand can be either an XMM register or a 128-bit memory location.</p>
<p>The PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.</p>
<p>The PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.</p>
<p>The PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.</p>
<p>Note that the PSUBB, PSUBW, and PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values operated on.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> PSUBB<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PSUBB instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PSUBB instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="operator">]</span><span class="number">72..79</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">120..111</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PSUBW<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PSUBW instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PSUBW instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PSUBD<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PSUBD instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">31..0</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">31..0</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">31..0</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">63..32</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">63..32</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">63..32</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PSUBD instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PSUBQ</strong><br />Subtract Packed Quadword Integers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F FB /r</code></td>
<td class="grid"><code>PSUBQ mm1, mm2/m64</code></td>
<td class="grid">Subtract quadword integer in mm1 from mm2 /m64.</td>
</tr>
<tr>
<td class="grid"><code>66 0F FB /r</code></td>
<td class="grid"><code>PSUBQ xmm1, xmm2/m128</code></td>
<td class="grid">Subtract packed quadword integers in xmm1 from xmm2/m128.</td>
</tr>
</table></td><td>
<p>Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. The source operand can be a quadword integer stored in an MMX technology register or a 64-bit memory location, or it can be two packed quadword integers stored in an XMM register or an 128-bit memory location. The destination operand can be a quadword integer stored in an MMX technology register or two packed quadword integers stored in an XMM register. When packed quadword operands are used, an SIMD subtract is performed. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).</p>
<p>Note that the PSUBQ instruction can operate on either unsigned or signed (two's complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.</p>
<br />
<pre><span class="comment">//PSUBQ instruction with 64-Bit operands:</span>
<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//PSUBQ instruction with 128-Bit operands:</span>
<span class="keyword">else</span> {
	Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PSUBSB/PSUBSW</strong><br />Subtract Packed Signed Integers with Signed Saturation<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F E8 /r PSUBSB mm, mm/m64 Subtract signed packed bytes in mm/m64 from signed packed bytes in mm and saturate results.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>66 0F E8 /r PSUBSB xmm1, xmm2/m128 Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>0F E9 /r PSUBSW mm, mm/m64 Subtract signed packed words in mm/m64 from signed packed words in mm and saturate results.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>66 0F E9 /r PSUBSW xmm1, xmm2/m128 Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Performs an SIMD subtract of the packed signed integers of the source operand (second operand) from the packed signed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD operation. Overflow is handled with signed saturation, as described in the following paragraphs.</p>
<p>These instructions can operate on either 64-bit or 128-bit operands. When operating on 64-bit operands, the destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location. When operating on 128- bit operands, the destination operand must be an XMM register and the source operand can be either an XMM register or a 128-bit memory location.</p>
<p>The PSUBSB instruction subtracts packed signed byte integers. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.</p>
<p>The PSUBSW instruction subtracts packed signed word integers. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> PSUBSB<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PSUBSB instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PSUBSB instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="operator">]</span><span class="number">72..79</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">120..111</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PSUBSW<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PSUBSW instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PSUBSW instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> SaturateToSignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PSUBUSB/PSUBUSW</strong><br />Subtract Packed Unsigned Integers with Unsigned Saturation<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F D8 /r PSUBUSB mm, mm/m64 Subtract unsigned packed bytes in mm/m64 from unsigned packed bytes in mm and saturate result.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>66 0F D8 /r PSUBUSB xmm1, xmm2/m128 Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>0F D9 /r PSUBUSW mm, mm/m64 Subtract unsigned packed words in mm/m64 from unsigned packed words in mm and saturate result.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>66 0F D9 /r PSUBUSW xmm1, xmm2/m128 Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result.</code></td>
<td class="grid"><code></code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Performs an SIMD subtract of the packed unsigned integers of the source operand (second operand) from the packed unsigned integers of the destination operand (first operand), and stores the packed unsigned integer results in the destination operand. See Figure 9-4 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD operation.</p>
<p>Overflow is handled with unsigned saturation, as described in the following paragraphs.</p>
<p>These instructions can operate on either 64-bit or 128-bit operands. When operating on 64-bit operands, the destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location. When operating on 128-bit operands, the destination operand must be an XMM register and the source operand can be either an XMM register or a 128-bit memory location.</p>
<p>The PSUBUSB instruction subtracts packed unsigned byte integers. When an individual byte result is less than zero, the saturated value of 00H is written to the destination operand.</p>
<p>The PSUBUSW instruction subtracts packed unsigned word integers. When an individual word result is less than zero, the saturated value of 0000H is written to the destination operand.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> PSUBUSB<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PSUBUSB instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PSUBUSB instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="operator">]</span><span class="number">72..79</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedByte<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">120..111</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PSUBUSW<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PSUBUSW instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PSUBUSW instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> SaturateToUnsignedWord<span class="operator">(</span>Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ</strong><br /> Unpack High Data<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 68 /r</code></td>
<td class="grid"><code>PUNPCKHBW mm, mm/m64</code></td>
<td class="grid">Unpack and interleave high-order bytes from mm and mm/m64 into mm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 68 /r</code></td>
<td class="grid"><code>PUNPCKHBW xmm1, xmm2/m128</code></td>
<td class="grid">Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1.</td>
</tr>
<tr>
<td class="grid"><code>0F 69 /r</code></td>
<td class="grid"><code>PUNPCKHWD mm, mm/m64</code></td>
<td class="grid">Unpack and interleave high-order words from mm and mm/m64 into mm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 69 /r</code></td>
<td class="grid"><code>PUNPCKHWD xmm1, xmm2/m128</code></td>
<td class="grid">Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1.</td>
</tr>
<tr>
<td class="grid"><code>0F 6A /r</code></td>
<td class="grid"><code>PUNPCKHDQ mm, mm/m64</code></td>
<td class="grid">Unpack and interleave high-order doublewords from mm and mm/m64 into mm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 6A /r</code></td>
<td class="grid"><code>PUNPCKHDQ xmm1, xmm2/m128</code></td>
<td class="grid">Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 6D /r</code></td>
<td class="grid"><code>PUNPCKHQDQ xmm1, xmm2/m128</code></td>
<td class="grid">Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1.</td>
</tr>
</table></td><td>
<p>Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. The low-order data elements are ignored.</p>
<p>The source operand can be an MMX technology register or a 64-bit memory location, or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register. When the source data comes from a 64-bit memory operand, the full 64-bit operand is accessed from memory, but the instruction uses only the highorder 32 bits. When the source data comes from a 128-bit memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to a 16-byte boundary and normal segment checking will still be enforced.</p>
<p>The PUNPCKHBW instruction interleaves the high-order bytes of the source and destination operands, the PUNPCKHWD instruction interleaves the high-order words of the source and destination operands, the PUNPCKHDQ instruction interleaves the high-order doubleword (or doublewords) of the source and destination operands, and the PUNPCKHQDQ instruction interleaves the high-order quadwords of the source and destination operands.</p>
<p>These instructions can be used to convert bytes to words, words to doublewords, doublewords to quadwords, and quadwords to double quadwords, respectively, by placing all 0s in the source operand. Here, if the source operand contains all 0s, the result (stored in the destination operand) contains zero extensions of the high-order data elements from the original value in the destination operand. For example, with the PUNPCKHBW instruction the high-order bytes are zero extended (that is, unpacked into unsigned word integers), and with the PUNPCKHWD instruction, the high-order words are zero extended (unpacked into unsigned doubleword integers).</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> PUNPCKHBW<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PUNPCKHBW instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PUNPCKHBW instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PUNPCKHWD<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PUNPCKHWD instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PUNPCKHWD instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PUNPCKHDQ<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">64</span><span class="operator">)</span> {
			<span class="comment">//PUNPCKHDQ instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span>
			Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PUNPCKHDQ instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PUNPCKHQDQ<span class="operator">:</span>
		<span class="comment">//PUNPCKHQDQ instruction:</span>
		Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
		Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ</strong><br /> Unpack Low Data<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 60 /r</code></td>
<td class="grid"><code>PUNPCKLBW mm, mm/m32</code></td>
<td class="grid">Interleave low-order bytes from mm and mm/m32 into mm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 60 /r</code></td>
<td class="grid"><code>PUNPCKLBW xmm1, xmm2/m128</code></td>
<td class="grid">Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1.</td>
</tr>
<tr>
<td class="grid"><code>0F 61 /r</code></td>
<td class="grid"><code>PUNPCKLWD mm, mm/m32</code></td>
<td class="grid">Interleave low-order words from mm and mm/m32 into mm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 61 /r</code></td>
<td class="grid"><code>PUNPCKLWD xmm1, xmm2/m128</code></td>
<td class="grid">Interleave low-order words from xmm1 and xmm2/m128 into xmm1.</td>
</tr>
<tr>
<td class="grid"><code>0F 62 /r</code></td>
<td class="grid"><code>PUNPCKLDQ mm, mm/m32</code></td>
<td class="grid">Interleave low-order doublewords from mm and mm/m32 into mm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 62 /r</code></td>
<td class="grid"><code>PUNPCKLDQ xmm1, xmm2/m128</code></td>
<td class="grid">Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1.</td>
</tr>
<tr>
<td class="grid"><code>66 0F 6C /r</code></td>
<td class="grid"><code>PUNPCKLQDQ xmm1, xmm2/m128</code></td>
<td class="grid">Interleave low-order quadwords from xmm1 and xmm2/m128 into xmm1.</td>
</tr>
</table></td><td>
<p>Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. The high-order data elements are ignored.</p>
<p>The source operand can be an MMX technology register or a 32-bit memory location, or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register. When the source data comes from a 128-bit memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to a 16-byte boundary and normal segment checking will still be enforced.</p>
<p>The PUNPCKLBW instruction interleaves the low-order bytes of the source and destination operands, the PUNPCKLWD instruction interleaves the low-order words of the source and destination operands, the PUNPCKLDQ instruction interleaves the low-order doubleword (or doublewords) of the source and destination operands, and the PUNPCKLQDQ instruction interleaves the low-order quadwords of the source and destination operands.</p>
<p>These instructions can be used to convert bytes to words, words to doublewords, doublewords to quadwords, and quadwords to double quadwords, respectively, by placing all 0s in the source operand. Here, if the source operand contains all 0s, the result (stored in the destination operand) contains zero extensions of the high-order data elements from the original value in the destination operand. For example, with the PUNPCKLBW instruction the high-order bytes are zero extended (that is, unpacked into unsigned word integers), and with the PUNPCKLWD instruction, the high-order words are zero extended (unpacked into unsigned doubleword integers).</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> PUNPCKLBW<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> {
			<span class="comment">//PUNPCKLBW instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">63..56</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">31..24</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">55..48</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">31..24</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">47..40</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">23..16</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">39..32</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">23..16</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">31..24</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">15..8</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">23..16</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">15..8</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">15..8</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">7..0</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">7..0</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">7..0</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PUNPCKLBW instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..7</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">8..15</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..23</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">24..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..71</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">72..79</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..87</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">88..95</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..103</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">104..111</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">48..55</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..119</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">120..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">56..63</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PUNPCKLWD<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> {
			<span class="comment">//PUNPCKLWD instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">63..48</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">31..16</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">47..32</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">31..16</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">31..16</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">15..0</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">15..0</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">15..0</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PUNPCKLWD instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">16..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..79</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">80..95</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..47</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..111</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">112..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">48..63</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PUNPCKLDQ<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> {
			<span class="comment">//PUNPCKLDQ instruction with 64-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//PUNPCKLDQ instruction with 128-bit operands:</span>
			Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
			Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> PUNPCKLQDQ<span class="operator">:</span>
		<span class="comment">//PUNPCKLQDQ instruction:</span>
		Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
		Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PUSH</strong><br />Push Word or Doubleword Onto the Stack<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>FF /6</code></td>
<td class="grid"><code>PUSH r/m16</code></td>
<td class="grid">Push r/m16.</td>
</tr>
<tr>
<td class="grid"><code>FF /6</code></td>
<td class="grid"><code>PUSH r/m32</code></td>
<td class="grid">Push r/m32.</td>
</tr>
<tr>
<td class="grid"><code>50+rw</code></td>
<td class="grid"><code>PUSH r16</code></td>
<td class="grid">Push r16.</td>
</tr>
<tr>
<td class="grid"><code>50+rd</code></td>
<td class="grid"><code>PUSH r32</code></td>
<td class="grid">Push r32.</td>
</tr>
<tr>
<td class="grid"><code>6A</code></td>
<td class="grid"><code>PUSH imm8</code></td>
<td class="grid">Push imm8.</td>
</tr>
<tr>
<td class="grid"><code>68</code></td>
<td class="grid"><code>PUSH imm16</code></td>
<td class="grid">Push imm16.</td>
</tr>
<tr>
<td class="grid"><code>68</code></td>
<td class="grid"><code>PUSH imm32</code></td>
<td class="grid">Push imm32.</td>
</tr>
<tr>
<td class="grid"><code>0E</code></td>
<td class="grid"><code>PUSH CS</code></td>
<td class="grid">Push CS.</td>
</tr>
<tr>
<td class="grid"><code>16</code></td>
<td class="grid"><code>PUSH SS</code></td>
<td class="grid">Push SS.</td>
</tr>
<tr>
<td class="grid"><code>1E</code></td>
<td class="grid"><code>PUSH DS</code></td>
<td class="grid">Push DS.</td>
</tr>
<tr>
<td class="grid"><code>06</code></td>
<td class="grid"><code>PUSH ES</code></td>
<td class="grid">Push ES.</td>
</tr>
<tr>
<td class="grid"><code>0F A0</code></td>
<td class="grid"><code>PUSH FS</code></td>
<td class="grid">Push FS.</td>
</tr>
<tr>
<td class="grid"><code>0F A8</code></td>
<td class="grid"><code>PUSH GS</code></td>
<td class="grid">Push GS.</td>
</tr>
</table></td><td>
<p>Decrements the stack pointer and then stores the source operand on the top of the stack. The address-size attribute of the stack segment determines the stack pointer size (16 bits or 32 bits), and the operand-size attribute of the current code segment determines the amount the stack pointer is decremented (2 bytes or 4 bytes). For example, if these address- and operand-size attributes are 32, the 32-bit ESP register (stack pointer) is decremented by 4 and, if they are 16, the 16-bit SP register is decremented by 2. (The B flag in the stack segment's segment descriptor determines the stack's address-size attribute, and the D flag in the current code segment's segment descriptor, along with prefixes, determines the operand-size attribute and also the address-size attribute of the source operand.) Pushing a 16-bit operand when the stack addresssize attribute is 32 can result in a misaligned the stack pointer (that is, the stack pointer is not aligned on a doubleword boundary).</p>
<p>The PUSH ESP instruction pushes the value of the ESP register as it existed before the instruction was executed. Thus, if a PUSH instruction uses a memory operand in which the ESP register is used as a base register for computing the operand address, the effective address of the operand is computed before the ESP register is decremented.</p>
<p>In the real-address mode, if the ESP or SP register is 1 when the PUSH instruction is executed, the processor shuts down due to a lack of stack space. No exception is generated to indicate this condition.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>StackAddressSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
		ESP <span class="operator">=</span> ESP <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
		SS<span class="operator">:</span>ESP <span class="operator">=</span> Source <span class="comment">//push doubleword</span>
	}
	<span class="keyword">else</span> { <span class="comment">//OperandSize == 16</span>
		ESP <span class="operator">=</span> ESP <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
		SS<span class="operator">:</span>ESP <span class="operator">=</span> Source<span class="operator">;</span> <span class="comment">//push word</span>
	}
}
<span class="keyword">else</span> { <span class="comment">//StackAddressSize == 16</span>
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> {
		SP <span class="operator">=</span> SP <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
		SS<span class="operator">:</span>ESP <span class="operator">=</span> Source <span class="comment">//push word</span>
	}
	<span class="keyword">else</span> { <span class="comment">//OperandSize == 32</span>
		SP <span class="operator">=</span> SP <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
		SS<span class="operator">:</span>ESP <span class="operator">=</span> Source<span class="operator">;</span> <span class="comment">//push doubleword</span>
	}
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PUSHA/PUSHAD</strong><br />Push All General-Purpose Registers<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>60</code></td>
<td class="grid"><code>PUSHA</code></td>
<td class="grid">Push AX, CX, DX, BX, original SP, BP, SI, and DI.</td>
</tr>
<tr>
<td class="grid"><code>60</code></td>
<td class="grid"><code>PUSHAD</code></td>
<td class="grid">Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI.</td>
</tr>
</table></td><td>
<p>Pushes the contents of the general-purpose registers onto the stack. The registers are stored on the stack in the following order: EAX, ECX, EDX, EBX, EBP, ESP (original value), EBP, ESI, and EDI (if the current operand-size attribute is 32) and AX, CX, DX, BX, SP (original value), BP, SI, and DI (if the operand-size attribute is 16). These instructions perform the reverse operation of the POPA/POPAD instructions. The value pushed for the ESP or SP register is its value before prior to pushing the first register (see the &quot;Operation&quot; section below).</p>
<p>The PUSHA (push all) and PUSHAD (push all double) mnemonics reference the same opcode.</p>
<p>The PUSHA instruction is intended for use when the operand-size attribute is 16 and the PUSHAD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when PUSHA is used and to 32 when PUSHAD is used. Others may treat these mnemonics as synonyms (PUSHA/PUSHAD) and use the current setting of the operandsize attribute to determine the size of values to be pushed from the stack, regardless of the mnemonic used.</p>
<p>In the real-address mode, if the ESP or SP register is 1, 3, or 5 when the PUSHA/PUSHAD instruction is executed, the processor shuts down due to a lack of stack space. No exception is generated to indicate this condition.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">=</span> <span class="number">32</span><span class="operator">)</span> { <span class="comment">//PUSHAD instruction</span>
	Temporary <span class="operator">=</span> ESP<span class="operator">;</span>
	Push<span class="operator">(</span>EAX<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>ECX<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>EDX<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>EBX<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>Temporary<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>EBP<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>ESI<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>EDI<span class="operator">)</span><span class="operator">;</span>
}
<span class="keyword">else</span> { <span class="comment">//OperandSize = 16, PUSHA instruction</span>
	Temporary <span class="operator">=</span> SP<span class="operator">;</span>
	Push<span class="operator">(</span>AX<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>CX<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>DX<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>BX<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>Temporary<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>BP<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>SI<span class="operator">)</span><span class="operator">;</span>
	Push<span class="operator">(</span>DI<span class="operator">)</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PUSHF/PUSHFD</strong><br />Push EFLAGS Register onto the Stack<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>9C</code></td>
<td class="grid"><code>PUSHF</code></td>
<td class="grid">Push lower 16 bits of EFLAGS.</td>
</tr>
<tr>
<td class="grid"><code>9C</code></td>
<td class="grid"><code>PUSHFD</code></td>
<td class="grid">Push EFLAGS.</td>
</tr>
</table></td><td>
<p>Decrements the stack pointer by 4 (if the current operand-size attribute is 32) and pushes the entire contents of the EFLAGS register onto the stack, or decrements the stack pointer by 2 (if the operand-size attribute is 16) and pushes the lower 16 bits of the EFLAGS register (that is, the FLAGS register) onto the stack. (These instructions reverse the operation of the POPF/POPFD instructions.) When copying the entire EFLAGS register to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead, the values for these flags are cleared in the EFLAGS image stored on the stack. See the section titled &quot;EFLAGS Register&quot; in Chapter 3 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for information about the EFLAGS registers.</p>
<p>The PUSHF (push flags) and PUSHFD (push flags double) mnemonics reference the same opcode. The PUSHF instruction is intended for use when the operand-size attribute is 16 and the PUSHFD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when PUSHF is used and to 32 when PUSHFD is used. Others may treat these mnemonics as synonyms (PUSHF/PUSHFD) and use the current setting of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the mnemonic used.</p>
<p>When in virtual-8086 mode and the I/O privilege level (IOPL) is less than 3, the PUSHF/PUSHFD instruction causes a general protection exception (#GP).</p>
<p>In the real-address mode, if the ESP or SP register is 1, 3, or 5 when the PUSHA/PUSHAD instruction is executed, the processor shuts down due to a lack of stack space. No exception is generated to indicate this condition.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>PE <span class="operator">==</span> <span class="number">0</span> <span class="operator">||</span> <span class="operator">(</span>PE <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> <span class="operator">(</span>VM <span class="operator">==</span> <span class="number">0</span> <span class="operator">||</span> <span class="operator">(</span>VM <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> IOPL <span class="operator">==</span> <span class="number">3</span><span class="operator">)</span><span class="operator">)</span><span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> Push<span class="operator">(</span>EFLAGS <span class="operator">&amp;</span> <span class="number">0xFCFFFF</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//VM and RF EFLAG bits are cleared in image stored on the stack</span>
	<span class="keyword">else</span> Push<span class="operator">(</span>EFLAGS<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
}
<span class="comment">//In Virtual-8086 Mode with IOPL less than 3</span>
<span class="keyword">else</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//Trap to virtual-8086 monitor</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>PXOR</strong><br />Logical Exclusive OR<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F EF /r</code></td>
<td class="grid"><code>PXOR mm, mm/m64</code></td>
<td class="grid">Bitwise XOR of mm/m64 and mm.</td>
</tr>
<tr>
<td class="grid"><code>66 0F EF /r</code></td>
<td class="grid"><code>PXOR xmm1, xmm2/m128</code></td>
<td class="grid">Bitwise XOR of xmm2/m128 and xmm1.</td>
</tr>
</table></td><td>
<p>Performs a bitwise logical exclusive-OR (XOR) operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. The source operand can be an MMX technology register or a 64-bit memory location or it can be an XMM register or a 128-bit memory location. The destination operand can be an MMX technology register or an XMM register. Each bit of the result is 1 if the corresponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same.</p>
<br />
<pre>Destination <span class="operator">=</span> Destination <span class="operator">^</span> Source<span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>RCL/RCR/ROL/ROR</strong><br />Rotate<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D0 /2</code></td>
<td class="grid"><code>RCL r/m8, 1</code></td>
<td class="grid">Rotate 9 bits (CF, r/m8) left once.</td>
</tr>
<tr>
<td class="grid"><code>D2 /2</code></td>
<td class="grid"><code>RCL r/m8, CL</code></td>
<td class="grid">Rotate 9 bits (CF, r/m8) left CL times.</td>
</tr>
<tr>
<td class="grid"><code>C0 /2 ib</code></td>
<td class="grid"><code>RCL r/m8, imm8</code></td>
<td class="grid">Rotate 9 bits (CF, r/m8) left imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D1 /2</code></td>
<td class="grid"><code>RCL r/m16, 1</code></td>
<td class="grid">Rotate 17 bits (CF, r/m16) left once.</td>
</tr>
<tr>
<td class="grid"><code>D3 /2</code></td>
<td class="grid"><code>RCL r/m16, CL</code></td>
<td class="grid">Rotate 17 bits (CF, r/m16) left CL times.</td>
</tr>
<tr>
<td class="grid"><code>C1 /2 ib</code></td>
<td class="grid"><code>RCL r/m16, imm8</code></td>
<td class="grid">Rotate 17 bits (CF, r/m16) left imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D1 /2</code></td>
<td class="grid"><code>RCL r/m32, 1</code></td>
<td class="grid">Rotate 33 bits (CF, r/m32) left once.</td>
</tr>
<tr>
<td class="grid"><code>D3 /2</code></td>
<td class="grid"><code>RCL r/m32, CL</code></td>
<td class="grid">Rotate 33 bits (CF, r/m32) left CL times.</td>
</tr>
<tr>
<td class="grid"><code>C1 /2 ib</code></td>
<td class="grid"><code>RCL r/m32,i mm8</code></td>
<td class="grid">Rotate 33 bits (CF, r/m32) left imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D0 /3</code></td>
<td class="grid"><code>RCR r/m8, 1</code></td>
<td class="grid">Rotate 9 bits (CF, r/m8) right once.</td>
</tr>
<tr>
<td class="grid"><code>D2 /3</code></td>
<td class="grid"><code>RCR r/m8, CL</code></td>
<td class="grid">Rotate 9 bits (CF, r/m8) right CL times.</td>
</tr>
<tr>
<td class="grid"><code>C0 /3 ib</code></td>
<td class="grid"><code>RCR r/m8, imm8</code></td>
<td class="grid">Rotate 9 bits (CF, r/m8) right imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D1 /3</code></td>
<td class="grid"><code>RCR r/m16, 1</code></td>
<td class="grid">Rotate 17 bits (CF, r/m16) right once.</td>
</tr>
<tr>
<td class="grid"><code>D3 /3</code></td>
<td class="grid"><code>RCR r/m16, CL</code></td>
<td class="grid">Rotate 17 bits (CF, r/m16) right CL times.</td>
</tr>
<tr>
<td class="grid"><code>C1 /3 ib</code></td>
<td class="grid"><code>RCR r/m16, imm8</code></td>
<td class="grid">Rotate 17 bits (CF, r/m16) right imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D1 /3</code></td>
<td class="grid"><code>RCR r/m32, 1</code></td>
<td class="grid">Rotate 33 bits (CF, r/m32) right once.</td>
</tr>
<tr>
<td class="grid"><code>D3 /3</code></td>
<td class="grid"><code>RCR r/m32, CL</code></td>
<td class="grid">Rotate 33 bits (CF, r/m32) right CL times.</td>
</tr>
<tr>
<td class="grid"><code>C1 /3 ib</code></td>
<td class="grid"><code>RCR r/m32, imm8</code></td>
<td class="grid">Rotate 33 bits (CF, r/m32) right imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D0 /0 ROL r/m8, 1</code></td>
<td class="grid"><code>Rotate 8 bits r/m8 left once.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>D2 /0 ROL r/m8, CL</code></td>
<td class="grid"><code>Rotate 8 bits r/m8 left CL times.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>C0 /0 ib ROL r/m8, imm8</code></td>
<td class="grid"><code>Rotate 8 bits r/m8 left imm8 times.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>D1 /0 ROL r/m16, 1</code></td>
<td class="grid"><code>Rotate 16 bits r/m16 left once.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>D3 /0 ROL r/m16, CL</code></td>
<td class="grid"><code>Rotate 16 bits r/m16 left CL times.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>C1 /0 ib ROL r/m16, imm8</code></td>
<td class="grid"><code>Rotate 16 bits r/m16 left imm8 times.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>D1 /0 ROL r/m32, 1</code></td>
<td class="grid"><code>Rotate 32 bits r/m32 left once.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>D3 /0 ROL r/m32, CL</code></td>
<td class="grid"><code>Rotate 32 bits r/m32 left CL times.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>C1 /0 ib ROL r/m32, imm8</code></td>
<td class="grid"><code>Rotate 32 bits r/m32 left imm8 times.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>D0 /1</code></td>
<td class="grid"><code>ROR r/m8, 1</code></td>
<td class="grid">Rotate 8 bits r/m8 right once.</td>
</tr>
<tr>
<td class="grid"><code>D2 /1</code></td>
<td class="grid"><code>ROR r/m8, CL</code></td>
<td class="grid">Rotate 8 bits r/m8 right CL times.</td>
</tr>
<tr>
<td class="grid"><code>C0 /1 ib</code></td>
<td class="grid"><code>ROR r/m8, imm8</code></td>
<td class="grid">Rotate 8 bits r/m16 right imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D1 /1</code></td>
<td class="grid"><code>ROR r/m16, 1</code></td>
<td class="grid">Rotate 16 bits r/m16 right once.</td>
</tr>
<tr>
<td class="grid"><code>D3 /1</code></td>
<td class="grid"><code>ROR r/m16, CL</code></td>
<td class="grid">Rotate 16 bits r/m16 right CL times.</td>
</tr>
<tr>
<td class="grid"><code>C1 /1 ib</code></td>
<td class="grid"><code>ROR r/m16, imm8</code></td>
<td class="grid">Rotate 16 bits r/m16 right imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D1 /1</code></td>
<td class="grid"><code>ROR r/m32, 1</code></td>
<td class="grid">Rotate 32 bits r/m32 right once.</td>
</tr>
<tr>
<td class="grid"><code>D3 /1</code></td>
<td class="grid"><code>ROR r/m32, CL</code></td>
<td class="grid">Rotate 32 bits r/m32 right CL times.</td>
</tr>
<tr>
<td class="grid"><code>C1 /1 ib</code></td>
<td class="grid"><code>ROR r/m32, imm8</code></td>
<td class="grid">Rotate 32 bits r/m32 right imm8 times.</td>
</tr>
</table></td><td>
<p>Shifts (rotates) the bits of the first operand (destination operand) the number of bit positions specified in the second operand (count operand) and stores the result in the destination operand.</p>
<p>The destination operand can be a register or a memory location; the count operand is an unsigned integer that can be an immediate or a value in the CL register. The processor restricts the count to a number between 0 and 31 by masking all the bits in the count operand except the 5 leastsignificant bits.</p>
<p>The rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the leastsignificant bit location (see Figure 7-11 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1). The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location (see Figure 7-11 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1).</p>
<p>The RCL and RCR instructions include the CF flag in the rotation. The RCL instruction shifts the CF flag into the least-significant bit and shifts the most-significant bit into the CF flag (see Figure 7-11 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1). The RCR instruction shifts the CF flag into the most-significant bit and shifts the least-significant bit into the CF flag (see Figure 7-11 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1). For the ROL and ROR instructions, the original value of the CF flag is not a part of the result, but the CF flag receives a copy of the bit that was shifted from one end to the other.</p>
<p>The OF flag is defined only for the 1-bit rotates; it is undefined in all other cases (except that a zero-bit rotate does nothing, that is affects no flags). For left rotates, the OF flag is set to the exclusive OR of the CF bit (after the rotate) and the most-significant bit of the result. For right rotates, the OF flag is set to the exclusive OR of the two most-significant bits of the result.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instructions<span class="operator">)</span> {
	<span class="keyword">case</span> RCL<span class="operator">:</span>
	<span class="keyword">case</span> RCR<span class="operator">:</span>
		<span class="comment">//RCL and RCR instructions</span>
		<span class="keyword">switch</span><span class="operator">(</span>OperandSize<span class="operator">)</span> {
			<span class="keyword">case</span> <span class="number">8</span><span class="operator">:</span>
				TemporaryCount <span class="operator">=</span> <span class="operator">(</span>Count <span class="operator">&amp;</span> <span class="number">0x1F</span><span class="operator">)</span> <span class="operator">%</span> <span class="number">9</span><span class="operator">;</span>
				<span class="keyword">break</span><span class="operator">;</span>
			<span class="keyword">case</span> <span class="number">16</span><span class="operator">:</span>
				TemporaryCount <span class="operator">=</span> <span class="operator">(</span>Count <span class="operator">&amp;</span> <span class="number">0x1F</span><span class="operator">)</span> <span class="operator">%</span> <span class="number">17</span><span class="operator">;</span>
				<span class="keyword">break</span><span class="operator">;</span>
			<span class="keyword">case</span> <span class="number">32</span><span class="operator">:</span>
				TemporaryCount <span class="operator">=</span> Count <span class="operator">&amp;</span> <span class="number">0x1F</span><span class="operator">;</span>
				<span class="keyword">break</span><span class="operator">;</span>
		}
		<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> RCL<span class="operator">)</span> {
			<span class="comment">//RCL instruction operation</span>
			<span class="keyword">while</span><span class="operator">(</span>TemporaryCount <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> {
				TemporaryCF <span class="operator">=</span> MSB<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">;</span>
				Destination <span class="operator">=</span> <span class="operator">(</span>Destination <span class="operator">&lt;&lt;</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">+</span> CF<span class="operator">;</span>
				CF <span class="operator">=</span> TemporaryCF<span class="operator">;</span>
				TemporaryCount <span class="operator">=</span> TemporaryCount <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
			}
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> OF <span class="operator">=</span> MSB<span class="operator">(</span>Destination<span class="operator">)</span> <span class="operator">^</span> CF<span class="operator">;</span>
			<span class="keyword">else</span> OF <span class="operator">=</span> Undefined<span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//RCR instruction operation</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> OF <span class="operator">=</span> MSB<span class="operator">(</span>Destination<span class="operator">)</span> <span class="operator">^</span> CF<span class="operator">;</span>
			<span class="keyword">else</span> OF <span class="operator">=</span> Undefined<span class="operator">;</span>
			<span class="keyword">while</span><span class="operator">(</span>TemporaryCount <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> {
				TemporaryCF <span class="operator">=</span> LSB<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">;</span>
				Destination <span class="operator">=</span> <span class="operator">(</span>Destination <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">+</span> <span class="operator">(</span>CF <span class="operator">&lt;&lt;</span> Size<span class="operator">)</span><span class="operator">;</span>
				CF <span class="operator">=</span> TemporaryCF<span class="operator">;</span>
				TemporaryCount <span class="operator">=</span> TemporaryCount <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
			}
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ROL<span class="operator">:</span>
	<span class="keyword">case</span> ROR<span class="operator">:</span>
		<span class="comment">//ROL and ROR instructions</span>
		<span class="keyword">switch</span><span class="operator">(</span>OperandSize<span class="operator">)</span> {
			<span class="keyword">case</span> <span class="number">8</span><span class="operator">:</span>
				TemporaryCount <span class="operator">=</span> Count <span class="operator">%</span> <span class="number">8</span><span class="operator">;</span>
				<span class="keyword">break</span><span class="operator">;</span>
			<span class="keyword">case</span> <span class="number">16</span><span class="operator">:</span>
				TemporaryCount <span class="operator">=</span> Count <span class="operator">%</span> <span class="number">16</span><span class="operator">;</span>
				<span class="keyword">break</span><span class="operator">;</span>
			<span class="keyword">case</span> <span class="number">32</span><span class="operator">:</span>
				TemporaryCount <span class="operator">=</span> Count <span class="operator">%</span> <span class="number">32</span><span class="operator">;</span>
				<span class="keyword">break</span><span class="operator">;</span>
		}
		<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> ROL<span class="operator">)</span> {
			<span class="comment">//ROL instruction operation</span>
			<span class="keyword">while</span><span class="operator">(</span>TemporaryCount <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> {
				TemporaryCF <span class="operator">=</span> MSB<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">;</span>
				Destination <span class="operator">=</span> <span class="operator">(</span>Destination <span class="operator">&lt;&lt;</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">+</span> TemporaryCF<span class="operator">;</span>
				TemporaryCount <span class="operator">=</span> TemporaryCount <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
			}
			CF <span class="operator">=</span> LSB<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> OF <span class="operator">=</span> MSB<span class="operator">(</span>Destination<span class="operator">)</span> <span class="operator">^</span> CF<span class="operator">;</span>
			<span class="keyword">else</span> OF <span class="operator">=</span> Undefined<span class="operator">;</span>
		}
		<span class="keyword">else</span> {
			<span class="comment">//ROR instruction operation</span>
			<span class="keyword">while</span><span class="operator">(</span>TemporaryCount <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> {
				TemporaryCF <span class="operator">=</span> LSB<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">;</span>
				Destination <span class="operator">=</span> <span class="operator">(</span>Destination <span class="operator">&gt;&gt;</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">+</span> <span class="operator">(</span>TemporaryCF <span class="operator">&lt;&lt;</span> Size<span class="operator">)</span><span class="operator">;</span>
				TemporaryCount <span class="operator">=</span> TemporaryCount <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
			}
			CF <span class="operator">=</span> MSB<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> OF <span class="operator">=</span> MSB<span class="operator">(</span>Destination<span class="operator">)</span> <span class="operator">^</span> SMSB<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">;</span> <span class="comment">//SMSB: bit next to high-order bit</span>
			<span class="keyword">else</span> OF <span class="operator">=</span> Undefined<span class="operator">;</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>The CF flag contains the value of the bit shifted into it. The OF flag is affected only for singlebit rotates (see &quot;Description&quot; above); it is undefined for multi-bit rotates. The SF, ZF, AF, and PF flags are not affected.
</p>
</td></tr><tr><td><strong>RCPPS</strong><br />Compute Reciprocals of Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 53 /r</code></td>
<td class="grid"><code>RCPPS xmm1, xmm2/m128</code></td>
<td class="grid">Compute the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and store the results in xmm1.</td>
</tr>
</table></td><td>
<p>Performs an SIMD computation of the approximate reciprocals of the four packed single-precision floating-point values in the source operand (second operand) stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD single-precision floating-point operation.</p>
<p>The relative error for this approximation is:</p>
<p>|Relative Error| &lt;= 1.5 * 2-12 The RCPPS instruction is not affected by the rounding control bits in the MXCSR register.</p>
<p>When a source value is a 0.0, an infinite of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). Tiny results are always flushed to 0.0, with the sign of the operand. (Input values greater than or equal to |1.11111111110100000000000B*2125| are guaranteed to not produce tiny results; input values less than or equal to |1.00000000000110000000001B*2126| are guaranteed to produce tiny results, which are in turn flushed to 0.0; and input values in between this range may or may not produce tiny results, depending on the implementation.) When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Approximate<span class="operator">(</span><span class="number">1.0</span> / Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Approximate<span class="operator">(</span><span class="number">1.0</span> / Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Approximate<span class="operator">(</span><span class="number">1.0</span> / Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Approximate<span class="operator">(</span><span class="number">1.0</span> / Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>RCPSS</strong><br />Compute Reciprocal of Scalar Single-Precision Floating- Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 53 /r</code></td>
<td class="grid"><code>RCPSS xmm1, xmm2/m32</code></td>
<td class="grid">Compute the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and store the result in xmm1.</td>
</tr>
</table></td><td>
<p>Computes of an approximate reciprocal of the low single-precision floating-point value in the source operand (second operand) and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location.</p>
<p>The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of a scalar single-precision floating-point operation.</p>
<p>The relative error for this approximation is:</p>
<p>|Relative Error| &lt;= 1.5 * 2-12 The RCPSS instruction is not affected by the rounding control bits in the MXCSR register.</p>
<p>When a source value is a 0.0, an infinite of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). Tiny results are always flushed to 0.0, with the sign of the operand. (Input values greater than or equal to |1.11111111110100000000000B*2125| are guaranteed to not produce tiny results; input values less than or equal to |1.00000000000110000000001B*2126| are guaranteed to produce tiny results, which are in turn flushed to 0.0; and input values in between this range may or may not produce tiny results, depending on the implementation.) When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Approximate<span class="operator">(</span><span class="number">1.0</span> / Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
<span class="comment">//Destination[32..127] remains unchanged</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>RDMSR</strong><br />Read from Model Specific Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 32</code></td>
<td class="grid"><code>RDMSR</code></td>
<td class="grid">Load MSR specified by ECX into EDX:EAX.</td>
</tr>
</table></td><td>
<p>Loads the contents of a 64-bit model specific register (MSR) specified in the ECX register into registers EDX:EAX. The input value loaded into the ECX register is the address of the MSR to be read. The EDX register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. If fewer than 64 bits are implemented in the MSR being read, the values returned to EDX:EAX in unimplemented bit locations are undefined.</p>
<p>This instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) will be generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a general protection exception.</p>
<p>The MSRs control functions for testability, execution tracing, performance-monitoring, and machine check errors. Appendix B, Model-Specific Registers (MSRs), in the IA-32 Intel Architecture Software Developer's Manual, Volume 3, lists all the MSRs that can be read with this instruction and their addresses. Note that each processor family has its own set of MSRs.</p>
<p>The CPUID instruction should be used to determine whether MSRs are supported (EDX[5]=1) before using this instruction.</p>
<br />
<pre>EDX<span class="operator">:</span>EAX <span class="operator">=</span> MSR<span class="operator">[</span>ECX<span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>RDPMC</strong><br />Read Performance-Monitoring Counters<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 33</code></td>
<td class="grid"><code>RDPMC</code></td>
<td class="grid">Read performance-monitoring counter specified by ECX into EDX:EAX.</td>
</tr>
</table></td><td>
<p>Loads the contents of the 40-bit performance-monitoring counter specified in the ECX register into registers EDX:EAX. The EDX register is loaded with the high-order 8 bits of the counter and the EAX register is loaded with the low-order 32 bits. The counter to be read is specified with an unsigned integer placed in the ECX register. The P6 family processors and Pentium processors with MMX technology have two performance-monitoring counters (0 and 1), which are specified by placing 0000H or 0001H, respectively, in the ECX register. The Pentium 4 and Intel Xeon processors have 18 counters (0 through 17), which are specified with 0000H through 0011H, respectively The Pentium 4 and Intel Xeon processors also support &quot;fast&quot; (32-bit) and &quot;slow&quot; (40-bit) reads of the performance counters, selected with bit 31 of the ECX register. If bit 31 is set, the RDPMC instruction reads only the low 32 bits of the selected performance counter; if bit 31 is clear, all 40 bits of the counter are read. The 32-bit counter result is returned in the EAX register, and the EDX register is set to 0. A 32-bit read executes faster on a Pentium 4 or Intel Xeon processor than a full 40-bit read.</p>
<p>When in protected or virtual 8086 mode, the performance-monitoring counters enabled (PCE) flag in register CR4 restricts the use of the RDPMC instruction as follows. When the PCE flag is set, the RDPMC instruction can be executed at any privilege level; when the flag is clear, the instruction can only be executed at privilege level 0. (When in real-address mode, the RDPMC instruction is always enabled.) The performance-monitoring counters can also be read with the RDMSR instruction, when executing at privilege level 0.</p>
<p>The performance-monitoring counters are event counters that can be programmed to count events such as the number of instructions decoded, number of interrupts received, or number of cache loads. Appendix A, Performance-Monitoring Events, in the IA-32 Intel Architecture Software Developer's Manual, Volume 3, lists the events that can be counted for the Pentium 4, Intel Xeon, and earlier IA-32 processors.</p>
<p>The RDPMC instruction is not a serializing instruction; that is, it does not imply that all the events caused by the preceding instructions have been completed or that events caused by subsequent instructions have not begun. If an exact event count is desired, software must insert a serializing instruction (such as the CPUID instruction) before and/or after the RDPCM instruction.</p>
<p>In the Pentium 4 and Intel Xeon processors, performing back-to-back fast reads are not guaranteed to be monotonic. To guarantee monotonicity on back-to-back reads, a serializing instruction must be placed between the tow RDPMC instructions.</p>
<p>The RDPMC instruction can execute in 16-bit addressing mode or virtual-8086 mode; however, the full contents of the ECX register are used to select the counter, and the event count is stored in the full EAX and EDX registers.</p>
<p>The RDPMC instruction was introduced into the IA-32 Architecture in the Pentium Pro processor and the Pentium processor with MMX technology. The earlier Pentium processors have performance-monitoring counters, but they must be read with the RDMSR instruction.</p>
<br />
<pre><span class="comment">//P6 family processors and Pentium processor with MMX technology</span>
<span class="keyword">if</span><span class="operator">(</span>ECX <span class="operator">&lt;=</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> <span class="operator">(</span>CR4<span class="operator">.</span>PCE <span class="operator">==</span> <span class="number">1</span> <span class="operator">||</span> CPL <span class="operator">==</span> <span class="number">0</span> <span class="operator">||</span> CR0<span class="operator">.</span>PE <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span><span class="operator">)</span> {
	EAX <span class="operator">=</span> PMC<span class="operator">(</span>ECX<span class="operator">)</span><span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
	EDX <span class="operator">=</span> PMC<span class="operator">(</span>ECX<span class="operator">)</span><span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
}
<span class="keyword">else</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//ECX is not 0 or 1 or CR4.PCE is 0 and CPL is 1, 2, or 3 and CR0.PE is 1</span>

<span class="comment">//Pentium 4 and Intel Xeon processor</span>
<span class="keyword">if</span><span class="operator">(</span>ECX<span class="operator">[</span><span class="number">0..30</span><span class="operator">]</span> <span class="operator">&lt;=</span> <span class="number">17</span><span class="operator">)</span> <span class="operator">&amp;&amp;</span> <span class="operator">(</span>CR4<span class="operator">.</span>PCE <span class="operator">==</span> <span class="number">1</span> <span class="operator">||</span> CPL <span class="operator">==</span> <span class="number">0</span> <span class="operator">||</span> CR0<span class="operator">.</span>PE <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>ECX<span class="operator">[</span><span class="number">31</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		EAX <span class="operator">=</span> PMC<span class="operator">(</span>ECX<span class="operator">[</span><span class="number">0..30</span><span class="operator">]</span><span class="operator">)</span><span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span> <span class="comment">//40-bit read</span>
		EDX <span class="operator">=</span> PMC<span class="operator">(</span>ECX<span class="operator">[</span><span class="number">0..30</span><span class="operator">]</span><span class="operator">)</span><span class="operator">[</span><span class="number">32..39</span><span class="operator">]</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>ECX<span class="operator">[</span><span class="number">31</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> {
		EAX <span class="operator">=</span> PMC<span class="operator">(</span>ECX<span class="operator">[</span><span class="number">0..30</span><span class="operator">]</span><span class="operator">)</span><span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span> <span class="comment">//32-bit read</span>
		EDX <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	}
}
<span class="keyword">else</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//ECX[30:0] is not 0...17 or CR4.PCE is 0 and CPL is 1, 2, or 3 and CR0.PE is 1</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>RDTSC</strong><br />Read Time-Stamp Counter<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 31</code></td>
<td class="grid"><code>RDTSC</code></td>
<td class="grid">Read time-stamp counter into EDX:EAX.</td>
</tr>
</table></td><td>
<p>Loads the current value of the processor's time-stamp counter into the EDX:EAX registers. The time-stamp counter is contained in a 64-bit MSR. The high-order 32 bits of the MSR are loaded into the EDX register, and the low-order 32 bits are loaded into the EAX register. The processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever the processor is reset. See &quot;Time Stamp Counter&quot; in Chapter 15 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3 for specific details of the time stamp counter behavior.</p>
<p>When in protected or virtual 8086 mode, the time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSC instruction as follows. When the TSD flag is clear, the RDTSC instruction can be executed at any privilege level; when the flag is set, the instruction can only be executed at privilege level 0. (When in real-address mode, the RDTSC instruction is always enabled.) The time-stamp counter can also be read with the RDMSR instruction, when executing at privilege level 0.</p>
<p>The RDTSC instruction is not a serializing instruction. Thus, it does not necessarily wait until all previous instructions have been executed before reading the counter. Similarly, subsequent instructions may begin execution before the read operation is performed.</p>
<p>This instruction was introduced into the IA-32 Architecture in the Pentium processor.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>CR4<span class="operator">.</span>TSD <span class="operator">==</span> <span class="number">0</span> <span class="operator">||</span> CPL <span class="operator">==</span> <span class="number">0</span> <span class="operator">||</span> CR0<span class="operator">.</span>PE <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> EDX<span class="operator">:</span>EAX <span class="operator">=</span> TimeStampCounter<span class="operator">;</span>
<span class="keyword">else</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//CR4.TSD is 1 and CPL is 1, 2, or 3 and CR0.PE is 1</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>REP/REPE/REPZ/REPNE/REPNZ</strong><br />Repeat String Operation Prefix<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 6C</code></td>
<td class="grid"><code>REP INS m8, DX</code></td>
<td class="grid">Input (E)CX bytes from port DX into ES:[(E)DI].</td>
</tr>
<tr>
<td class="grid"><code>F3 6D</code></td>
<td class="grid"><code>REP INS m16, DX</code></td>
<td class="grid">Input (E)CX words from port DX into ES:[(E)DI].</td>
</tr>
<tr>
<td class="grid"><code>F3 6D</code></td>
<td class="grid"><code>REP INS m32, DX</code></td>
<td class="grid">Input (E)CX doublewords from port DX into ES:[(E)DI].</td>
</tr>
<tr>
<td class="grid"><code>F3 A4</code></td>
<td class="grid"><code>REP MOVS m8, m8</code></td>
<td class="grid">Move (E)CX bytes from DS:[(E)SI] to ES:[(E)DI].</td>
</tr>
<tr>
<td class="grid"><code>F3 A5</code></td>
<td class="grid"><code>REP MOVS m16, m16</code></td>
<td class="grid">Move (E)CX words from DS:[(E)SI] to ES:[(E)DI].</td>
</tr>
<tr>
<td class="grid"><code>F3 A5</code></td>
<td class="grid"><code>REP MOVS m32, m32</code></td>
<td class="grid">Move (E)CX doublewords from DS:[(E)SI] to ES:[(E)DI].</td>
</tr>
<tr>
<td class="grid"><code>F3 6E</code></td>
<td class="grid"><code>REP OUTS DX, r/m8</code></td>
<td class="grid">Output (E)CX bytes from DS:[(E)SI] to port DX.</td>
</tr>
<tr>
<td class="grid"><code>F3 6F</code></td>
<td class="grid"><code>REP OUTS DX, r/m16</code></td>
<td class="grid">Output (E)CX words from DS:[(E)SI] to port DX.</td>
</tr>
<tr>
<td class="grid"><code>F3 6F</code></td>
<td class="grid"><code>REP OUTS DX, r/m32</code></td>
<td class="grid">Output (E)CX doublewords from DS:[(E)SI] to port DX.</td>
</tr>
<tr>
<td class="grid"><code>F3 AC</code></td>
<td class="grid"><code>REP LODS AL</code></td>
<td class="grid">Load (E)CX bytes from DS:[(E)SI] to AL.</td>
</tr>
<tr>
<td class="grid"><code>F3 AD</code></td>
<td class="grid"><code>REP LODS AX</code></td>
<td class="grid">Load (E)CX words from DS:[(E)SI] to AX.</td>
</tr>
<tr>
<td class="grid"><code>F3 AD</code></td>
<td class="grid"><code>REP LODS EAX</code></td>
<td class="grid">Load (E)CX doublewords from DS:[(E)SI] to EAX.</td>
</tr>
<tr>
<td class="grid"><code>F3 AA</code></td>
<td class="grid"><code>REP STOS m8</code></td>
<td class="grid">Fill (E)CX bytes at ES:[(E)DI] with AL.</td>
</tr>
<tr>
<td class="grid"><code>F3 AB</code></td>
<td class="grid"><code>REP STOS m16</code></td>
<td class="grid">Fill (E)CX words at ES:[(E)DI] with AX.</td>
</tr>
<tr>
<td class="grid"><code>F3 AB</code></td>
<td class="grid"><code>REP STOS m32</code></td>
<td class="grid">Fill (E)CX doublewords at ES:[(E)DI] with EAX.</td>
</tr>
<tr>
<td class="grid"><code>F3 A6</code></td>
<td class="grid"><code>REPE CMPS m8, m8</code></td>
<td class="grid">Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI].</td>
</tr>
<tr>
<td class="grid"><code>F3 A7</code></td>
<td class="grid"><code>REPE CMPS m16, m16</code></td>
<td class="grid">Find nonmatching words in ES:[(E)DI] and DS:[(E)SI].</td>
</tr>
<tr>
<td class="grid"><code>F3 A7</code></td>
<td class="grid"><code>REPE CMPS m32, m32</code></td>
<td class="grid">Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI].</td>
</tr>
<tr>
<td class="grid"><code>F3 AE</code></td>
<td class="grid"><code>REPE SCAS m8</code></td>
<td class="grid">Find non-AL byte starting at ES:[(E)DI].</td>
</tr>
<tr>
<td class="grid"><code>F3 AF</code></td>
<td class="grid"><code>REPE SCAS m16</code></td>
<td class="grid">Find non-AX word starting at ES:[(E)DI].</td>
</tr>
<tr>
<td class="grid"><code>F3 AF</code></td>
<td class="grid"><code>REPE SCAS m32</code></td>
<td class="grid">Find non-EAX doubleword starting at ES:[(E)DI].</td>
</tr>
<tr>
<td class="grid"><code>F2 A6</code></td>
<td class="grid"><code>REPNE CMPS m8, m8</code></td>
<td class="grid">Find matching bytes in ES:[(E)DI] and DS:[(E)SI].</td>
</tr>
<tr>
<td class="grid"><code>F2 A7</code></td>
<td class="grid"><code>REPNE CMPS m16, m16</code></td>
<td class="grid">Find matching words in ES:[(E)DI] and DS:[(E)SI].</td>
</tr>
<tr>
<td class="grid"><code>F2 A7</code></td>
<td class="grid"><code>REPNE CMPS m32, m32</code></td>
<td class="grid">Find matching doublewords in ES:[(E)DI] and DS:[(E)SI].</td>
</tr>
<tr>
<td class="grid"><code>F2 AE</code></td>
<td class="grid"><code>REPNE SCAS m8</code></td>
<td class="grid">Find AL, starting at ES:[(E)DI].</td>
</tr>
<tr>
<td class="grid"><code>F2 AF</code></td>
<td class="grid"><code>REPNE SCAS m16</code></td>
<td class="grid">Find AX, starting at ES:[(E)DI].</td>
</tr>
<tr>
<td class="grid"><code>F2 AF</code></td>
<td class="grid"><code>REPNE SCAS m32</code></td>
<td class="grid">Find EAX, starting at ES:[(E)DI].</td>
</tr>
</table></td><td>
<p>Repeats a string instruction the number of times specified in the count register ((E)CX) or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The behavior of the REP prefix is undefined when used with non-string instructions.</p>
<p>The REP prefixes apply only to one string instruction at a time. To repeat a block of instructions, use the LOOP instruction or another looping construct.</p>
<p>All of these repeat prefixes cause the associated instruction to be repeated until the count in register (E)CX is decremented to 0 (see table below). (If the current address-size attribute is 32, register ECX is used as a counter, and if the address-size attribute is 16, the CX register is used.) The REPE, REPNE, REPZ, and REPNZ prefixes also check the state of the ZF flag after each iteration and terminate the repeat loop if the ZF flag is not in the specified state. When both termination conditions are tested, the cause of a repeat termination can be determined either by testing the (E)CX register with a JECXZ instruction or by testing the ZF flag with a JZ, JNZ, and JNE instruction.</p>
<div>
<table class="grid">
<caption>Repeat Prefixes</caption>
<tr><th>Repeat Prefix</th><th>Termination Condition 1</th><th>Termination Condition 2</th></tr>
<tr><td>REP</td><td>ECX=0</td><td>None</td></tr>
<tr><td>REPE/REPZ</td><td>ECX=0</td><td>ZF=0</td></tr>
<tr><td>REPNE/REPNZ</td><td>ECX=0</td><td>ZF=1</td></tr>
</table>
</div>
<p>When the REPE/REPZ and REPNE/REPNZ prefixes are used, the ZF flag does not require initialization because both the CMPS and SCAS instructions affect the ZF flag according to the results of the comparisons they make.</p>
<p>A repeating string operation can be suspended by an exception or interrupt. When this happens, the state of the registers is preserved to allow the string operation to be resumed upon a return from the exception or interrupt handler. The source and destination registers point to the next string elements to be operated on, the EIP register points to the string instruction, and the ECX register has the value it held following the last successful iteration of the instruction. This mechanism allows long string operations to proceed without affecting the interrupt response time of the system.</p>
<p>When a fault occurs during the execution of a CMPS or SCAS instruction that is prefixed with REPE or REPNE, the EFLAGS value is restored to the state prior to the execution of the instruction.</p>
<p>Since the SCAS and CMPS instructions do not use EFLAGS as an input, the processor can resume the instruction after the page fault handler.</p>
<p>Use the REP INS and REP OUTS instructions with caution. Not all I/O ports can handle the rate at which these instructions execute.</p>
<p>A REP STOS instruction is the fastest way to initialize a large block of memory.</p>
<br />REP</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>AddressSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> Counter <span class="operator">=</span> <span class="operator">&amp;</span>CX<span class="operator">;</span> <span class="comment">//use CX</span>
<span class="keyword">else</span> Counter <span class="operator">=</span> <span class="operator">&amp;</span>ECX<span class="operator">;</span> <span class="comment">//AddressSize == 32, use ECX</span>

<span class="keyword">while</span><span class="operator">(</span>Counter <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> {
	ServiceInterrupts<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//service pending interrupts (if any)</span>
	ExecuteStringInstruction<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//execute associated string instruction</span>
	Counter <span class="operator">=</span> Counter <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span><span class="operator">(</span>Instruction <span class="operator">==</span> REPZ <span class="operator">||</span> Instruction <span class="operator">==</span> REPE<span class="operator">)</span> <span class="operator">&amp;&amp;</span> ZF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> <span class="operator">||</span> <span class="operator">(</span><span class="operator">(</span>Instruction <span class="operator">==</span> REPNZ <span class="operator">||</span> Instruction <span class="operator">==</span> REPNE<span class="operator">)</span> <span class="operator">&amp;&amp;</span> ZF <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> <span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td></tr><tr><td><strong>RET</strong><br />Return from Procedure<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>C3</code></td>
<td class="grid"><code>RET</code></td>
<td class="grid">Near return to calling procedure.</td>
</tr>
<tr>
<td class="grid"><code>CB</code></td>
<td class="grid"><code>RET</code></td>
<td class="grid">Far return to calling procedure.</td>
</tr>
<tr>
<td class="grid"><code>C2 iw</code></td>
<td class="grid"><code>RET imm16</code></td>
<td class="grid">Near return to calling procedure and pop imm16 bytes from stack.</td>
</tr>
<tr>
<td class="grid"><code>CA iw</code></td>
<td class="grid"><code>RET imm16</code></td>
<td class="grid">Far return to calling procedure and pop imm16 bytes from stack.</td>
</tr>
</table></td><td>
<p>Transfers program control to a return address located on the top of the stack. The address is usually placed on the stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction.</p>
<p>The optional source operand specifies the number of stack bytes to be released after the return address is popped; the default is none. This operand can be used to release parameters from the stack that were passed to the called procedure and are no longer needed. It must be used when the CALL instruction used to switch to a new procedure uses a call gate with a non-zero word count to access the new procedure. Here, the source operand for the RET instruction must specify the same number of bytes as is specified in the word count field of the call gate.</p>
<p>The RET instruction can be used to execute three different types of returns:</p>
<dl>
<dt>Near return</dt>
<dd>A return to a calling procedure within the current code segment (the segment currently pointed to by the CS register), sometimes referred to as an intrasegment return.</dd>
<dt>Far return</dt>
<dd>A return to a calling procedure located in a different segment than the current code segment, sometimes referred to as an intersegment return.</dd>
<dt>Inter-privilege-level far return</dt>
<dd>A far return to a different privilege level than that of the currently executing program or procedure.</dd>
</dl>
<p>The inter-privilege-level return type can only be executed in protected mode. See the section titled &quot;Calling Procedures Using Call and RET&quot; in Chapter 6 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for detailed information on near, far, and inter-privilege- level returns.</p>
<p>When executing a near return, the processor pops the return instruction pointer (offset) from the top of the stack into the EIP register and begins program execution at the new instruction pointer. The CS register is unchanged.</p>
<p>When executing a far return, the processor pops the return instruction pointer from the top of the stack into the EIP register, then pops the segment selector from the top of the stack into the CS register. The processor then begins program execution in the new code segment at the new instruction pointer.</p>
<p>The mechanics of an inter-privilege-level far return are similar to an intersegment return, except that the processor examines the privilege levels and access rights of the code and stack segments being returned to determine if the control transfer is allowed to be made. The DS, ES, FS, and GS segment registers are cleared by the RET instruction during an inter-privilege-level return if they refer to segments that are not allowed to be accessed at the new privilege level. Since a stack switch also occurs on an inter-privilege level return, the ESP and SS registers are loaded from the stack.</p>
<p>If parameters are passed to the called procedure during an inter-privilege level call, the optional source operand must be used with the RET instruction to release the parameters on the return.</p>
<p>Here, the parameters are released both from the called procedure's stack and the calling procedure's stack (that is, the stack being returned to).</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Instruction<span class="operator">)</span> {
	<span class="keyword">case</span> NearReturn<span class="operator">:</span>
		<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span> <span class="operator">&amp;&amp;</span> <span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>TopStackBytes<span class="operator">(</span><span class="number">12</span><span class="operator">)</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//top 12 bytes of stack not within stack limits</span>
		<span class="comment">//OperandSize == 16</span>
		<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>TopStackBytes<span class="operator">(</span><span class="number">6</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//IF top 6 bytes of stack not within stack limits</span>
		TemporaryEIP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
		TemporaryEIP <span class="operator">=</span> TemporaryEIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>TemporaryEIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
		EIP <span class="operator">=</span> TemporaryEIP<span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span>HasImmediateOperand<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> { <span class="comment">//instruction has immediate operand</span>
			<span class="keyword">if</span><span class="operator">(</span>StackAddressSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> ESP <span class="operator">=</span> ESP <span class="operator">+</span> Source<span class="operator">;</span> <span class="comment">//release parameters from stack</span>
			<span class="comment">//StackAddressSize == 16</span>
			<span class="keyword">else</span> SP <span class="operator">=</span> SP <span class="operator">+</span> Source<span class="operator">;</span> <span class="comment">//release parameters from stack</span>
		}
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> FarReturn<span class="operator">:</span>
		<span class="comment">//Real-address mode or virtual-8086 mode</span>
		<span class="keyword">if</span><span class="operator">(</span>PE <span class="operator">==</span> <span class="number">0</span> <span class="operator">||</span> <span class="operator">(</span>PE <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> VM <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span><span class="operator">)</span> {
			<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>TopStackBytes<span class="operator">(</span><span class="number">12</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//top 12 bytes of stack not within stack limits</span>
				EIP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
				CS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//32-bit pop, high-order 16 bits discarded</span>
			}
			<span class="keyword">else</span> { <span class="comment">//OperandSize == 16</span>
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>TopStackBytes<span class="operator">(</span><span class="number">6</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//top 6 bytes of stack not within stack limits</span>
				TemporaryEIP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
				TemporaryEIP <span class="operator">=</span> TemporaryEIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinCodeSegmentLimits<span class="operator">(</span>TemporaryEIP<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				EIP <span class="operator">=</span> TemporaryEIP<span class="operator">;</span>
				CS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//16-bit pop</span>
			}
			<span class="keyword">if</span><span class="operator">(</span>HasImmediateOperand<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> <span class="keyword">else</span> SP <span class="operator">=</span> SP <span class="operator">+</span> Source<span class="operator">;</span> <span class="comment">//instruction has immediate operand; release parameters from stack</span>
		}
		<span class="comment">//Protected mode, not virtual-8086 mode</span>
		<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>PE <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> VM <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
			<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span> <span class="operator">&amp;&amp;</span> <span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>OffsetStackBytes<span class="operator">(</span><span class="number">4</span><span class="operator">,</span> <span class="number">4</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//second doubleword on stack is not within stack limits</span>
			<span class="comment">//OperandSize == 16</span>
			<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>OffsetStackBytes<span class="operator">(</span><span class="number">2</span><span class="operator">,</span> <span class="number">2</span><span class="operator">)</span><span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//second word on stack is not within stack limits</span>
			<span class="keyword">if</span><span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentSelector<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			ReturnCode<span class="operator">.</span>SegmentDescriptor <span class="operator">=</span> ObtainSegmentDescriptor<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//Obtain descriptor to which return code segment selector points from descriptor table</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsCodeSegment<span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentDescriptor<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL <span class="operator">&lt;</span> CPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>IsConforming<span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentDescriptor <span class="operator">&amp;&amp;</span> ReturnCode<span class="operator">.</span>Segment<span class="operator">.</span>DPL <span class="operator">&gt;</span> ReturnCode<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentDescriptor<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>NP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
			<span class="keyword">if</span><span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL <span class="operator">&gt;</span> CPL<span class="operator">)</span> {
				<span class="comment">//Return outer privilege level</span>
				<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span> <span class="operator">&amp;&amp;</span> <span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>TopStackBytes<span class="operator">(</span><span class="number">16</span> <span class="operator">+</span> Source<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//top 16 + Source bytes of stack not within stack limits</span>
				<span class="comment">//OperandSize == 16</span>
				<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinStackLimits<span class="operator">(</span>TopStackBytes<span class="operator">(</span><span class="number">8</span> <span class="operator">+</span> Source<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//top 8 + Source bytes of stack not within stack limits</span>
				ReturnSegmentSelector <span class="operator">=</span> ReadReturnSegmentSelector<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span>StackSegmentSelector <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>ReturnStack<span class="operator">.</span>SegmentSelector<span class="operator">.</span>Index<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span>StackSegmentSelector<span class="operator">.</span>RPL <span class="operator">!=</span> ReturnCode<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL <span class="operator">||</span> <span class="operator">!</span>IsWritableDataSegment<span class="operator">(</span>StackSegment<span class="operator">)</span> <span class="operator">||</span> StackSegmentDescriptor<span class="operator">.</span>DPL <span class="operator">!=</span> ReturnCode<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL<span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span>Selector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsPresent<span class="operator">(</span>StackSegment<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>SS<span class="operator">(</span>StackSegmentSelector<span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinLimits<span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentLimit<span class="operator">,</span> ReturnInstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				CPL <span class="operator">=</span> ReturnCode<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL<span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
					EIP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
					CS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//32-bit pop, high-order 16 bits discarded; segment descriptor information also loaded</span>
					CS<span class="operator">.</span>RPL <span class="operator">=</span> CPL<span class="operator">;</span>
					ESP <span class="operator">=</span> ESP <span class="operator">+</span> Source<span class="operator">;</span> <span class="comment">//release parameters from called procedure's stack</span>
					TemporaryESP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
					TemporarySS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//32-bit pop, high-order 16 bits discarded; segment descriptor information also loaded</span>
					ESP <span class="operator">=</span> TemporaryESP<span class="operator">;</span>
					SS <span class="operator">=</span> TemporarySS<span class="operator">;</span>
				}
				<span class="comment">//OperandSize == 16</span>
				<span class="keyword">else</span> {
					EIP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
					EIP <span class="operator">=</span> EIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span>
					CS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//16-bit pop; segment descriptor information also loaded</span>
					CS<span class="operator">.</span>RPL <span class="operator">=</span> CPL<span class="operator">;</span>
					ESP <span class="operator">=</span> ESP <span class="operator">+</span> Source<span class="operator">;</span> <span class="comment">//release parameters from called procedure's stack</span>
					TemporaryESP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
					TemporarySS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//16-bit pop; segment descriptor information also loaded</span>
					ESP <span class="operator">=</span> TemporaryESP<span class="operator">;</span>
					SS <span class="operator">=</span> TemporarySS<span class="operator">;</span>
				}
				SegmentRegisters<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {ES<span class="operator">,</span> FS<span class="operator">,</span> GS<span class="operator">,</span> DS}<span class="operator">;</span>
				<span class="keyword">while</span><span class="operator">(</span>SegmentRegister <span class="operator">=</span> NextSegmentRegister<span class="operator">(</span>SegmentRegisters<span class="operator">)</span><span class="operator">)</span> {
					<span class="keyword">if</span><span class="operator">(</span>IsDataPointer<span class="operator">(</span>SegmentRegister<span class="operator">)</span>  <span class="operator">||</span> <span class="operator">!</span>IsConformingCodeSegment<span class="operator">(</span>SegmentRegister<span class="operator">)</span> <span class="operator">&amp;&amp;</span> CPL <span class="operator">&gt;</span> SegmentDescriptor<span class="operator">.</span>DPL <span class="comment">/*DPL in hidden part of segment register*/</span><span class="operator">)</span> SegmentSelector <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//segment register is invalid, null segment selector</span>
					<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinDescriptorTableLimits<span class="operator">(</span>SegmentSelector<span class="operator">.</span>Index<span class="operator">)</span> <span class="operator">||</span> <span class="operator">(</span><span class="operator">!</span>IsData<span class="operator">(</span>SegmentDescriptor<span class="operator">)</span> <span class="operator">&amp;&amp;</span> <span class="operator">!</span>IsReadableCodeSegment<span class="operator">(</span>SegmentDescriptor<span class="operator">)</span><span class="operator">)</span> <span class="operator">||</span> <span class="operator">(</span>IsData<span class="operator">(</span>SegmentDescriptor<span class="operator">)</span> <span class="operator">&amp;&amp;</span> <span class="operator">!</span>IsConformingCodeSegment<span class="operator">(</span>SegmentDescriptor<span class="operator">)</span> <span class="operator">&amp;&amp;</span> SegmentDescriptor<span class="operator">.</span>DPL <span class="operator">&lt;</span> CPL <span class="operator">&amp;&amp;</span> SegmentDescriptor<span class="operator">.</span>DPL <span class="operator">&lt;</span> CodeSegment<span class="operator">.</span>SegmentSelector<span class="operator">.</span>RPL<span class="operator">)</span><span class="operator">)</span> SegmentSelectorRegister <span class="operator">=</span> NullSelector<span class="operator">;</span>
					ESP <span class="operator">=</span> ESP <span class="operator">+</span> Source<span class="operator">;</span> <span class="comment">//release parameters from called procedure's stack</span>
				}
			}
			<span class="keyword">else</span> {
				<span class="comment">//Return to same privilege level</span>
				<span class="keyword">if</span><span class="operator">(</span><span class="operator">!</span>IsWithinLimits<span class="operator">(</span>ReturnCode<span class="operator">.</span>SegmentLimit<span class="operator">,</span> ReturnInstructionPointer<span class="operator">)</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
				<span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">32</span><span class="operator">)</span> {
					EIP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
					CS <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//32-bit pop, high-order 16 bits are discarded</span>
					ESP <span class="operator">=</span> ESP <span class="operator">+</span> Source<span class="operator">;</span> <span class="comment">//Release parameters from stack</span>
				}
				<span class="keyword">else</span> { <span class="comment">//OperandSize == 16</span>
					EIP <span class="operator">=</span> Pop<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
					EIP <span class="operator">=</span> EIP <span class="operator">&amp;</span> <span class="number">0xFFFF</span><span class="operator">;</span>
					ESP <span class="operator">=</span> ESP <span class="operator">+</span> Source<span class="operator">;</span> <span class="comment">//Release parameters from stack</span>
				}
			}
		}
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>RSM</strong><br />Resume from System Management Mode<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F AA</code></td>
<td class="grid"><code>RSM</code></td>
<td class="grid">Resume operation of interrupted program.</td>
</tr>
</table></td><td>
<p>Returns program control from system management mode (SMM) to the application program or operating-system procedure that was interrupted when the processor received an SMM interrupt.</p>
<p>The processor's state is restored from the dump created upon entering SMM. If the processor detects invalid state information during state restoration, it enters the shutdown state.</p>
<p>The following invalid information can cause a shutdown:</p>
<ul>
<li>Any reserved bit of CR4 is set to 1.</li>
<li>Any illegal combination of bits in CR0, such as (PG=1 and PE=0) or (NW=1 and CD=0).</li>
<li>(Intel Pentium and Intel486 processors only.) The value stored in the state dump base field is not a 32-KByte aligned address.</li>
</ul>
<p>The contents of the model-specific registers are not affected by a return from SMM.</p>
<p>See Chapter 13, System Management Mode (SMM), in the IA-32 Intel Architecture Software Developer's Manual, Volume 3, for more information about SMM and the behavior of the RSM instruction.</p>
<br />
<pre>ReturnFromSMM<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
ProcessorState <span class="operator">=</span> Restore<span class="operator">(</span>SMMDump<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>All.
</p>
</td></tr><tr><td><strong>RSQRTPS</strong><br />Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 52 /r</code></td>
<td class="grid"><code>RSQRTPS xmm1, xmm2/m128</code></td>
<td class="grid">Compute the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and store the results in xmm1.</td>
</tr>
</table></td><td>
<p>Performs an SIMD computation of the approximate reciprocals of the square roots of the four packed single-precision floating-point values in the source operand (second operand) and stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD single-precision floating-point operation.</p>
<p>The relative error for this approximation is:</p>
<p>|Relative Error| &lt;= 1.5 * 2-12 The RSQRTPS instruction is not affected by the rounding control bits in the MXCSR register.</p>
<p>When a source value is a 0.0, an infinite of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). When a source value is a negative value (other than -0.0), a floating-point indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Approximate<span class="operator">(</span><span class="number">1.0</span> / SquareRoot<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Approximate<span class="operator">(</span><span class="number">1.0</span> / SquareRoot<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Approximate<span class="operator">(</span><span class="number">1.0</span> / SquareRoot<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Approximate<span class="operator">(</span><span class="number">1.0</span> / SquareRoot<span class="operator">(</span>Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>RSQRTSS</strong><br />Compute Reciprocal of Square Root of Scalar Single- Precision Floating-Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 52 /r</code></td>
<td class="grid"><code>RSQRTSS xmm1, xmm2/m32</code></td>
<td class="grid">Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1.</td>
</tr>
</table></td><td>
<p>Computes an approximate reciprocal of the square root of the low single-precision floatingpoint value in the source operand (second operand) stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of a scalar single-precision floating-point operation.</p>
<p>The relative error for this approximation is:</p>
<p>|Relative Error| &lt;= 1.5 * 2-12 The RSQRTSS instruction is not affected by the rounding control bits in the MXCSR register.</p>
<p>When a source value is a 0.0, an infinite of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). When a source value is a negative value (other than -0.0), a floating-point indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Approximate<span class="operator">(</span><span class="number">1.0</span> / SquareRoot<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
<span class="comment">//Destination[32..127] remains unchanged</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>SAHF</strong><br />Store AH into Flags<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>9E</code></td>
<td class="grid"><code>SAHF</code></td>
<td class="grid">Load SF, ZF, AF, PF, and CF from AH into EFLAGS register.</td>
</tr>
</table></td><td>
<p>Loads the SF, ZF, AF, PF, and CF flags of the EFLAGS register with values from the corresponding bits in the AH register (bits 7, 6, 4, 2, and 0, respectively). Bits 1, 3, and 5 of register AH are ignored; the corresponding reserved bits (1, 3, and 5) in the EFLAGS register remain as shown in the &quot;Operation&quot; section below.</p>
<br />
<pre>EFLAGS<span class="operator">(</span>SF<span class="operator">:</span>ZF<span class="operator">:</span><span class="number">0</span><span class="operator">:</span>AF<span class="operator">:</span><span class="number">0</span><span class="operator">:</span>PF<span class="operator">:</span><span class="number">1</span><span class="operator">:</span>CF<span class="operator">)</span> <span class="operator">=</span> AH<span class="operator">;</span>
</pre>
</td><td>
<p>The SF, ZF, AF, PF, and CF flags are loaded with values from the AH register. Bits 1, 3, and 5 of the EFLAGS register are unaffected, with the values remaining 1, 0, and 0, respectively.
</p>
</td></tr><tr><td><strong>SAL/SAR/SHL/SHR</strong><br />Shift<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D0 /4</code></td>
<td class="grid"><code>SAL r/m8</code></td>
<td class="grid">Multiply r/m8 by 2, 1 time.</td>
</tr>
<tr>
<td class="grid"><code>D2 /4</code></td>
<td class="grid"><code>SAL r/m8,CL</code></td>
<td class="grid">Multiply r/m8 by 2, CL times.</td>
</tr>
<tr>
<td class="grid"><code>C0 /4 ib</code></td>
<td class="grid"><code>SAL r/m8,imm8</code></td>
<td class="grid">Multiply r/m8 by 2, imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D1 /4</code></td>
<td class="grid"><code>SAL r/m16</code></td>
<td class="grid">Multiply r/m16 by 2, 1 time.</td>
</tr>
<tr>
<td class="grid"><code>D3 /4</code></td>
<td class="grid"><code>SAL r/m16,CL</code></td>
<td class="grid">Multiply r/m16 by 2, CL times.</td>
</tr>
<tr>
<td class="grid"><code>C1 /4 ib</code></td>
<td class="grid"><code>SAL r/m16,imm8</code></td>
<td class="grid">Multiply r/m16 by 2, imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D1 /4</code></td>
<td class="grid"><code>SAL r/m32</code></td>
<td class="grid">Multiply r/m32 by 2, 1 time.</td>
</tr>
<tr>
<td class="grid"><code>D3 /4</code></td>
<td class="grid"><code>SAL r/m32,CL</code></td>
<td class="grid">Multiply r/m32 by 2, CL times.</td>
</tr>
<tr>
<td class="grid"><code>C1 /4 ib</code></td>
<td class="grid"><code>SAL r/m32,imm8</code></td>
<td class="grid">Multiply r/m32 by 2, imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D0 /7</code></td>
<td class="grid"><code>SAR r/m8</code></td>
<td class="grid">Signed divide* r/m8 by 2, 1 times.</td>
</tr>
<tr>
<td class="grid"><code>D2 /7</code></td>
<td class="grid"><code>SAR r/m8,CL</code></td>
<td class="grid">Signed divide* r/m8 by 2, CL times.</td>
</tr>
<tr>
<td class="grid"><code>C0 /7 ib</code></td>
<td class="grid"><code>SAR r/m8,imm8</code></td>
<td class="grid">Signed divide* r/m8 by 2, imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D1 /7</code></td>
<td class="grid"><code>SAR r/m16</code></td>
<td class="grid">Signed divide* r/m16 by 2, 1 time.</td>
</tr>
<tr>
<td class="grid"><code>D3 /7</code></td>
<td class="grid"><code>SAR r/m16,CL</code></td>
<td class="grid">Signed divide* r/m16 by 2, CL times.</td>
</tr>
<tr>
<td class="grid"><code>C1 /7 ib</code></td>
<td class="grid"><code>SAR r/m16,imm8</code></td>
<td class="grid">Signed divide* r/m16 by 2, imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D1 /7</code></td>
<td class="grid"><code>SAR r/m32</code></td>
<td class="grid">Signed divide* r/m32 by 2, 1 time.</td>
</tr>
<tr>
<td class="grid"><code>D3 /7</code></td>
<td class="grid"><code>SAR r/m32,CL</code></td>
<td class="grid">Signed divide* r/m32 by 2, CL times.</td>
</tr>
<tr>
<td class="grid"><code>C1 /7 ib</code></td>
<td class="grid"><code>SAR r/m32,imm8</code></td>
<td class="grid">Signed divide* r/m32 by 2, imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D0 /4</code></td>
<td class="grid"><code>SHL r/m8</code></td>
<td class="grid">Multiply r/m8 by 2, 1 time.</td>
</tr>
<tr>
<td class="grid"><code>D2 /4</code></td>
<td class="grid"><code>SHL r/m8,CL</code></td>
<td class="grid">Multiply r/m8 by 2, CL times.</td>
</tr>
<tr>
<td class="grid"><code>C0 /4 ib</code></td>
<td class="grid"><code>SHL r/m8,imm8</code></td>
<td class="grid">Multiply r/m8 by 2, imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D1 /4</code></td>
<td class="grid"><code>SHL r/m16</code></td>
<td class="grid">Multiply r/m16 by 2, 1 time.</td>
</tr>
<tr>
<td class="grid"><code>D3 /4</code></td>
<td class="grid"><code>SHL r/m16,CL</code></td>
<td class="grid">Multiply r/m16 by 2, CL times.</td>
</tr>
<tr>
<td class="grid"><code>C1 /4 ib</code></td>
<td class="grid"><code>SHL r/m16,imm8</code></td>
<td class="grid">Multiply r/m16 by 2, imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D1 /4</code></td>
<td class="grid"><code>SHL r/m32</code></td>
<td class="grid">Multiply r/m32 by 2, 1 time.</td>
</tr>
<tr>
<td class="grid"><code>D3 /4</code></td>
<td class="grid"><code>SHL r/m32,CL</code></td>
<td class="grid">Multiply r/m32 by 2, CL times.</td>
</tr>
<tr>
<td class="grid"><code>C1 /4 ib</code></td>
<td class="grid"><code>SHL r/m32,imm8</code></td>
<td class="grid">Multiply r/m32 by 2, imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D0 /5</code></td>
<td class="grid"><code>SHR r/m8</code></td>
<td class="grid">Unsigned divide r/m8 by 2, 1 time.</td>
</tr>
<tr>
<td class="grid"><code>D2 /5</code></td>
<td class="grid"><code>SHR r/m8,CL</code></td>
<td class="grid">Unsigned divide r/m8 by 2, CL times.</td>
</tr>
<tr>
<td class="grid"><code>C0 /5 ib</code></td>
<td class="grid"><code>SHR r/m8,imm8</code></td>
<td class="grid">Unsigned divide r/m8 by 2, imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D1 /5</code></td>
<td class="grid"><code>SHR r/m16</code></td>
<td class="grid">Unsigned divide r/m16 by 2, 1 time.</td>
</tr>
<tr>
<td class="grid"><code>D3 /5</code></td>
<td class="grid"><code>SHR r/m16,CL</code></td>
<td class="grid">Unsigned divide r/m16 by 2, CL times.</td>
</tr>
<tr>
<td class="grid"><code>C1 /5 ib</code></td>
<td class="grid"><code>SHR r/m16,imm8</code></td>
<td class="grid">Unsigned divide r/m16 by 2, imm8 times.</td>
</tr>
<tr>
<td class="grid"><code>D1 /5</code></td>
<td class="grid"><code>SHR r/m32</code></td>
<td class="grid">Unsigned divide r/m32 by 2, 1 time.</td>
</tr>
<tr>
<td class="grid"><code>D3 /5</code></td>
<td class="grid"><code>SHR r/m32,CL</code></td>
<td class="grid">Unsigned divide r/m32 by 2, CL times.</td>
</tr>
<tr>
<td class="grid"><code>C1 /5 ib</code></td>
<td class="grid"><code>SHR r/m32,imm8</code></td>
<td class="grid">Unsigned divide r/m32 by 2, imm8 times.</td>
</tr>
</table></td><td>
<p>NOTE: * Not the same form of division as IDIV; rounding is toward negative infinity.</p>
<p>Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF flag, then discarded. At the end of the shift operation, the CF flag contains the last bit shifted out of the destination operand.</p>
<p>The destination operand can be a register or a memory location. The count operand can be an immediate value or register CL. The count is masked to 5 bits, which limits the count range to 0 to 31. A special opcode encoding is provided for a count of 1.</p>
<p>The shift arithmetic left (SAL) and shift logical left (SHL) instructions perform the same operation; they shift the bits in the destination operand to the left (toward more significant bit locations).</p>
<p>For each shift count, the most significant bit of the destination operand is shifted into the CF flag, and the least significant bit is cleared (see Figure 7-7 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1).</p>
<p>The shift arithmetic right (SAR) and shift logical right (SHR) instructions shift the bits of the destination operand to the right (toward less significant bit locations). For each shift count, the least significant bit of the destination operand is shifted into the CF flag, and the most significant bit is either set or cleared depending on the instruction type. The SHR instruction clears the most significant bit (see Figure 7-8 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1); the SAR instruction sets or clears the most significant bit to correspond to the sign (most significant bit) of the original value in the destination operand. In effect, the SAR instruction fills the empty bit position's shifted value with the sign of the unshifted value (see Figure 7-9 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1).</p>
<p>The SAR and SHR instructions can be used to perform signed or unsigned division, respectively, of the destination operand by powers of 2. For example, using the SAR instruction to shift a signed integer 1 bit to the right divides the value by 2.</p>
<p>Using the SAR instruction to perform a division operation does not produce the same result as the IDIV instruction. The quotient from the IDIV instruction is rounded toward zero, whereas the &quot;quotient&quot; of the SAR instruction is rounded toward negative infinity. This difference is apparent only for negative numbers. For example, when the IDIV instruction is used to divide -9 by 4, the result is -2 with a remainder of -1. If the SAR instruction is used to shift -9 right by two bits, the result is -3 and the &quot;remainder&quot; is +3; however, the SAR instruction stores only the most significant bit of the remainder (in the CF flag).</p>
<p>The OF flag is affected only on 1-bit shifts. For left shifts, the OF flag is set to 0 if the mostsignificant bit of the result is the same as the CF flag (that is, the top two bits of the original operand were the same); otherwise, it is set to 1. For the SAR instruction, the OF flag is cleared for all 1-bit shifts. For the SHR instruction, the OF flag is set to the most-significant bit of the original operand.</p>
<br />
<pre>TemporaryCount <span class="operator">=</span> Count <span class="operator">&amp;</span> <span class="number">0x1F</span><span class="operator">;</span>
TemporaryDestination <span class="operator">=</span> Destination<span class="operator">;</span>
<span class="keyword">while</span><span class="operator">(</span>TemporaryCount <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> SAL <span class="operator">||</span> Instruction <span class="operator">==</span> SHL<span class="operator">)</span> {
		CF <span class="operator">=</span> MSB<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">;</span>
		Destination <span class="operator">=</span> Destination <span class="operator">&lt;&lt;</span> <span class="number">1</span><span class="operator">;</span>
	}
	<span class="comment">//instruction is SAR or SHR</span>
	<span class="keyword">else</span> {
		CF <span class="operator">=</span> LSB<span class="operator">(</span>Destination<span class="operator">)</span><span class="operator">;</span>
		<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> SAR<span class="operator">)</span> Destination <span class="operator">=</span> Destination / <span class="number">2</span><span class="operator">;</span> <span class="comment">//Signed divide, rounding toward negative infinity</span>
		<span class="comment">//Instruction is SHR</span>
		<span class="keyword">else</span> Destination <span class="operator">=</span> Destination / <span class="number">2</span><span class="operator">;</span> <span class="comment">//Unsigned divide</span>
	}
	TemporaryCount <span class="operator">=</span> TemporaryCount <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
}
<span class="comment">//Determine overflow</span>
<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&amp;</span> <span class="number">0x1F</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> SAL <span class="operator">||</span> Instruction <span class="operator">==</span> SHL<span class="operator">)</span> OF <span class="operator">=</span> MSB<span class="operator">(</span>Destination<span class="operator">)</span> <span class="operator">^</span> CF<span class="operator">;</span>
	<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>Instruction <span class="operator">==</span> SAR<span class="operator">)</span> OF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	<span class="comment">//Instruction == SHR</span>
	<span class="keyword">else</span> OF <span class="operator">=</span> MSB<span class="operator">(</span>TemporaryDestination<span class="operator">)</span><span class="operator">;</span>
}
<span class="keyword">else</span> OF <span class="operator">=</span> Undefined<span class="operator">;</span>
</pre>
</td><td>
<p>The CF flag contains the value of the last bit shifted out of the destination operand; it is undefined for SHL and SHR instructions where the count is greater than or equal to the size (in bits) of the destination operand. The OF flag is affected only for 1-bit shifts (see &quot;Description&quot; above); otherwise, it is undefined. The SF, ZF, and PF flags are set according to the result. If the count is 0, the flags are not affected. For a non-zero count, the AF flag is undefined.
</p>
</td></tr><tr><td><strong>SBB</strong><br />Integer Subtraction with Borrow<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>1C ib</code></td>
<td class="grid"><code>SBB AL,imm8</code></td>
<td class="grid">Subtract with borrow imm8 from AL.</td>
</tr>
<tr>
<td class="grid"><code>1D iw</code></td>
<td class="grid"><code>SBB AX,imm16</code></td>
<td class="grid">Subtract with borrow imm16 from AX.</td>
</tr>
<tr>
<td class="grid"><code>1D id</code></td>
<td class="grid"><code>SBB EAX,imm32</code></td>
<td class="grid">Subtract with borrow imm32 from EAX.</td>
</tr>
<tr>
<td class="grid"><code>80 /3 ib</code></td>
<td class="grid"><code>SBB r/m8,imm8</code></td>
<td class="grid">Subtract with borrow imm8 from r/m8.</td>
</tr>
<tr>
<td class="grid"><code>81 /3 iw</code></td>
<td class="grid"><code>SBB r/m16,imm16</code></td>
<td class="grid">Subtract with borrow imm16 from r/m16.</td>
</tr>
<tr>
<td class="grid"><code>81 /3 id</code></td>
<td class="grid"><code>SBB r/m32,imm32</code></td>
<td class="grid">Subtract with borrow imm32 from r/m32.</td>
</tr>
<tr>
<td class="grid"><code>83 /3 ib</code></td>
<td class="grid"><code>SBB r/m16,imm8</code></td>
<td class="grid">Subtract with borrow sign-extended imm8 from r/m16.</td>
</tr>
<tr>
<td class="grid"><code>83 /3 ib</code></td>
<td class="grid"><code>SBB r/m32,imm8</code></td>
<td class="grid">Subtract with borrow sign-extended imm8 from r/m32.</td>
</tr>
<tr>
<td class="grid"><code>18 /r</code></td>
<td class="grid"><code>SBB r/m8,r8</code></td>
<td class="grid">Subtract with borrow r8 from r/m8.</td>
</tr>
<tr>
<td class="grid"><code>19 /r</code></td>
<td class="grid"><code>SBB r/m16,r16</code></td>
<td class="grid">Subtract with borrow r16 from r/m16.</td>
</tr>
<tr>
<td class="grid"><code>19 /r</code></td>
<td class="grid"><code>SBB r/m32,r32</code></td>
<td class="grid">Subtract with borrow r32 from r/m32.</td>
</tr>
<tr>
<td class="grid"><code>1A /r</code></td>
<td class="grid"><code>SBB r8,r/m8</code></td>
<td class="grid">Subtract with borrow r/m8 from r8.</td>
</tr>
<tr>
<td class="grid"><code>1B /r</code></td>
<td class="grid"><code>SBB r16,r/m16</code></td>
<td class="grid">Subtract with borrow r/m16 from r16.</td>
</tr>
<tr>
<td class="grid"><code>1B /r</code></td>
<td class="grid"><code>SBB r32,r/m32</code></td>
<td class="grid">Subtract with borrow r/m32 from r32.</td>
</tr>
</table></td><td>
<p>Adds the source operand (second operand) and the carry (CF) flag, and subtracts the result from the destination operand (first operand). The result of the subtraction is stored in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a borrow from a previous subtraction.</p>
<p>When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</p>
<p>The SBB instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a borrow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.</p>
<p>The SBB instruction is usually executed as part of a multibyte or multiword subtraction in which a SUB instruction is followed by a SBB instruction.</p>
<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<br />
<pre>Destination <span class="operator">=</span> Destination <span class="operator">-</span> <span class="operator">(</span>Source <span class="operator">+</span> CF<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>The OF, SF, ZF, AF, PF, and CF flags are set according to the result.
</p>
</td></tr><tr><td><strong>SCAS/SCASB/SCASW/SCASD</strong><br />Scan String<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>AE</code></td>
<td class="grid"><code>SCAS m8</code></td>
<td class="grid">Compare AL with byte at ES:(E)DI and set status flags.</td>
</tr>
<tr>
<td class="grid"><code>AF</code></td>
<td class="grid"><code>SCAS m16</code></td>
<td class="grid">Compare AX with word at ES:(E)DI and set status flags.</td>
</tr>
<tr>
<td class="grid"><code>AF</code></td>
<td class="grid"><code>SCAS m32</code></td>
<td class="grid">Compare EAX with doubleword at ES(E)DI and set status flags.</td>
</tr>
<tr>
<td class="grid"><code>AE</code></td>
<td class="grid"><code>SCASB</code></td>
<td class="grid">Compare AL with byte at ES:(E)DI and set status flags.</td>
</tr>
<tr>
<td class="grid"><code>AF</code></td>
<td class="grid"><code>SCASW</code></td>
<td class="grid">Compare AX with word at ES:(E)DI and set status flags.</td>
</tr>
<tr>
<td class="grid"><code>AF</code></td>
<td class="grid"><code>SCASD</code></td>
<td class="grid">Compare EAX with doubleword at ES:(E)DI and set status flags.</td>
</tr>
</table></td><td>
<p>Compares the byte, word, or double word specified with the memory operand with the value in the AL, AX, or EAX register, and sets the status flags in the EFLAGS register according to the results. The memory operand address is read from either the ES:EDI or the ES:DI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The ES segment cannot be overridden with a segment override prefix.</p>
<p>At the assembly-code level, two forms of this instruction are allowed: the &quot;explicit-operands&quot; form and the &quot;no-operands&quot; form. The explicit-operand form (specified with the SCAS mnemonic) allows the memory operand to be specified explicitly. Here, the memory operand should be a symbol that indicates the size and location of the operand value. The register operand is then automatically selected to match the size of the memory operand (the AL register for byte comparisons, AX for word comparisons, and EAX for doubleword comparisons). This explicit-operand form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the memory operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers, which must be loaded correctly before the compare string instruction is executed.</p>
<p>The no-operands form provides &quot;short forms&quot; of the byte, word, and doubleword versions of the SCAS instructions. Here also ES:(E)DI is assumed to be the memory operand and the AL, AX, or EAX register is assumed to be the register operand. The size of the two operands is selected with the mnemonic: SCASB (byte comparison), SCASW (word comparison), or SCASD (doubleword comparison).</p>
<p>After the comparison, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.</p>
<p>The SCAS, SCASB, SCASW, and SCASD instructions can be preceded by the REP prefix for block comparisons of ECX bytes, words, or doublewords. More often, however, these instructions will be used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made. See &quot;REP/REPE/REPZ/REPNE /REPNZ-Repeat String Operation Prefix&quot; in this chapter for a description of the REP prefix.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>IsByteComparison<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	Temporary <span class="operator">=</span> AL <span class="operator">-</span> Source<span class="operator">;</span>
	SetStatusFlags<span class="operator">(</span>Temporary<span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
	}
}
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>IsWordComparison<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	Temporary <span class="operator">=</span> Ax <span class="operator">-</span> Source<span class="operator">;</span>
	SetStatusFlags<span class="operator">(</span>Temporary<span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
	}
}
<span class="keyword">else</span> { <span class="comment">//doubleword comparison</span>
	Temporary <span class="operator">=</span> EAX <span class="operator">-</span> Source<span class="operator">;</span>
	SetStatusFlags<span class="operator">(</span>Temporary<span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
	}
}
</pre>
</td><td>
<p>The OF, SF, ZF, AF, PF, and CF flags are set according to the temporary result of the comparison.
</p>
</td></tr><tr><td><strong>SETcc</strong><br />Set Byte on Condition<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 97</code></td>
<td class="grid"><code>SETA r/m8</code></td>
<td class="grid">Set byte if above (CF=0 and ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 93</code></td>
<td class="grid"><code>SETAE r/m8</code></td>
<td class="grid">Set byte if above or equal (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 92</code></td>
<td class="grid"><code>SETB r/m8</code></td>
<td class="grid">Set byte if below (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 96</code></td>
<td class="grid"><code>SETBE r/m8</code></td>
<td class="grid">Set byte if below or equal (CF=1 or ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 92</code></td>
<td class="grid"><code>SETC r/m8</code></td>
<td class="grid">Set if carry (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 94</code></td>
<td class="grid"><code>SETE r/m8</code></td>
<td class="grid">Set byte if equal (ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 9F</code></td>
<td class="grid"><code>SETG r/m8</code></td>
<td class="grid">Set byte if greater (ZF=0 and SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 9D</code></td>
<td class="grid"><code>SETGE r/m8</code></td>
<td class="grid">Set byte if greater or equal (SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 9C</code></td>
<td class="grid"><code>SETL r/m8</code></td>
<td class="grid">Set byte if less (SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 9E</code></td>
<td class="grid"><code>SETLE r/m8</code></td>
<td class="grid">Set byte if less or equal (ZF=1 or SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 96</code></td>
<td class="grid"><code>SETNA r/m8</code></td>
<td class="grid">Set byte if not above (CF=1 or ZF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 92</code></td>
<td class="grid"><code>SETNAE r/m8</code></td>
<td class="grid">Set byte if not above or equal (CF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 93</code></td>
<td class="grid"><code>SETNB r/m8</code></td>
<td class="grid">Set byte if not below (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 97</code></td>
<td class="grid"><code>SETNBE r/m8</code></td>
<td class="grid">Set byte if not below or equal (CF=0 and ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 93</code></td>
<td class="grid"><code>SETNC r/m8</code></td>
<td class="grid">Set byte if not carry (CF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 95</code></td>
<td class="grid"><code>SETNE r/m8</code></td>
<td class="grid">Set byte if not equal (ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 9E</code></td>
<td class="grid"><code>SETNG r/m8</code></td>
<td class="grid">Set byte if not greater (ZF=1 or SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 9C</code></td>
<td class="grid"><code>SETNGE r/m8</code></td>
<td class="grid">Set if not greater or equal (SF&lt;&gt;OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 9D</code></td>
<td class="grid"><code>SETNL r/m8</code></td>
<td class="grid">Set byte if not less (SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 9F</code></td>
<td class="grid"><code>SETNLE r/m8</code></td>
<td class="grid">Set byte if not less or equal (ZF=0 and SF=OF).</td>
</tr>
<tr>
<td class="grid"><code>0F 91</code></td>
<td class="grid"><code>SETNO r/m8</code></td>
<td class="grid">Set byte if not overflow (OF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 9B</code></td>
<td class="grid"><code>SETNP r/m8</code></td>
<td class="grid">Set byte if not parity (PF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 99</code></td>
<td class="grid"><code>SETNS r/m8</code></td>
<td class="grid">Set byte if not sign (SF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 95</code></td>
<td class="grid"><code>SETNZ r/m8</code></td>
<td class="grid">Set byte if not zero (ZF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 90</code></td>
<td class="grid"><code>SETO r/m8</code></td>
<td class="grid">Set byte if overflow (OF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 9A</code></td>
<td class="grid"><code>SETP r/m8</code></td>
<td class="grid">Set byte if parity (PF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 9A</code></td>
<td class="grid"><code>SETPE r/m8</code></td>
<td class="grid">Set byte if parity even (PF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 9B</code></td>
<td class="grid"><code>SETPO r/m8</code></td>
<td class="grid">Set byte if parity odd (PF=0).</td>
</tr>
<tr>
<td class="grid"><code>0F 98</code></td>
<td class="grid"><code>SETS r/m8</code></td>
<td class="grid">Set byte if sign (SF=1).</td>
</tr>
<tr>
<td class="grid"><code>0F 94</code></td>
<td class="grid"><code>SETZ r/m8</code></td>
<td class="grid">Set byte if zero (ZF=1).</td>
</tr>
</table></td><td>
<p>Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.</p>
<p>The terms &quot;above&quot; and &quot;below&quot; are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms &quot;greater&quot; and &quot;less&quot; are associated with the SF and OF flags and refer to the relationship between two signed integer values.</p>
<p>Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, EFLAGS Condition Codes, in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, shows the alternate mnemonics for various test conditions.</p>
<p>Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Condition <span class="operator">==</span> <span class="keyword">true</span><span class="operator">)</span> Destination <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
<span class="keyword">else</span> Destination <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>SFENCE</strong><br />Store Fence<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F AE /7</code></td>
<td class="grid"><code>SFENCE</code></td>
<td class="grid">Serializes store operations.</td>
</tr>
</table></td><td>
<p>Performs a serializing operation on all store-to-memory instructions that were issued prior the SFENCE instruction. This serializing operation guarantees that every store instruction that precedes in program order the SFENCE instruction is globally visible before any store instruction that follows the SFENCE instruction is globally visible. The SFENCE instruction is ordered with respect store instructions, other SFENCE instructions, any MFENCE instructions, and any serializing instructions (such as the CPUID instruction). It is not ordered with respect to load instructions or the LFENCE instruction.</p>
<p>Weakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue, write-combining, and write-collapsing. The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data. The SFENCE instruction provides a performance-efficient way of insuring store ordering between routines that produce weakly-ordered results and routines that consume this data.</p>
<br />
<pre>WaitOnStores<span class="operator">(</span>PrecedingStoresGloballyVisible<span class="operator">)</span><span class="operator">;</span> <span class="comment">//wait on following stores until the preceding stores are globally visible</span>
</pre>
</td><td></td></tr><tr><td><strong>SGDT</strong><br />Store Global Descriptor Table Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 01 /0</code></td>
<td class="grid"><code>SGDT m</code></td>
<td class="grid">Store GDTR to m.</td>
</tr>
</table></td><td>
<p>Stores the content of the global descriptor table register (GDTR) in the destination operand. The destination operand specifies a 6-byte memory location. If the operand-size attribute is 32 bits, the 16-bit limit field of the register is stored in the low 2 bytes of the memory location and the 32-bit base address is stored in the high 4 bytes. If the operand-size attribute is 16 bits, the limit is stored in the low 2 bytes and the 24-bit base address is stored in the third, fourth, and fifth byte, with the sixth byte filled with 0s.</p>
<p>SGDT is only useful in operating-system software; however, it can be used in application programs without causing an exception to be generated.</p>
<p>See &quot;LGDT/LIDT-Load Global/Interrupt Descriptor Table Register&quot; in Chapter 3 for information on loading the GDTR and IDTR.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> {
	Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> GDTR<span class="operator">.</span>Limit<span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">16..39</span><span class="operator">]</span> <span class="operator">=</span> GDTR<span class="operator">.</span>Base<span class="operator">;</span> <span class="comment">//24 bits of base address loaded</span>
	Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
}
<span class="keyword">else</span> { <span class="comment">//32-bit Operand Size</span>
	Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> GDTR<span class="operator">.</span>Limit<span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">16..47</span><span class="operator">]</span> <span class="operator">=</span> GDTR<span class="operator">.</span>Base<span class="operator">;</span> <span class="comment">//full 32-bit base address loaded</span>
}
</pre>
</td><td>
<p>The 16-bit form of the SGDT is compatible with the Intel 286 processor if the upper 8 bits are not referenced. The Intel 286 processor fills these bits with 1s; the Pentium 4, Intel Xeon, P6 family, Pentium, Intel486, and Intel386 processors fill these bits with 0s.
</p>
</td></tr><tr><td><strong>SHLD</strong><br />Double Precision Shift Left<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F A4</code></td>
<td class="grid"><code>SHLD r/m16, r16, imm8</code></td>
<td class="grid">Shift r/m16 to left imm8 places while shifting bits from r16 in from the right.</td>
</tr>
<tr>
<td class="grid"><code>0F A5</code></td>
<td class="grid"><code>SHLD r/m16, r16, CL</code></td>
<td class="grid">Shift r/m16 to left CL places while shifting bits from r16 in from the right.</td>
</tr>
<tr>
<td class="grid"><code>0F A4</code></td>
<td class="grid"><code>SHLD r/m32, r32, imm8</code></td>
<td class="grid">Shift r/m32 to left imm8 places while shifting bits from r32 in from the right.</td>
</tr>
<tr>
<td class="grid"><code>0F A5</code></td>
<td class="grid"><code>SHLD r/m32, r32, CL</code></td>
<td class="grid">Shift r/m32 to left CL places while shifting bits from r32 in from the right.</td>
</tr>
</table></td><td>
<p>Shifts the first operand (destination operand) to the left the number of bits specified by the third operand (count operand). The second operand (source operand) provides bits to shift in from the right (starting with bit 0 of the destination operand). The destination operand can be a register or a memory location; the source operand is a register. The count operand is an unsigned integer that can be an immediate byte or the contents of the CL register. Only bits 0 through 4 of the count are used, which masks the count to a value between 0 and 31. If the count is greater than the operand size, the result in the destination operand is undefined.</p>
<p>If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, the flags are not affected. </p>
<p>The SHLD instruction is useful for multi-precision shifts of 64 bits or more.</p>
<br />
<pre>Count <span class="operator">=</span> Count <span class="operator">%</span> <span class="number">32</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> OperandSize<span class="operator">)</span> { <span class="comment">//Bad parameters</span>
		Destination <span class="operator">=</span> Undefined<span class="operator">;</span>
		<span class="operator">(</span>CF<span class="operator">,</span> OF<span class="operator">,</span> SF<span class="operator">,</span> ZF<span class="operator">,</span> AF<span class="operator">,</span> PF<span class="operator">)</span> <span class="operator">=</span> Undefined<span class="operator">;</span>
	}
	<span class="keyword">else</span> { <span class="comment">//Perform the shift</span>
		<span class="comment">//Last bit shifted out on exit</span>
		<span class="keyword">for</span><span class="operator">(</span>i <span class="operator">=</span> OperandSize <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span> i <span class="operator">&gt;=</span> Count<span class="operator">;</span> <span class="operator">--</span>i<span class="operator">)</span> Destination<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span>i <span class="operator">-</span> Count<span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">for</span><span class="operator">(</span>i <span class="operator">=</span> Count <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span> i <span class="operator">&gt;=</span> <span class="number">0</span><span class="operator">;</span> <span class="operator">--</span>i<span class="operator">)</span> Destination<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span>i <span class="operator">-</span> Count <span class="operator">+</span> OperandSize<span class="operator">]</span><span class="operator">;</span>
	}
}
</pre>
</td><td>
<p>If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand and the SF, ZF, and PF flags are set according to the value of the result. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. For shifts greater than 1 bit, the OF flag is undefined. If a shift occurs, the AF flag is undefined. If the count operand is 0, the flags are not affected. If the count is greater than the operand size, the flags are undefined.
</p>
</td></tr><tr><td><strong>SHRD</strong><br />Double Precision Shift Right<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F AC</code></td>
<td class="grid"><code>SHRD r/m16, r16, imm8</code></td>
<td class="grid">Shift r/m16 to right imm8 places while shifting bits from r16 in from the left.</td>
</tr>
<tr>
<td class="grid"><code>0F AD</code></td>
<td class="grid"><code>SHRD r/m16, r16, CL</code></td>
<td class="grid">Shift r/m16 to right CL places while shifting bits from r16 in from the left.</td>
</tr>
<tr>
<td class="grid"><code>0F AC</code></td>
<td class="grid"><code>SHRD r/m32, r32, mm8</code></td>
<td class="grid">Shift r/m32 to right imm8 places while shifting bits from r32 in from the left.</td>
</tr>
<tr>
<td class="grid"><code>0F AD</code></td>
<td class="grid"><code>SHRD r/m32, r32, CL</code></td>
<td class="grid">Shift r/m32 to right CL places while shifting bits from r32 in from the left.</td>
</tr>
</table></td><td>
<p>Shifts the first operand (destination operand) to the right the number of bits specified by the third operand (count operand). The second operand (source operand) provides bits to shift in from the left (starting with the most significant bit of the destination operand). The destination operand can be a register or a memory location; the source operand is a register. The count operand is an unsigned integer that can be an immediate byte or the contents of the CL register. Only bits 0 through 4 of the count are used, which masks the count to a value between 0 and 31. If the count is greater than the operand size, the result in the destination operand is undefined.</p>
<p>If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, the flags are not affected. </p>
<p>The SHRD instruction is useful for multiprecision shifts of 64 bits or more.</p>
<br />
<pre>Count <span class="operator">=</span> Count <span class="operator">%</span> <span class="number">32</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> {
	<span class="keyword">if</span><span class="operator">(</span>Count <span class="operator">&gt;</span> OperandSize<span class="operator">)</span> { <span class="comment">//Bad parameters</span>
		Destination <span class="operator">=</span> Undefined<span class="operator">;</span>
		<span class="operator">(</span>CF<span class="operator">,</span> OF<span class="operator">,</span> SF<span class="operator">,</span> ZF<span class="operator">,</span> AF<span class="operator">,</span> PF<span class="operator">)</span> <span class="operator">=</span> Undefined<span class="operator">;</span>
	}
	<span class="keyword">else</span> { <span class="comment">//Perform the shift</span>
		<span class="keyword">for</span><span class="operator">(</span>i <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> i <span class="operator">&lt;=</span> OperandSize <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span> <span class="operator">++</span>i<span class="operator">)</span> Destination<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span>i <span class="operator">+</span> Count<span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">for</span><span class="operator">(</span>i <span class="operator">=</span> OperandSize <span class="operator">-</span> Count<span class="operator">;</span> i <span class="operator">&gt;=</span> OperandSize <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span> <span class="operator">--</span>i<span class="operator">)</span> Destination<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span>i <span class="operator">+</span> Count <span class="operator">-</span> OperandSize<span class="operator">]</span><span class="operator">;</span>
	}
}
</pre>
</td><td>
<p>If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand and the SF, ZF, and PF flags are set according to the value of the result. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. For shifts greater than 1 bit, the OF flag is undefined. If a shift occurs, the AF flag is undefined. If the count operand is 0, the flags are not affected. If the count is greater than the operand size, the flags are undefined.
</p>
</td></tr><tr><td><strong>SHUFPD</strong><br />Shuffle Packed Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F C6 /r ib</code></td>
<td class="grid"><code>SHUFPD xmm1, xmm2/m128, imm8</code></td>
<td class="grid">Shuffle packed double-precision floating-point values selected by imm8 from xmm1 and xmm1/m128 to xmm1.</td>
</tr>
</table></td><td>
<p>Moves either of the two packed double-precision floating-point values from destination operand (first operand) into the low quadword of the destination operand; moves either of the two packed double-precision floating-point values from the source operand into to the high quadword of the destination operand. The select operand (third operand) determines which values are moved to the destination operand.</p>
<p>The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The select operand is an 8-bit immediate: bit 0 selects which value is moved from the destination operand to the result (where 0 selects the low quadword and 1 selects the high quadword) and bit 1 selects which value is moved from the source operand to the result. Bits 2 through 7 of the select operand are reserved and must be set to 0.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Select<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Select<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="keyword">else</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>SHUFPS</strong><br />Shuffle Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F C6 /r ib</code></td>
<td class="grid"><code>SHUFPS xmm1, xmm2/m128, imm8</code></td>
<td class="grid">Shuffle packed single-precision floating-point values selected by imm8 from xmm1 and xmm1/m128 to xmm1.</td>
</tr>
</table></td><td>
<p>Moves two of the four packed single-precision floating-point values from the destination operand (first operand) into the low quadword of the destination operand; moves two of the four packed single-precision floating-point values from the source operand (second operand) into to the high quadword of the destination operand. The select operand (third operand) determines which values are moved to the destination operand.</p>
<p>The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The select operand is an 8-bit immediate: bits 0 and 1 select the value to be moved from the destination operand to the low doubleword of the result, bits 2 and 3 select the value to be moved from the destination operand to the second doubleword of the result, bits 4 and 5 select the value to be moved from the source operand to the third doubleword of the result, and bits 6 and 7 select the value to be moved from the source operand to the high doubleword of the result.</p>
<br />
<pre><span class="keyword">switch</span><span class="operator">(</span>Select<span class="operator">[</span><span class="number">0..1</span><span class="operator">]</span><span class="operator">)</span> {
	<span class="keyword">case</span> <span class="number">0</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">1</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">2</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">3</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
<span class="keyword">switch</span><span class="operator">(</span>Select<span class="operator">[</span><span class="number">2..3</span><span class="operator">]</span><span class="operator">)</span> {
	<span class="keyword">case</span> <span class="number">0</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">1</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">2</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">3</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
<span class="keyword">switch</span><span class="operator">(</span>Select<span class="operator">[</span><span class="number">4..5</span><span class="operator">]</span><span class="operator">)</span> {
	<span class="keyword">case</span> <span class="number">0</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">1</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">2</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">3</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
<span class="keyword">switch</span><span class="operator">(</span>Select<span class="operator">[</span><span class="number">6..7</span><span class="operator">]</span><span class="operator">)</span> {
	<span class="keyword">case</span> <span class="number">0</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">1</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">2</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> <span class="number">3</span><span class="operator">:</span>
		Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>SIDT</strong><br />Store Interrupt Descriptor Table Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 01 /1</code></td>
<td class="grid"><code>SIDT m</code></td>
<td class="grid">Store IDTR to m.</td>
</tr>
</table></td><td>
<p>Stores the content the interrupt descriptor table register (IDTR) in the destination operand. The destination operand specifies a 6-byte memory location. If the operand-size attribute is 32 bits, the 16-bit limit field of the register is stored in the low 2 bytes of the memory location and the 32-bit base address is stored in the high 4 bytes. If the operand-size attribute is 16 bits, the limit is stored in the low 2 bytes and the 24-bit base address is stored in the third, fourth, and fifth byte, with the sixth byte filled with 0s.</p>
<p>SIDT is only useful in operating-system software; however, it can be used in application programs without causing an exception to be generated.</p>
<p>See &quot;LGDT/LIDT-Load Global/Interrupt Descriptor Table Register&quot; in Chapter 4 for information on loading the GDTR and IDTR.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>OperandSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> {
	Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> IDTR<span class="operator">.</span>Limit<span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">16..39</span><span class="operator">]</span> <span class="operator">=</span> IDTR<span class="operator">.</span>Base<span class="operator">;</span> <span class="comment">//24 bits of base address loaded</span>
	Destination<span class="operator">[</span><span class="number">40..47</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
}
<span class="keyword">else</span> { <span class="comment">//32-bit Operand Size</span>
	Destination<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span> <span class="operator">=</span> IDTR<span class="operator">.</span>Limit<span class="operator">;</span>
	Destination<span class="operator">[</span><span class="number">16..47</span><span class="operator">]</span> <span class="operator">=</span> IDTR<span class="operator">.</span>Base<span class="operator">;</span> <span class="comment">//full 32-bit base address loaded *)</span>
}
</pre>
</td><td>
<p>The 16-bit form of SIDT is compatible with the Intel 286 processor if the upper 8 bits are not referenced. The Intel 286 processor fills these bits with 1s; the Pentium 4, Intel Xeon, P6 family, Pentium, Intel486, and Intel386 processors fill these bits with 0s.
</p>
</td></tr><tr><td><strong>SLDT</strong><br />Store Local Descriptor Table Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 00 /0</code></td>
<td class="grid"><code>SLDT r/m16</code></td>
<td class="grid">Store segment selector from LDTR in r/m16.</td>
</tr>
</table></td><td>
<p>Stores the segment selector from the local descriptor table register (LDTR) in the destination operand. The destination operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the segment descriptor (located in the GDT) for the current LDT. This instruction can only be executed in protected mode.</p>
<p>When the destination operand is a 32-bit register, the 16-bit segment selector is copied into the lower-order 16 bits of the register. The high-order 16 bits of the register are cleared for the Pentium 4, Intel Xeon, and P6 family processors and are undefined for Pentium, Intel486, and Intel386 processors. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of the operand size.</p>
<p>The SLDT instruction is only useful in operating-system software; however, it can be used in application programs.</p>
<br />
<pre>Destination <span class="operator">=</span> LDTR<span class="operator">.</span>SegmentSelector<span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>SMSW</strong><br />Store Machine Status Word<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 01 /4</code></td>
<td class="grid"><code>SMSW r/m16</code></td>
<td class="grid">Store machine status word to r/m16.</td>
</tr>
<tr>
<td class="grid"><code>0F 01 /4</code></td>
<td class="grid"><code>SMSW r32/m16</code></td>
<td class="grid">Store machine status word in low-order 16 bits of r32/m16; high-order 16 bits of r32 are undefined.</td>
</tr>
</table></td><td>
<p>Stores the machine status word (bits 0 through 15 of control register CR0) into the destination operand. The destination operand can be a 16-bit general-purpose register or a memory location.</p>
<p>When the destination operand is a 32-bit register, the low-order 16 bits of register CR0 are copied into the low-order 16 bits of the register and the upper 16 bits of the register are undefined.</p>
<p>When the destination operand is a memory location, the low-order 16 bits of register CR0 are written to memory as a 16-bit quantity, regardless of the operand size.</p>
<p>The SMSW instruction is only useful in operating-system software; however, it is not a privileged instruction and can be used in application programs.</p>
<p>This instruction is provided for compatibility with the Intel 286 processor. Programs and procedures intended to run on the Pentium 4, Intel Xeon, P6 family, Pentium, Intel486, and Intel386 processors should use the MOV (control registers) instruction to load the machine status word.</p>
<br />
<pre>Destination <span class="operator">=</span> CR0<span class="operator">[</span><span class="number">0..15</span><span class="operator">]</span><span class="operator">;</span> <span class="comment">//Machine status word</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>SQRTPD</strong><br />Compute Square Roots of Packed Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 51 /r</code></td>
<td class="grid"><code>SQRTPD xmm1, xmm2/m128</code></td>
<td class="grid">Compute the square root of the packed doubleprecision floating-point values in xmm2/m128 and store the results in xmm1.</td>
</tr>
</table></td><td>
<p>Performs an SIMD computation of the square roots of the two packed double-precision floatingpoint values in the source operand (second operand) stores the packed double-precision floatingpoint results in the destination operand. The source operand can be an XMM register or a 128- bit memory location. The destination operand is an XMM register. See Figure 11-3 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD double-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> SquareRoot<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> SquareRoot<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>SQRTPS</strong><br />Compute Square Roots of Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 51 /r</code></td>
<td class="grid"><code>SQRTPS xmm1, xmm2/m128</code></td>
<td class="grid">Compute the square root of the packed single-precision floating-point values in xmm2/m128 and store the results in xmm1.</td>
</tr>
</table></td><td>
<p>Performs an SIMD computation of the square roots of the four packed single-precision floatingpoint values in the source operand (second operand) stores the packed single-precision floatingpoint results in the destination operand. The source operand can be an XMM register or a 128- bit memory location. The destination operand is an XMM register. See Figure 10-5 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD single-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> SquareRoot<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> SquareRoot<span class="operator">(</span>Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> SquareRoot<span class="operator">(</span>Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> SquareRoot<span class="operator">(</span>Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>SQRTSD</strong><br />Compute Square Root of Scalar Double-Precision Floating-Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 51 /r</code></td>
<td class="grid"><code>SQRTSD xmm1, xmm2/m64</code></td>
<td class="grid">Compute the square root of the low double-precision floating-point value in xmm2/m64 and store the results in xmm1.</td>
</tr>
</table></td><td>
<p>Computes the square root of the low double-precision floating-point value in the source operand (second operand) and stores the double-precision floating-point result in the destination operand. The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. The high quadword of the destination operand remains unchanged. See Figure 11-4 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of a scalar double-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> SquareRoot<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
<span class="comment">//Destination[64..127] remains unchanged</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>SQRTSS</strong><br />Compute Square Root of Scalar Single-Precision Floating-Point Value<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 51 /r</code></td>
<td class="grid"><code>SQRTSS xmm1, xmm2/m32</code></td>
<td class="grid">Compute the square root of the low single-precision floating-point value in xmm2/m32 and store the results in xmm1.</td>
</tr>
</table></td><td>
<p>Computes the square root of the low single-precision floating-point value in the source operand (second operand) and stores the single-precision floating-point result in the destination operand.</p>
<p>The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of a scalar single-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> SquareRoot<span class="operator">(</span>Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
<span class="comment">//Destination[64..127] remains unchanged</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>STC</strong><br />Set Carry Flag<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F9</code></td>
<td class="grid"><code>STC</code></td>
<td class="grid">Set CF flag.</td>
</tr>
</table></td><td>
<p>Sets the CF flag in the EFLAGS register.</p>
<br />
<pre>CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</pre>
</td><td>
<p>The CF flag is set. The OF, ZF, SF, AF, and PF flags are unaffected.
</p>
</td></tr><tr><td><strong>STD</strong><br />Set Direction Flag<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>FD</code></td>
<td class="grid"><code>STD</code></td>
<td class="grid">Set DF flag.</td>
</tr>
</table></td><td>
<p>Sets the DF flag in the EFLAGS register. When the DF flag is set to 1, string operations decrement the index registers (ESI and/or EDI).</p>
<br />
<pre>DF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</pre>
</td><td>
<p>The DF flag is set. The CF, OF, ZF, SF, AF, and PF flags are unaffected.
</p>
</td></tr><tr><td><strong>STI</strong><br />Set Interrupt Flag<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>FB</code></td>
<td class="grid"><code>STI</code></td>
<td class="grid">Set interrupt flag; external, maskable interrupts enabled at the end of the next instruction.</td>
</tr>
</table></td><td>
<p>If protected-mode virtual interrupts are not enabled, STI sets the interrupt flag (IF) in the EFLAGS register. After the IF flag is set, the processor begins responding to external, maskable interrupts after the next instruction is executed. The delayed effect of this instruction is provided to allow interrupts to be enabled just before returning from a procedure (or subroutine). For instance, if an STI instruction is followed by an RET instruction, the RET instruction is allowed to execute before external interrupts are recognized.</p>
<p>Note that in a sequence of instructions that individually delay interrupts past the following instruction, only the first instruction in the sequence is guaranteed to delay the interrupt, but subsequent interrupt-delaying instructions may not delay the interrupt. Thus, in the following instruction sequence:</p>
<pre>STI
MOV SS, AX
MOV ESP, EBP
</pre>
<p>Interrupts may be recognized before MOV ESP, EBP executes, even though MOV SS, AX normally delays interrupts for one instruction.</p>
<p>If the STI instruction is followed by a CLI instruction (which clears the IF flag), the effect of the STI instruction is negated.</p>
<p>The IF flag and the STI and CLI instructions do not prohibit the generation of exceptions and NMI interrupts. NMI interrupts may be blocked for one macroinstruction following an STI.</p>
<p>When protected-mode virtual interrupts are enabled, CPL is 3, and IOPL is less than 3; STI sets the VIF flag in the EFLAGS register, leaving IF unaffected.</p>
<p>The following table indicates the action of the STI instruction depending on the processor's mode of operation and the CPL/IOPL settings of the running program or procedure.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>PE <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> IF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//Executing in real-address mode; Set Interrupt Flag</span>
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>VM <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> { <span class="comment">//Executing in protected mode</span>
	<span class="keyword">if</span><span class="operator">(</span>IOPL <span class="operator">&gt;=</span> CPL<span class="operator">)</span> IF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//Set Interrupt Flag</span>
	<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>IOPL <span class="operator">&lt;</span> CPL <span class="operator">&amp;&amp;</span> CPL <span class="operator">==</span> <span class="number">3</span> <span class="operator">&amp;&amp;</span> VIP <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> VIF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//Set Virtual Interrupt Flag</span>
	<span class="keyword">else</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
}
<span class="keyword">else</span> { <span class="comment">//Executing in Virtual-8086 mode</span>
	<span class="keyword">if</span><span class="operator">(</span>IOPL <span class="operator">==</span> <span class="number">3</span><span class="operator">)</span> IF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//Set Interrupt Flag</span>
	<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>IOPL <span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&amp;&amp;</span> VIP <span class="operator">==</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> VME <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> VIF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//Set Virtual Interrupt Flag</span>
	<span class="keyword">else</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span> <span class="comment">//Trap to virtual-8086 monitor</span>
}
</pre>
</td><td>
<p>The IF flag is set to 1; or the VIF flag is set to 1.
</p>
</td></tr><tr><td><strong>STMXCSR</strong><br />Store MXCSR Register State<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F AE /3</code></td>
<td class="grid"><code>STMXCSR m32</code></td>
<td class="grid">Store contents of MXCSR register to m32.</td>
</tr>
</table></td><td>
<p>Stores the contents of the MXCSR control and status register to the destination operand. The destination operand is a 32-bit memory location. The reserved bits in the MXCSR register are stored as 0s.</p>
<br />
<pre>m32 <span class="operator">=</span> MXCSR<span class="operator">;</span>
</pre>
</td><td></td></tr><tr><td><strong>STOS/STOSB/STOSW/STOSD</strong><br />Store String<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>AA</code></td>
<td class="grid"><code>STOS m8</code></td>
<td class="grid">Store AL at address ES:(E)DI.</td>
</tr>
<tr>
<td class="grid"><code>AB</code></td>
<td class="grid"><code>STOS m16</code></td>
<td class="grid">Store AX at address ES:(E)DI.</td>
</tr>
<tr>
<td class="grid"><code>AB</code></td>
<td class="grid"><code>STOS m32</code></td>
<td class="grid">Store EAX at address ES:(E)DI.</td>
</tr>
<tr>
<td class="grid"><code>AA</code></td>
<td class="grid"><code>STOSB</code></td>
<td class="grid">Store AL at address ES:(E)DI.</td>
</tr>
<tr>
<td class="grid"><code>AB</code></td>
<td class="grid"><code>STOSW</code></td>
<td class="grid">Store AX at address ES:(E)DI.</td>
</tr>
<tr>
<td class="grid"><code>AB</code></td>
<td class="grid"><code>STOSD</code></td>
<td class="grid">Store EAX at address ES:(E)DI.</td>
</tr>
</table></td><td>
<p>Stores a byte, word, or doubleword from the AL, AX, or EAX register, respectively, into the destination operand. The destination operand is a memory location, the address of which is read from either the ES:EDI or the ES:DI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The ES segment cannot be overridden with a segment override prefix.</p>
<p>At the assembly-code level, two forms of this instruction are allowed: the &quot;explicit-operands&quot; form and the &quot;no-operands&quot; form. The explicit-operands form (specified with the STOS mnemonic) allows the destination operand to be specified explicitly. Here, the destination operand should be a symbol that indicates the size and location of the destination value. The source operand is then automatically selected to match the size of the destination operand (the AL register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers, which must be loaded correctly before the store string instruction is executed.</p>
<p>The no-operands form provides &quot;short forms&quot; of the byte, word, and doubleword versions of the STOS instructions. Here also ES:(E)DI is assumed to be the destination operand and the AL, AX, or EAX register is assumed to be the source operand. The size of the destination and source operands is selected with the mnemonic: STOSB (byte read from register AL), STOSW (word from AX), or STOSD (doubleword from EAX).</p>
<p>After the byte, word, or doubleword is transferred from the AL, AX, or EAX register to the memory location, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.</p>
<p>The STOS, STOSB, STOSW, and STOSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because data needs to be moved into the AL, AX, or EAX register before it can be stored. See &quot;REP/REPE/REPZ/REPNE /REPNZ-Repeat String {operation} Prefix&quot; in this chapter for a description of the REP prefix.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>IsByteOperation<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	Destination <span class="operator">=</span> AL<span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>
	}
}
<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span>IsWordOperation<span class="operator">(</span><span class="operator">)</span><span class="operator">)</span> {
	Destination <span class="operator">=</span> AX<span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">2</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">2</span><span class="operator">;</span>
	}
}
<span class="keyword">else</span> { <span class="comment">//doubleword comparison</span>
	Destination <span class="operator">=</span> EAX<span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>DF <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">+</span> <span class="number">4</span><span class="operator">;</span>
	}
	<span class="keyword">else</span> {
		<span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>SI <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
		<span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">=</span> <span class="operator">(</span>E<span class="operator">)</span>DI <span class="operator">-</span> <span class="number">4</span><span class="operator">;</span>
	}
}
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>STR</strong><br />Store Task Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 00 /1</code></td>
<td class="grid"><code>STR r/m16</code></td>
<td class="grid">Stores segment selector from TR in r/m16.</td>
</tr>
</table></td><td>
<p>Stores the segment selector from the task register (TR) in the destination operand. The destination operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the task state segment (TSS) for the currently running task.</p>
<p>When the destination operand is a 32-bit register, the 16-bit segment selector is copied into the lower 16 bits of the register and the upper 16 bits of the register are cleared. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of operand size.</p>
<p>The STR instruction is useful only in operating-system software. It can only be executed in protected mode.</p>
<br />
<pre>Destination <span class="operator">=</span> TR<span class="operator">.</span>SegmentSelector<span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>SUB</strong><br />Subtract<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>2C ib</code></td>
<td class="grid"><code>SUB AL,imm8</code></td>
<td class="grid">Subtract imm8 from AL.</td>
</tr>
<tr>
<td class="grid"><code>2D iw</code></td>
<td class="grid"><code>SUB AX,imm16</code></td>
<td class="grid">Subtract imm16 from AX.</td>
</tr>
<tr>
<td class="grid"><code>2D id</code></td>
<td class="grid"><code>SUB EAX,imm32</code></td>
<td class="grid">Subtract imm32 from EAX.</td>
</tr>
<tr>
<td class="grid"><code>80 /5 ib</code></td>
<td class="grid"><code>SUB r/m8,imm8</code></td>
<td class="grid">Subtract imm8 from r/m8.</td>
</tr>
<tr>
<td class="grid"><code>81 /5 iw</code></td>
<td class="grid"><code>SUB r/m16,imm16</code></td>
<td class="grid">Subtract imm16 from r/m16.</td>
</tr>
<tr>
<td class="grid"><code>81 /5 id</code></td>
<td class="grid"><code>SUB r/m32,imm32</code></td>
<td class="grid">Subtract imm32 from r/m32.</td>
</tr>
<tr>
<td class="grid"><code>83 /5 ib</code></td>
<td class="grid"><code>SUB r/m16,imm8</code></td>
<td class="grid">Subtract sign-extended imm8 from r/m16.</td>
</tr>
<tr>
<td class="grid"><code>83 /5 ib</code></td>
<td class="grid"><code>SUB r/m32,imm8</code></td>
<td class="grid">Subtract sign-extended imm8 from r/m32.</td>
</tr>
<tr>
<td class="grid"><code>28 /r</code></td>
<td class="grid"><code>SUB r/m8,r8</code></td>
<td class="grid">Subtract r8 from r/m8.</td>
</tr>
<tr>
<td class="grid"><code>29 /r</code></td>
<td class="grid"><code>SUB r/m16,r16</code></td>
<td class="grid">Subtract r16 from r/m16.</td>
</tr>
<tr>
<td class="grid"><code>29 /r</code></td>
<td class="grid"><code>SUB r/m32,r32</code></td>
<td class="grid">Subtract r32 from r/m32.</td>
</tr>
<tr>
<td class="grid"><code>2A /r</code></td>
<td class="grid"><code>SUB r8,r/m8</code></td>
<td class="grid">Subtract r/m8 from r8.</td>
</tr>
<tr>
<td class="grid"><code>2B /r</code></td>
<td class="grid"><code>SUB r16,r/m16</code></td>
<td class="grid">Subtract r/m16 from r16.</td>
</tr>
<tr>
<td class="grid"><code>2B /r</code></td>
<td class="grid"><code>SUB r32,r/m32</code></td>
<td class="grid">Subtract r/m32 from r32.</td>
</tr>
</table></td><td>
<p>Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, register, or memory location.</p>
<p>(However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</p>
<p>The SUB instruction performs integer subtraction. It evaluates the result for both signed and unsigned integer operands and sets the OF and CF flags to indicate an overflow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.</p>
<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<br />
<pre>Destination <span class="operator">=</span> Destination <span class="operator">-</span> Source<span class="operator">;</span>
</pre>
</td><td>
<p>The OF, SF, ZF, AF, PF, and CF flags are set according to the result.
</p>
</td></tr><tr><td><strong>SUBPD</strong><br />Subtract Packed Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 5C /r</code></td>
<td class="grid"><code>SUBPD xmm1, xmm2/m128 Subtract packed double-precision floating-point values in xmm2/m128 from xmm1.</code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Performs an SIMD subtract of the two packed double-precision floating-point values in the source operand (second operand) from the two packed double-precision floating-point values in the destination operand (first operand), and stores the packed double-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 11-3 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD double-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>SUBPS</strong><br />Subtract Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 5C /r</code></td>
<td class="grid"><code>SUBPS xmm1 xmm2/m128</code></td>
<td class="grid">Subtract packed single-precision floating-point values in xmm2/mem from xmm1.</td>
</tr>
</table></td><td>
<p>Performs an SIMD subtract of the four packed single-precision floating-point values in the source operand (second operand) from the four packed single-precision floating-point values in the destination operand (first operand), and stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of an SIMD double-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>SUBSD</strong><br />Subtract Scalar Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F2 0F 5C /r</code></td>
<td class="grid"><code>SUBSD xmm1, xmm2/m64</code></td>
<td class="grid">Subtract the low double-precision floating-point value in xmm2/mem64 from xmm1.</td>
</tr>
</table></td><td>
<p>Subtracts the low double-precision floating-point value in the source operand (second operand) from the low double-precision floating-point value in the destination operand (first operand), and stores the double-precision floating-point result in the destination operand. The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. The high quadword of the destination operand remains unchanged. See Figure 11-4 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of a scalar double-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[64..127] remains unchanged</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>SUBSS</strong><br />Subtract Scalar Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>F3 0F 5C /r</code></td>
<td class="grid"><code>SUBSS xmm1, xmm2/m32</code></td>
<td class="grid">Subtract the lower single-precision floating-point values in xmm2/m32 from xmm1.</td>
</tr>
</table></td><td>
<p>Subtracts the low single-precision floating-point value in the source operand (second operand) from the low single-precision floating-point value in the destination operand (first operand), and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1 for an illustration of a scalar single-precision floating-point operation.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">-</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
<span class="comment">//Destination[96..127] remains unchanged</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>SYSENTER</strong><br />Fast System Call<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 34</code></td>
<td class="grid"><code>SYSENTER</code></td>
<td class="grid">Fast call to privilege level 0 system procedures.</td>
</tr>
</table></td><td>
<p>Executes a fast call to a level 0 system procedure or routine. This instruction is a companion instruction to the SYSEXIT instruction. The SYSENTER instruction is optimized to provide the maximum performance for system calls from user code running at privilege level 3 to operating system or executive procedures running at privilege level 0.</p>
<p>Prior to executing the SYSENTER instruction, software must specify the privilege level 0 code segment and code entry point, and the privilege level 0 stack segment and stack pointer by writing values into the following MSRs:</p>
<ul>
<li>SYSENTER_CS_MSR-Contains the 32-bit segment selector for the privilege level 0 code segment. (This value is also used to compute the segment selector of the privilege level 0 stack segment.)</li>
<li>SYSENTER_EIP_MSR-Contains the 32-bit offset into the privilege level 0 code segment to the first instruction of the selected operating procedure or routine.</li>
<li>SYSENTER_ESP_MSR-Contains the 32-bit stack pointer for the privilege level 0 stack.</li>
</ul>
<p>These MSRs can be read from and written to using the RDMSR and WRMSR instructions. The register addresses are listed in Table 4-3. These addresses are defined to remain fixed for future IA-32 processors.</p>
<div>
<table class="grid">
<caption>MSRs Used By the SYSENTER and SYSEXIT Instructions</caption>
<tr><th>MSR</th><th>Address</th></tr>
<tr><td>SYSENTER_CS_MSR</td><td>174H</td></tr>
<tr><td>SYSENTER_ESP_MSR</td><td>175H</td></tr>
<tr><td>SYSENTER_EIP_MSR</td><td>176H</td></tr>
</table>
</div>
<p>When the SYSENTER instruction is executed, the processor does the following:</p>
<ul>
<li>Loads the segment selector from the SYSENTER_CS_MSR into the CS register.</li>
<li>Loads the instruction pointer from the SYSENTER_EIP_MSR into the EIP register.</li>
<li>Adds 8 to the value in SYSENTER_CS_MSR and loads it into the SS register.</li>
<li>Loads the stack pointer from the SYSENTER_ESP_MSR into the ESP register.</li>
<li>Switches to privilege level 0.</li>
<li>Clears the VM flag in the EFLAGS register, if the flag is set.</li>
<li>Begins executing the selected system procedure.</li>
</ul>
<p>The processor does not save a return IP or other state information for the calling procedure.</p>
<p>The SYSENTER instruction always transfers program control to a protected-mode code segment with a DPL of 0. The instruction requires that the following conditions are met by the operating system:</p>
<ul>
<li>The segment descriptor for the selected system code segment selects a flat, 32-bit code segment of up to 4 GBytes, with execute, read, accessed, and non-conforming permissions.</li>
<li>The segment descriptor for selected system stack segment selects a flat 32-bit stack segment of up to 4 GBytes, with read, write, accessed, and expand-up permissions.</li>
</ul>
<p>The SYSENTER can be invoked from all operating modes except real-address mode.</p>
<p>The SYSENTER and SYSEXIT instructions are companion instructions, but they do not constitute a call/return pair. When executing a SYSENTER instruction, the processor does not save state information for the user code, and neither the SYSENTER nor the SYSEXIT instruction supports passing parameters on the stack.</p>
<p>To use the SYSENTER and SYSEXIT instructions as companion instructions for transitions between privilege level 3 code and privilege level 0 operating system procedures, the following conventions must be followed:</p>
<ul>
<li>The segment descriptors for the privilege level 0 code and stack segments and for the privilege level 3 code and stack segments must be contiguous in the global descriptor table. This convention allows the processor to compute the segment selectors from the value entered in the SYSENTER_CS_MSR MSR.</li>
<li>The fast system call &quot;stub&quot; routines executed by user code (typically in shared libraries or DLLs) must save the required return IP and processor state information if a return to the calling procedure is required. Likewise, the operating system or executive procedures called with SYSENTER instructions must have access to and use this saved return and state information when returning to the user code.</li>
</ul>
<p>The SYSENTER and SYSEXIT instructions were introduced into the IA-32 architecture in the Pentium II processor. The availability of these instructions on a processor is indicated with the SYSENTER/SYSEXIT present (SEP) feature flag returned to the EDX register by the CPUID instruction. An operating system that qualifies the SEP flag must also qualify the processor family and model to ensure that the SYSENTER/SYSEXIT instructions are actually present.</p>
<p>For example:</p>
<pre>IF (CPUID SEP bit is set)
THEN IF (Family = 6) AND (Model &lt; 3) AND (Stepping &lt; 3)
THEN SYSENTER/SYSEXIT_Not_Supported
FI;
ELSE SYSENTER/SYSEXIT_Supported
FI;
</pre>
<p>When the CPUID instruction is executed on the Pentium Pro processor (model 1), the processor returns a the SEP flag as set, but does not support the SYSENTER/SYSEXIT instructions.</p>
<br />SYSENTER_CS_MSR</td><td>
<pre><span class="keyword">if</span><span class="operator">(</span>CR0<span class="operator">.</span>PE <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>SYSENTER_CS_MSR <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
EFLAGS<span class="operator">.</span>VM <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//Insures protected mode execution</span>
EFLAGS<span class="operator">.</span>IF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//Mask interrupts</span>
EFLAGS<span class="operator">.</span>RF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
CS<span class="operator">.</span>SEL <span class="operator">=</span> SYSENTER_CS_MSR<span class="operator">;</span> <span class="comment">//Operating system provides CS</span>
<span class="comment">//Set rest of CS to a fixed value</span>
CS<span class="operator">.</span>SEL<span class="operator">.</span>CPL <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
CS<span class="operator">.</span>BASE <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="operator">(</span><span class="operator">*</span> Flat segment <span class="operator">*</span><span class="operator">)</span>
CS<span class="operator">.</span>LIMIT <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span> <span class="comment">//4 GByte limit</span>
CS<span class="operator">.</span>ARbyte<span class="operator">.</span>G <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//4 KByte granularity</span>
CS<span class="operator">.</span>ARbyte<span class="operator">.</span>S <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
CS<span class="operator">.</span>ARbyte<span class="operator">.</span>TYPE <span class="operator">=</span> <span class="number">0xB</span><span class="operator">;</span> <span class="comment">//Execute + Read, Accessed</span>
CS<span class="operator">.</span>ARbyte<span class="operator">.</span>D <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//32-bit code segment</span>
CS<span class="operator">.</span>ARbyte<span class="operator">.</span>DPL <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
CS<span class="operator">.</span>ARbyte<span class="operator">.</span>RPL <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
CS<span class="operator">.</span>ARbyte<span class="operator">.</span>P <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
SS<span class="operator">.</span>SEL <span class="operator">=</span> CS<span class="operator">.</span>SEL <span class="operator">+</span> <span class="number">8</span><span class="operator">;</span>
<span class="comment">//Set rest of SS to a fixed value</span>
SS<span class="operator">.</span>BASE <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//Flat segment</span>
SS<span class="operator">.</span>LIMIT <span class="operator">=</span> FFFFH<span class="operator">;</span> <span class="comment">//4 GByte limit</span>
SS<span class="operator">.</span>ARbyte<span class="operator">.</span>G <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//4 KByte granularity</span>
SS<span class="operator">.</span>ARbyte<span class="operator">.</span>S <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
SS<span class="operator">.</span>ARbyte<span class="operator">.</span>TYPE <span class="operator">=</span> <span class="number">3</span><span class="operator">;</span> <span class="comment">//Read/Write, Accessed</span>
SS<span class="operator">.</span>ARbyte<span class="operator">.</span>D <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//32-bit stack segment</span>
SS<span class="operator">.</span>ARbyte<span class="operator">.</span>DPL <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
SS<span class="operator">.</span>ARbyte<span class="operator">.</span>RPL <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
SS<span class="operator">.</span>ARbyte<span class="operator">.</span>P <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
ESP <span class="operator">=</span> SYSENTER_ESP_MSR<span class="operator">;</span>
EIP <span class="operator">=</span> SYSENTER_EIP_MSR<span class="operator">;</span>
</pre>
</td></tr><tr><td><strong>SYSEXIT</strong><br />Fast Return from Fast System Call<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 35</code></td>
<td class="grid"><code>SYSEXIT Fast return to privilege level 3 user code.</code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Executes a fast return to privilege level 3 user code. This instruction is a companion instruction to the SYSENTER instruction. The SYSEXIT instruction is optimized to provide the maximum performance for returns from system procedures executing at protections levels 0 to user procedures executing at protection level 3. This instruction must be executed from code executing at privilege level 0.</p>
<p>Prior to executing the SYSEXIT instruction, software must specify the privilege level 3 code segment and code entry point, and the privilege level 3 stack segment and stack pointer by writing values into the following MSR and general-purpose registers:</p>
<dl>
<dt>SYSENTER_CS_MSR</dt>
<dd>Contains the 32-bit segment selector for the privilege level 0 code segment in which the processor is currently executing. (This value is used to compute the segment selectors for the privilege level 3 code and stack segments.)</dd>
<dt>EDX</dt>
<dd>Contains the 32-bit offset into the privilege level 3 code segment to the first instruction to be executed in the user code.</dd>
<dt>ECX</dt>
<dd>Contains the 32-bit stack pointer for the privilege level 3 stack.</dd>
</dl>
<p>The SYSENTER_CS_MSR MSR can be read from and written to using the RDMSR and WRMSR instructions. The register address is listed in Table 4-3. This address is defined to remain fixed for future IA-32 processors.</p>
<p>When the SYSEXIT instruction is executed, the processor does the following:</p>
<ul>
<li>Adds 16 to the value in SYSENTER_CS_MSR and loads the sum into the CS selector register.</li>
<li>Loads the instruction pointer from the EDX register into the EIP register.</li>
<li>Adds 24 to the value in SYSENTER_CS_MSR and loads the sum into the SS selector register.</li>
<li>Loads the stack pointer from the ECX register into the ESP register.</li>
<li>Switches to privilege level 3.</li>
<li>Begins executing the user code at the EIP address.</li>
</ul>
<p>See &quot;SYSENTER-Fast System Call&quot; for information about using the SYSENTER and SYSEXIT instructions as companion call and return instructions.</p>
<p>The SYSEXIT instruction always transfers program control to a protected-mode code segment with a DPL of 3. The instruction requires that the following conditions are met by the operating system:</p>
<ul>
<li>The segment descriptor for the selected user code segment selects a flat, 32-bit code segment of up to 4 GBytes, with execute, read, accessed, and non-conforming permissions.</li>
<li>The segment descriptor for selected user stack segment selects a flat, 32-bit stack segment of up to 4 GBytes, with expand-up, read, write, and accessed permissions.</li>
</ul>
<p>The SYSENTER can be invoked from all operating modes except real-address mode.</p>
<p>The SYSENTER and SYSEXIT instructions were introduced into the IA-32 architecture in the Pentium II processor. The availability of these instructions on a processor is indicated with the SYSENTER/SYSEXIT present (SEP) feature flag returned to the EDX register by the CPUID instruction. An operating system that qualifies the SEP flag must also qualify the processor family and model to ensure that the SYSENTER/SYSEXIT instructions are actually present.</p>
<p>For example:</p>
<p>IF (CPUID SEP bit is set) THEN IF (Family = 6) AND (Model &lt; 3) AND (Stepping &lt; 3) THEN SYSENTER/SYSEXIT_Not_Supported FI; ELSE SYSENTER/SYSEXIT_Supported FI; When the CPUID instruction is executed on the Pentium Pro processor (model 1), the processor returns a the SEP flag as set, but does not support the SYSENTER/SYSEXIT instructions.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>SYSENTER_CS_MSR <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>CR0<span class="operator">.</span>PE <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>CPL <span class="operator">!=</span> <span class="number">0</span><span class="operator">)</span> Exception<span class="operator">(</span>GP<span class="operator">(</span><span class="number">0</span><span class="operator">)</span><span class="operator">)</span><span class="operator">;</span>
CS<span class="operator">.</span>SEL <span class="operator">=</span> SYSENTER_CS_MSR <span class="operator">+</span> <span class="number">16</span><span class="operator">;</span> <span class="comment">//Segment selector for return CS</span>
<span class="comment">//Set rest of CS to a fixed value</span>
CS<span class="operator">.</span>BASE <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//Flat segment</span>
CS<span class="operator">.</span>LIMIT <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span> <span class="comment">//4 GByte limit</span>
CS<span class="operator">.</span>ARbyte<span class="operator">.</span>G <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//4 KByte granularity</span>
CS<span class="operator">.</span>ARbyte<span class="operator">.</span>S <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
CS<span class="operator">.</span>ARbyte<span class="operator">.</span>TYPE <span class="operator">=</span> <span class="number">0xB</span><span class="operator">;</span> <span class="comment">//Execute, Read, Non-Conforming Code</span>
CS<span class="operator">.</span>ARbyte<span class="operator">.</span>D <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//32-bit code segment</span>
CS<span class="operator">.</span>ARbyte<span class="operator">.</span>DPL <span class="operator">=</span> <span class="number">3</span><span class="operator">;</span>
CS<span class="operator">.</span>ARbyte<span class="operator">.</span>RPL <span class="operator">=</span> <span class="number">3</span><span class="operator">;</span>
CS<span class="operator">.</span>ARbyte<span class="operator">.</span>P <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
SS<span class="operator">.</span>SEL <span class="operator">=</span> SYSENTER_CS_MSR <span class="operator">+</span> <span class="number">24</span><span class="operator">;</span> <span class="comment">//Segment selector for return SS</span>
<span class="comment">//Set rest of SS to a fixed value</span>
SS<span class="operator">.</span>BASE <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="comment">//Flat segment</span>
SS<span class="operator">.</span>LIMIT <span class="operator">=</span> <span class="number">0xFFFF</span><span class="operator">;</span> <span class="comment">//4 GByte limit</span>
SS<span class="operator">.</span>ARbyte<span class="operator">.</span>G <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//4 KByte granularity</span>
SS<span class="operator">.</span>ARbyte<span class="operator">.</span>S <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
SS<span class="operator">.</span>ARbyte<span class="operator">.</span>TYPE <span class="operator">=</span> <span class="number">3</span><span class="operator">;</span> <span class="comment">//Expand Up, Read/Write, Data</span>
SS<span class="operator">.</span>ARbyte<span class="operator">.</span>D <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="comment">//32-bit stack segment</span>
SS<span class="operator">.</span>ARbyte<span class="operator">.</span>DPL <span class="operator">=</span> <span class="number">3</span><span class="operator">;</span>
SS<span class="operator">.</span>ARbyte<span class="operator">.</span>RPL <span class="operator">=</span> <span class="number">3</span><span class="operator">;</span>
SS<span class="operator">.</span>ARbyte<span class="operator">.</span>P <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
ESP <span class="operator">=</span> ECX<span class="operator">;</span>
EIP <span class="operator">=</span> EDX<span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>TEST</strong><br />Logical Compare<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>A8 ib</code></td>
<td class="grid"><code>TEST AL,imm8</code></td>
<td class="grid">AND imm8 with AL; set SF, ZF, PF according to result.</td>
</tr>
<tr>
<td class="grid"><code>A9 iw</code></td>
<td class="grid"><code>TEST AX,imm16</code></td>
<td class="grid">AND imm16 with AX; set SF, ZF, PF according to result.</td>
</tr>
<tr>
<td class="grid"><code>A9 id</code></td>
<td class="grid"><code>TEST EAX,imm32</code></td>
<td class="grid">AND imm32 with EAX; set SF, ZF, PF according to result.</td>
</tr>
<tr>
<td class="grid"><code>F6 /0 ib</code></td>
<td class="grid"><code>TEST r/m8,imm8</code></td>
<td class="grid">AND imm8 with r/m8; set SF, ZF, PF according to result.</td>
</tr>
<tr>
<td class="grid"><code>F7 /0 iw</code></td>
<td class="grid"><code>TEST r/m16,imm16</code></td>
<td class="grid">AND imm16 with r/m16; set SF, ZF, PF according to result.</td>
</tr>
<tr>
<td class="grid"><code>F7 /0 id</code></td>
<td class="grid"><code>TEST r/m32,imm32</code></td>
<td class="grid">AND imm32 with r/m32; set SF, ZF, PF according to result.</td>
</tr>
<tr>
<td class="grid"><code>84 /r</code></td>
<td class="grid"><code>TEST r/m8,r8</code></td>
<td class="grid">AND r8 with r/m8; set SF, ZF, PF according to result.</td>
</tr>
<tr>
<td class="grid"><code>85 /r</code></td>
<td class="grid"><code>TEST r/m16,r16</code></td>
<td class="grid">AND r16 with r/m16; set SF, ZF, PF according to result.</td>
</tr>
<tr>
<td class="grid"><code>85 /r</code></td>
<td class="grid"><code>TEST r/m32,r32</code></td>
<td class="grid">AND r32 with r/m32; set SF, ZF, PF according to result.</td>
</tr>
</table></td><td>
<p>Computes the bit-wise logical AND of first operand (source 1 operand) and the second operand (source 2 operand) and sets the SF, ZF, and PF status flags according to the result. The result is then discarded.</p>
<br />
<pre>Temporary <span class="operator">=</span> Source1 <span class="operator">&amp;</span> Source2<span class="operator">;</span>
SF <span class="operator">=</span> MSB<span class="operator">(</span>Temporary<span class="operator">)</span><span class="operator">;</span>
<span class="keyword">if</span><span class="operator">(</span>Temporary <span class="operator">=</span> <span class="number">0</span><span class="operator">)</span> ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
<span class="keyword">else</span> ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
PF <span class="operator">=</span> BitwiseXNOR<span class="operator">(</span>Temporary<span class="operator">[</span><span class="number">0</span><span class="operator">:</span><span class="number">7</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">for</span><span class="operator">(</span>PF <span class="operator">=</span> <span class="number">1</span><span class="operator">,</span> i <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> i <span class="operator">&lt;</span> <span class="number">8</span><span class="operator">;</span> <span class="operator">++</span>i<span class="operator">)</span> PF <span class="operator">^=</span> Temporary<span class="operator">[</span>i<span class="operator">]</span><span class="operator">;</span>
CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
OF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
AF <span class="operator">=</span> Undefined<span class="operator">;</span>
</pre>
</td><td>
<p>The OF and CF flags are set to 0. The SF, ZF, and PF flags are set according to the result (see the &quot;Operation&quot; section above). The state of the AF flag is undefined.
</p>
</td></tr><tr><td><strong>UCOMISD</strong><br />Unordered Compare Scalar Double-Precision Floating- Point Values and Set EFLAGS<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 2E /r</code></td>
<td class="grid"><code>UCOMISD xmm1, xmm2/m64</code></td>
<td class="grid">Compare (unordered) the low double-precision floating-point values in xmm1 and xmm2/m64 and set EFLAGS accordingly.</td>
</tr>
</table></td><td>
<p>Performs and unordered compare of the double-precision floating-point values in the low quadwords of source operand 1 (first operand) and source operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).</p>
<p>Source operand 1 is an XMM register; source operand 2 can be an XMM register or a 64 bit memory location.</p>
<p>The UCOMISD instruction differs from the COMISD instruction in that it signals an SIMD floating-point invalid operation exception (#I) only when a source operand is an SNaN. The COMISD instruction signals an invalid operation exception if a source operand is either a QNaN or an SNaN.</p>
<p>The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.</p>
<br />
<pre>Result <span class="operator">=</span> UnorderedCompare<span class="operator">(</span>Source1<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">,</span> Source2<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">switch</span><span class="operator">(</span>Result<span class="operator">)</span> {
	<span class="keyword">case</span> ResultUnordered<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ResultGreaterThan<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ResultLessThan<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ResultEqual<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}

OF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
AF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
SF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>UCOMISS</strong><br />Unordered Compare Scalar Single-Precision Floating- Point Values and Set EFLAGS<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 2E /r</code></td>
<td class="grid"><code>UCOMISS xmm1, xmm2/m32</code></td>
<td class="grid">Compare lower single-precision floating-point value in xmm1 register with lower single-precision floating-point value in xmm2/mem and set the status flags accordingly.</td>
</tr>
</table></td><td>
<p>Performs and unordered compare of the single-precision floating-point values in the low doublewords of the source operand 1 (first operand) and the source operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). In The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).</p>
<p>Source operand 1 is an XMM register; source operand 2 can be an XMM register or a 32 bit memory location.</p>
<p>The UCOMISS instruction differs from the COMISS instruction in that it signals an SIMD floating-point invalid operation exception (#I) only when a source operand is an SNaN. The COMISS instruction signals an invalid operation exception if a source operand is either a QNaN or an SNaN.</p>
<p>The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.</p>
<br />
<pre>Result <span class="operator">=</span> UnorderedCompare<span class="operator">(</span>Source1<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">,</span> Source2<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">)</span><span class="operator">;</span>
<span class="keyword">switch</span><span class="operator">(</span>Result<span class="operator">)</span> {
	<span class="keyword">case</span> ResultUnordered<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ResultGreaterThan<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ResultLessThan<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
	<span class="keyword">case</span> ResultEqual<span class="operator">:</span>
		ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
		PF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		CF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
		<span class="keyword">break</span><span class="operator">;</span>
}

OF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
AF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
SF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>UD2</strong><br />Undefined Instruction<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 0B</code></td>
<td class="grid"><code>UD2</code></td>
<td class="grid">Raise invalid opcode exception.</td>
</tr>
</table></td><td>
<p>Generates an invalid opcode. This instruction is provided for software testing to explicitly generate an invalid opcode. The opcode for this instruction is reserved for this purpose.</p>
<p>Other than raising the invalid opcode exception, this instruction is the same as the NOP instruction.</p>
<br />
<pre>Exception<span class="operator">(</span>UD<span class="operator">)</span><span class="operator">;</span> <span class="comment">//Generates invalid opcode exception</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>UNPCKHPD</strong><br />Unpack and Interleave High Packed Double- Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 15 /r</code></td>
<td class="grid"><code>UNPCKHPD xmm1, xmm2/m128</code></td>
<td class="grid">Unpack and interleave double-precision floating-point values from the high quadwords of xmm1 and xmm2/m128.</td>
</tr>
</table></td><td>
<p>Performs an interleaved unpack of the high double-precision floating-point values from the source operand (second operand) and the destination operand (first operand).</p>
<p>The source operand can be an XMM register or a 128-bit memory location; the destination operand is an XMM register.</p>
<p>When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>UNPCKHPS</strong><br />Unpack and Interleave High Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 15 /r</code></td>
<td class="grid"><code>UNPCKHPS xmm1, xmm2/m128</code></td>
<td class="grid">Unpack and interleave the single-precision floating-point values from high quadwords of xmm1 and xmm2/mem into xmm1.</td>
</tr>
</table></td><td>
<p>Performs an interleaved unpack of the high-order single-precision floating-point values from the source operand (second operand) and the destination operand (first operand).</p>
<p>The source operand can be an XMM register or a 128-bit memory location; the destination operand is an XMM register.</p>
<p>When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>UNPCKLPD</strong><br />Unpack and Interleave Low Packed Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 14 /r</code></td>
<td class="grid"><code>UNPCKLPD xmm1, xmm2/m128</code></td>
<td class="grid">Unpack and interleave the double-precision floating-point values from low quadwords of xmm1 and xmm2/m128.</td>
</tr>
</table></td><td>
<p>Performs an interleaved unpack of the low double-precision floating-point values from the source operand (second operand) and the destination operand (first operand).</p>
<p>The source operand can be an XMM register or a 128-bit memory location; the destination operand is an XMM register.</p>
<p>When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..63</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>UNPCKLPS</strong><br />Unpack and Interleave Low Packed Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 14 /r</code></td>
<td class="grid"><code>UNPCKLPS xmm1, xmm2/m128</code></td>
<td class="grid">Unpack and interleaves the single-precision floating-point values from low quadwords of xmm1 and xmm2/mem into xmm1.</td>
</tr>
</table></td><td>
<p>Performs an interleaved unpack of the low-order single-precision floating-point values from the source operand (second operand) and the destination operand (first operand). The source operand can be an XMM register or a 128-bit memory location; the destination operand is an XMM register.</p>
<p>When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">0..31</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">64..95</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
Destination<span class="operator">[</span><span class="number">96..127</span><span class="operator">]</span> <span class="operator">=</span> Source<span class="operator">[</span><span class="number">32..63</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>VERR/VERW</strong><br />Verify a Segment for Reading or Writing<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 00 /4 VERR r/m16</code></td>
<td class="grid"><code>Set ZF=1 if segment specified with r/m16 can be read.</code></td>
<td class="grid"></td>
</tr>
<tr>
<td class="grid"><code>0F 00 /5 VERW r/m16</code></td>
<td class="grid"><code>Set ZF=1 if segment specified with r/m16 can be written.</code></td>
<td class="grid"></td>
</tr>
</table></td><td>
<p>Verifies whether the code or data segment specified with the source operand is readable (VERR) or writable (VERW) from the current privilege level (CPL). The source operand is a 16-bit register or a memory location that contains the segment selector for the segment to be verified.</p>
<p>If the segment is accessible and readable (VERR) or writable (VERW), the ZF flag is set; otherwise, the ZF flag is cleared. Code segments are never verified as writable. This check cannot be performed on system segments.</p>
<p>To set the ZF flag, the following conditions must be met:</p>
<ul>
<li>The segment selector is not null.</li>
<li>The selector must denote a descriptor within the bounds of the descriptor table (GDT or LDT).</li>
<li>The selector must denote the descriptor of a code or data segment (not that of a system segment or gate).</li>
<li>For the VERR instruction, the segment must be readable.</li>
<li>For the VERW instruction, the segment must be a writable data segment.</li>
<li>If the segment is not a conforming code segment, the segment's DPL must be greater than or equal to (have less or the same privilege as) both the CPL and the segment selector's RPL.</li>
</ul>
<p>The validation performed is the same as is performed when a segment selector is loaded into the DS, ES, FS, or GS register, and the indicated access (read or write) is performed. The segment selector's value cannot result in a protection exception, enabling the software to anticipate possible segment access problems.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>Source<span class="operator">.</span>Offset <span class="operator">&gt;</span> GDTR<span class="operator">.</span>Limit <span class="operator">||</span> Source<span class="operator">.</span>Offset <span class="operator">&gt;</span> LDTR<span class="operator">.</span>Limit<span class="operator">)</span> {
	ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	SegmentDescriptor <span class="operator">=</span> ReadSegmentDescriptor<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
	<span class="keyword">if</span><span class="operator">(</span>SegmentDescriptor<span class="operator">.</span>Type <span class="operator">==</span> <span class="number">0</span> <span class="comment">/*system segment*/</span> <span class="operator">||</span> <span class="operator">(</span><span class="operator">!</span>IsConformingCodeSegment<span class="operator">(</span>SegmentDescriptor<span class="operator">.</span>Type<span class="operator">)</span> <span class="operator">&amp;&amp;</span> <span class="operator">(</span>CPL <span class="operator">&gt;</span> DPL <span class="operator">||</span> RPL <span class="operator">&gt;</span> DPL<span class="operator">)</span><span class="operator">)</span><span class="operator">)</span> ZF <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
	<span class="keyword">else</span> <span class="keyword">if</span><span class="operator">(</span><span class="operator">(</span>Instruction <span class="operator">==</span> VERR <span class="operator">&amp;&amp;</span> IsReadable<span class="operator">(</span>Segment<span class="operator">)</span><span class="operator">)</span> <span class="operator">||</span> <span class="operator">(</span>Instruction <span class="operator">==</span> VERW <span class="operator">&amp;&amp;</span> IsWritable<span class="operator">(</span>Segment<span class="operator">)</span><span class="operator">)</span><span class="operator">)</span> ZF <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
}
</pre>
</td><td>
<p>The ZF flag is set to 1 if the segment is accessible and readable (VERR) or writable (VERW); otherwise, it is set to 0.
</p>
</td></tr><tr><td><strong>WAIT/FWAIT</strong><br />Wait<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>9B</code></td>
<td class="grid"><code>WAIT</code></td>
<td class="grid">Check pending unmasked floating-point exceptions.</td>
</tr>
<tr>
<td class="grid"><code>9B</code></td>
<td class="grid"><code>FWAIT</code></td>
<td class="grid">Check pending unmasked floating-point exceptions.</td>
</tr>
</table></td><td>
<p>Causes the processor to check for and handle pending, unmasked, floating-point exceptions before proceeding. (FWAIT is an alternate mnemonic for WAIT.) This instruction is useful for synchronizing exceptions in critical sections of code. Coding a WAIT instruction after a floating-point instruction insures that any unmasked floating-point exceptions the instruction may raise are handled before the processor can modify the instruction's results. See the section titled &quot;Floating-Point Exception Synchronization&quot; in Chapter 8 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for more information on using the WAIT/FWAIT instruction.</p>
<br />
<pre>CheckForPendingUnmaskedFloatingPointExceptions<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>The C0, C1, C2, and C3 flags are undefined.
</p>
</td></tr><tr><td><strong>WBINVD</strong><br />Write Back and Invalidate Cache<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 09</code></td>
<td class="grid"><code>WBINVD</code></td>
<td class="grid">Write back and flush internal caches; initiate writing-back and flushing of external caches.</td>
</tr>
</table></td><td>
<p>Writes back all modified cache lines in the processor's internal cache to main memory and invalidates (flushes) the internal caches. The instruction then issues a special-function bus cycle that directs external caches to also write back modified data and another bus cycle to indicate that the external caches should be invalidated.</p>
<p>After executing this instruction, the processor does not wait for the external caches to complete their write-back and flushing operations before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache write-back and flush signals.</p>
<p>The WBINVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction. This instruction is also a serializing instruction (see &quot;Serializing Instructions&quot; in Chapter 8 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3).</p>
<p>In situations where cache coherency with main memory is not a concern, software can use the INVD instruction.</p>
<br />
<pre>WriteBack<span class="operator">(</span>InternalCaches<span class="operator">)</span><span class="operator">;</span>
Flush<span class="operator">(</span>InternalCaches<span class="operator">)</span><span class="operator">;</span>
SignalWriteBack<span class="operator">(</span>ExternalCaches<span class="operator">)</span><span class="operator">;</span>
SignalFlush<span class="operator">(</span>ExternalCaches<span class="operator">)</span><span class="operator">;</span>
ContinueExecution<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>WRMSR</strong><br />Write to Model Specific Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 30</code></td>
<td class="grid"><code>WRMSR</code></td>
<td class="grid">Write the value in EDX:EAX to MSR specified by ECX.</td>
</tr>
</table></td><td>
<p>Writes the contents of registers EDX:EAX into the 64-bit model specific register (MSR) specified in the ECX register. The input value loaded into the ECX register is the address of the MSR to be written to. The contents of the EDX register are copied to high-order 32 bits of the selected MSR and the contents of the EAX register are copied to low-order 32 bits of the MSR. Undefined or reserved bits in an MSR should be set to the values previously read.</p>
<p>This instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) will be generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a general protection exception. The processor may also generate a general protection exception if software attempts to write to bits in an MSR marked as Reserved.</p>
<p>When the WRMSR instruction is used to write to an MTRR, the TLBs are invalidated, including the global entries (see &quot;Translation Lookaside Buffers (TLBs)&quot; in Chapter 3 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3).</p>
<p>The MSRs control functions for testability, execution tracing, performance-monitoring and machine check errors. Appendix B, Model-Specific Registers (MSRs), in the IA-32 Intel Architecture Software Developer's Manual, Volume 3, lists all the MSRs that can be read with this instruction and their addresses. Note that each processor family has its own set of MSRs.</p>
<p>The WRMSR instruction is a serializing instruction (see &quot;Serializing Instructions&quot; in Chapter 8 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3).</p>
<p>The CPUID instruction should be used to determine whether MSRs are supported (EDX[5]=1) before using this instruction.</p>
<br />
<pre>MSR<span class="operator">[</span>ECX<span class="operator">]</span> <span class="operator">=</span> EDX<span class="operator">:</span>EAX<span class="operator">;</span>
</pre>
</td><td>
<p>The MSRs and the ability to read them with the WRMSR instruction were introduced into the IA-32 architecture with the Pentium processor. Execution of this instruction by an IA-32 processor earlier than the Pentium processor results in an invalid opcode exception #UD.
</p>
</td></tr><tr><td><strong>XADD</strong><br />Exchange and Add<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F C0 /r</code></td>
<td class="grid"><code>XADD r/m8, r8</code></td>
<td class="grid">Exchange r8 and r/m8; load sum into r/m8.</td>
</tr>
<tr>
<td class="grid"><code>0F C1 /r</code></td>
<td class="grid"><code>XADD r/m16, r16</code></td>
<td class="grid">Exchange r16 and r/m16; load sum into r/m16.</td>
</tr>
<tr>
<td class="grid"><code>0F C1 /r</code></td>
<td class="grid"><code>XADD r/m32, r32</code></td>
<td class="grid">Exchange r32 and r/m32; load sum into r/m32.</td>
</tr>
</table></td><td>
<p>Exchanges the first operand (destination operand) with the second operand (source operand), then loads the sum of the two values into the destination operand. The destination operand can be a register or a memory location; the source operand is a register.</p>
<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<br />
<pre>Temporary <span class="operator">=</span> Source <span class="operator">+</span> Destination<span class="operator">;</span>
Source <span class="operator">=</span> Destination<span class="operator">;</span>
Destination <span class="operator">=</span> Temporary<span class="operator">;</span>
</pre>
</td><td>
<p>The CF, PF, AF, SF, ZF, and OF flags are set according to the result of the addition, which is stored in the destination operand.
</p>
</td></tr><tr><td><strong>XCHG</strong><br />Exchange Register/Memory with Register<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>90+rw</code></td>
<td class="grid"><code>XCHG AX, 16</code></td>
<td class="grid">Exchange r16 with AX.</td>
</tr>
<tr>
<td class="grid"><code>90+rw</code></td>
<td class="grid"><code>XCHG r16, X</code></td>
<td class="grid">Exchange AX with r16.</td>
</tr>
<tr>
<td class="grid"><code>90+rd</code></td>
<td class="grid"><code>XCHG EAX, r32</code></td>
<td class="grid">Exchange r32 with EAX.</td>
</tr>
<tr>
<td class="grid"><code>90+rd</code></td>
<td class="grid"><code>XCHG r32, EAX</code></td>
<td class="grid">Exchange EAX with r32.</td>
</tr>
<tr>
<td class="grid"><code>86 /r</code></td>
<td class="grid"><code>XCHG r/m8, r8</code></td>
<td class="grid">Exchange r8 (byte register) with byte from r/m8.</td>
</tr>
<tr>
<td class="grid"><code>86 /r</code></td>
<td class="grid"><code>XCHG r8, r/m8</code></td>
<td class="grid">Exchange byte from r/m8 with r8 (byte register).</td>
</tr>
<tr>
<td class="grid"><code>87 /r</code></td>
<td class="grid"><code>XCHG r/m16, r16</code></td>
<td class="grid">Exchange r16 with word from r/m16.</td>
</tr>
<tr>
<td class="grid"><code>87 /r</code></td>
<td class="grid"><code>XCHG r16, r/m16</code></td>
<td class="grid">Exchange word from r/m16 with r16.</td>
</tr>
<tr>
<td class="grid"><code>87 /r</code></td>
<td class="grid"><code>XCHG r/m32, r32</code></td>
<td class="grid">Exchange r32 with doubleword from r/m32.</td>
</tr>
<tr>
<td class="grid"><code>87 /r</code></td>
<td class="grid"><code>XCHG r32, r/m32</code></td>
<td class="grid">Exchange doubleword from r/m32 with r32.</td>
</tr>
</table></td><td>
<p>Exchanges the contents of the destination (first) and source (second) operands. The operands can be two general-purpose registers or a register and a memory location. If a memory operand is referenced, the processor's locking protocol is automatically implemented for the duration of the exchange operation, regardless of the presence or absence of the LOCK prefix or of the value of the IOPL. (See the LOCK prefix description in this chapter for more information on the locking protocol.) This instruction is useful for implementing semaphores or similar data structures for process synchronization. (See &quot;Bus Locking&quot; in Chapter 7 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3, for more information on bus locking.) The XCHG instruction can also be used instead of the BSWAP instruction for 16-bit operands.</p>
<br />
<pre>Temporary <span class="operator">=</span> Destination<span class="operator">;</span>
Destination <span class="operator">=</span> Source<span class="operator">;</span>
Source <span class="operator">=</span> Temporary<span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>XLAT/XLATB</strong><br />Table Look-up Translation<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>D7</code></td>
<td class="grid"><code>XLAT m8</code></td>
<td class="grid">Set AL to memory byte DS:[(E)BX + unsigned AL].</td>
</tr>
<tr>
<td class="grid"><code>D7</code></td>
<td class="grid"><code>XLATB</code></td>
<td class="grid">Set AL to memory byte DS:[(E)BX + unsigned AL].</td>
</tr>
</table></td><td>
<p>Locates a byte entry in a table in memory, using the contents of the AL register as a table index, then copies the contents of the table entry back into the AL register. The index in the AL register is treated as an unsigned integer. The XLAT and XLATB instructions get the base address of the table in memory from either the DS:EBX or the DS:BX registers (depending on the addresssize attribute of the instruction, 32 or 16, respectively). (The DS segment may be overridden with a segment override prefix.) At the assembly-code level, two forms of this instruction are allowed: the &quot;explicit-operand&quot; form and the &quot;no-operand&quot; form. The explicit-operand form (specified with the XLAT mnemonic) allows the base address of the table to be specified explicitly with a symbol. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the symbol does not have to specify the correct base address. The base address is always specified by the DS:(E)BX registers, which must be loaded correctly before the XLAT instruction is executed.</p>
<p>The no-operands form (XLATB) provides a &quot;short form&quot; of the XLAT instructions. Here also the processor assumes that the DS:(E)BX registers contain the base address of the table.</p>
<br />
<pre><span class="keyword">if</span><span class="operator">(</span>AddressSize <span class="operator">==</span> <span class="number">16</span><span class="operator">)</span> AL <span class="operator">=</span> DS<span class="operator">:</span>BX <span class="operator">+</span> ZeroExtend<span class="operator">(</span>AL<span class="operator">)</span><span class="operator">;</span>
<span class="comment">//AddressSize = 32</span>
<span class="keyword">else</span> AL <span class="operator">=</span> DS<span class="operator">:</span>EBX <span class="operator">+</span> ZeroExtend<span class="operator">(</span>AL<span class="operator">)</span><span class="operator">;</span>
</pre>
</td><td>
<p>None.
</p>
</td></tr><tr><td><strong>XOR</strong><br />Logical Exclusive OR<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>34 ib</code></td>
<td class="grid"><code>XOR AL,imm8</code></td>
<td class="grid">AL XOR imm8.</td>
</tr>
<tr>
<td class="grid"><code>35 iw</code></td>
<td class="grid"><code>XOR AX,imm16</code></td>
<td class="grid">AX XOR imm16.</td>
</tr>
<tr>
<td class="grid"><code>35 id</code></td>
<td class="grid"><code>XOR EAX,imm32</code></td>
<td class="grid">EAX XOR imm32.</td>
</tr>
<tr>
<td class="grid"><code>80 /6 ib</code></td>
<td class="grid"><code>XOR r/m8,imm8 r/m8</code></td>
<td class="grid">XOR imm8.</td>
</tr>
<tr>
<td class="grid"><code>81 /6 iw</code></td>
<td class="grid"><code>XOR r/m16,imm16</code></td>
<td class="grid">r/m16 XOR imm16.</td>
</tr>
<tr>
<td class="grid"><code>81 /6 id</code></td>
<td class="grid"><code>XOR r/m32,imm32</code></td>
<td class="grid">r/m32 XOR imm32.</td>
</tr>
<tr>
<td class="grid"><code>83 /6 ib</code></td>
<td class="grid"><code>XOR r/m16,imm8</code></td>
<td class="grid">r/m16 XOR imm8 (sign-extended).</td>
</tr>
<tr>
<td class="grid"><code>83 /6 ib</code></td>
<td class="grid"><code>XOR r/m32,imm8</code></td>
<td class="grid">r/m32 XOR imm8 (sign-extended).</td>
</tr>
<tr>
<td class="grid"><code>30 /r</code></td>
<td class="grid"><code>XOR r/m8,r8</code></td>
<td class="grid">r/m8 XOR r8.</td>
</tr>
<tr>
<td class="grid"><code>31 /r</code></td>
<td class="grid"><code>XOR r/m16,r16</code></td>
<td class="grid">r/m16 XOR r16.</td>
</tr>
<tr>
<td class="grid"><code>31 /r</code></td>
<td class="grid"><code>XOR r/m32,r32</code></td>
<td class="grid">r/m32 XOR r32.</td>
</tr>
<tr>
<td class="grid"><code>32 /r</code></td>
<td class="grid"><code>XOR r8,r/m8</code></td>
<td class="grid">r8 XOR r/m8.</td>
</tr>
<tr>
<td class="grid"><code>33 /r</code></td>
<td class="grid"><code>XOR r16,r/m16</code></td>
<td class="grid">r16 XOR r/m16.</td>
</tr>
<tr>
<td class="grid"><code>33 /r</code></td>
<td class="grid"><code>XOR r32,r/m32</code></td>
<td class="grid">r32 XOR r/m32.</td>
</tr>
</table></td><td>
<p>Performs a bitwise exclusive OR (XOR) operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is 1 if the corresponding bits of the operands are different; each bit is 0 if the corresponding bits are the same.</p>
<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>
<br />
<pre>Destination <span class="operator">=</span> Destination <span class="operator">^</span> Source<span class="operator">;</span>
</pre>
</td><td>
<p>The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined.
</p>
</td></tr><tr><td><strong>XORPD</strong><br />Bitwise Logical XOR for Double-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>66 0F 57 /r</code></td>
<td class="grid"><code>XORPD xmm1, xmm2/m128</code></td>
<td class="grid">Bitwise exclusive-OR of xmm2/m128 and xmm1..</td>
</tr>
</table></td><td>
<p>Performs a bitwise logical exclusive-OR of the two packed double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the result in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">^</span> Source<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td><code>CPUID</code></td></tr><tr><td><strong>XORPS</strong><br />Bitwise Logical XOR for Single-Precision Floating-Point Values<br /><table class="box">
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td class="grid"><code>0F 57 /r</code></td>
<td class="grid"><code>XORPS xmm1, xmm2/m128</code></td>
<td class="grid">Bitwise exclusive-OR of xmm2/m128 and xmm1.</td>
</tr>
</table></td><td>
<p>Performs a bitwise logical exclusive-OR of the four packed single-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the result in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p>
<br />
<pre>Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">=</span> Destination<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span> <span class="operator">^</span> Source<span class="operator">[</span><span class="number">0..127</span><span class="operator">]</span><span class="operator">;</span>
</pre>
</td><td><code>CPUID</code></td></tr></table>
